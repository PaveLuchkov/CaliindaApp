{
  "project_info": {
    "name": "auth",
    "path": "/Users/paveluckov/StudioProjects/CaliindaApp/app/src/main/java/com/lpavs/caliinda/core/data/auth",
    "generated_at": "2025-08-06T12:31:02.535821",
    "total_files": 3,
    "total_size": 17784
  },
  "structure": {
    "AuthViewModel.kt": {
      "type": "file",
      "info": {
        "size": 66,
        "last_modified": "2025-08-06T12:31:02.50724",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    "AuthManager.kt": {
      "type": "file",
      "info": {
        "size": 17332,
        "last_modified": "2025-08-06T12:31:02.521241",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    "AuthState.kt": {
      "type": "file",
      "info": {
        "size": 386,
        "last_modified": "2025-08-06T12:31:02.529108",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    }
  },
  "files": [
    {
      "path": "AuthViewModel.kt",
      "content": "package com.lpavs.caliinda.core.data.auth\n\nclass AuthViewModel {\n}",
      "info": {
        "size": 66,
        "last_modified": "2025-08-06T12:31:02.50724",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "AuthManager.kt",
      "content": "package com.lpavs.caliinda.core.data.auth\n\nimport android.app.Activity\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.util.Log\nimport androidx.annotation.WorkerThread\nimport androidx.core.net.toUri\nimport androidx.credentials.ClearCredentialStateRequest\nimport androidx.credentials.CredentialManager\nimport androidx.credentials.CustomCredential\nimport androidx.credentials.GetCredentialRequest\nimport androidx.credentials.GetCredentialResponse\nimport androidx.credentials.exceptions.GetCredentialException\nimport com.google.android.gms.auth.api.identity.AuthorizationClient\nimport com.google.android.gms.auth.api.identity.AuthorizationRequest\nimport com.google.android.gms.auth.api.identity.Identity\nimport com.google.android.gms.common.api.Scope\nimport com.google.android.libraries.identity.googleid.GetGoogleIdOption\nimport com.google.android.libraries.identity.googleid.GoogleIdTokenCredential\nimport com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException\nimport com.google.api.services.calendar.CalendarScopes\nimport com.lpavs.caliinda.core.data.auth.AuthEvent\nimport com.lpavs.caliinda.core.data.di.BackendUrl\nimport com.lpavs.caliinda.core.data.di.WebClientId\nimport com.lpavs.caliinda.core.data.repository.CalendarRepository\nimport dagger.Lazy\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.tasks.await\nimport kotlinx.coroutines.withContext\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.Request\nimport okhttp3.RequestBody.Companion.toRequestBody\nimport org.json.JSONException\nimport org.json.JSONObject\nimport java.util.UUID\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass AuthManager\n@Inject\nconstructor(\n    @ApplicationContext private val context: Context,\n    private val okHttpClient: OkHttpClient,\n    @BackendUrl private val backendBaseUrl: String,\n    @WebClientId private val webClientId: String,\n    private val sharedPreferences: SharedPreferences\n) {\n  private val TAG = \"AuthManager\"\n\n  private companion object {\n    const val BACKEND_TOKEN_KEY = \"backend_auth_token\"\n    const val USER_EMAIL_KEY = \"user_email\"\n    const val USER_DISPLAY_NAME_KEY = \"user_displayName\"\n    const val USER_PHOTO_URL_KEY = \"user_photoUrl\"\n  }\n\n  private val managerScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)\n\n  private val _authState = MutableStateFlow(AuthState())\n  val authState: StateFlow<AuthState> = _authState.asStateFlow()\n\n  private val _authEvents = MutableSharedFlow<AuthEvent>()\n  val authEvents: SharedFlow<AuthEvent> = _authEvents.asSharedFlow()\n\n  // --- Google Sign-In Клиент ---\n  private val credentialManager: CredentialManager = CredentialManager.create(context)\n  private val authorizationClient: AuthorizationClient = Identity.getAuthorizationClient(context)\n\n  private var pendingIdToken: String? = null\n\n  init {\n    Log.d(TAG, \"Initializing AuthManager with Credential Manager...\")\n    restoreStateFromStorage()\n  }\n\n  private fun restoreStateFromStorage() {\n    try {\n      Log.d(TAG, \"Starting state restoration from EncryptedSharedPreferences...\")\n      Log.d(TAG, \"Process ID: ${android.os.Process.myPid()}\")\n\n      val token = getBackendAuthToken()\n      Log.d(\n          TAG,\n          \"Token restoration result: ${if (token != null) \"FOUND token\" else \"NO token found\"}\")\n\n      if (token != null) {\n        val email = sharedPreferences.getString(USER_EMAIL_KEY, null)\n        val displayName = sharedPreferences.getString(USER_DISPLAY_NAME_KEY, null)\n        val photoUrlString = sharedPreferences.getString(USER_PHOTO_URL_KEY, null)\n\n        Log.d(TAG, \"Restoring user data: email=$email, displayName=$displayName\")\n\n        val photoUri =\n            if (!photoUrlString.isNullOrEmpty()) {\n              photoUrlString.toUri()\n            } else {\n              null\n            }\n\n        _authState.value =\n            AuthState(\n                isSignedIn = true,\n                userEmail = email,\n                displayName = displayName,\n                photoUrl = photoUri,\n                isLoading = false,\n                authError = null)\n        Log.i(TAG, \"✅ Successfully restored session for $email from EncryptedSharedPreferences\")\n      } else {\n        Log.d(TAG, \"❌ No token found, setting signed out state\")\n        _authState.value = AuthState(isLoading = false)\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception during state restoration from EncryptedSharedPreferences\", e)\n      _authState.value = AuthState(isLoading = false, authError = \"Failed to restore session\")\n    }\n  }\n\n  fun signIn(activity: Activity) {\n    managerScope.launch {\n      _authState.update { it.copy(isLoading = true, authError = null) }\n      try {\n        val googleIdOption = buildGoogleIdOption(filterByAuthorizedAccounts = false)\n        val request = GetCredentialRequest.Builder().addCredentialOption(googleIdOption).build()\n        val result = credentialManager.getCredential(activity, request)\n        handleAuthenticationSuccess(result)\n      } catch (e: GetCredentialException) {\n        Log.w(TAG, \"GetCredentialException: ${e.message}\", e)\n        _authState.update { it.copy(isLoading = false, authError = \"Вход был отменен.\") }\n      } catch (e: Exception) {\n        Log.e(TAG, \"Unknown error during sign-in\", e)\n        _authState.update {\n          it.copy(isLoading = false, authError = \"Произошла неизвестная ошибка.\")\n        }\n      }\n    }\n  }\n\n  private suspend fun handleAuthenticationSuccess(result: GetCredentialResponse) {\n    val credential = result.credential\n    if (credential is CustomCredential &&\n        credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {\n      try {\n        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)\n        val idToken = googleIdTokenCredential.idToken\n        val userEmail = googleIdTokenCredential.id\n        val displayName = googleIdTokenCredential.displayName\n        val photoUrl = googleIdTokenCredential.profilePictureUri?.toString()\n        saveUserInfo(userEmail, displayName, photoUrl)\n        Log.i(TAG, \"Authentication Success! Email: ${googleIdTokenCredential.id}\")\n\n        this.pendingIdToken = idToken\n        _authState.update {\n          it.copy(\n              isLoading = true,\n              userEmail = googleIdTokenCredential.id,\n              displayName = googleIdTokenCredential.displayName,\n              photoUrl = googleIdTokenCredential.profilePictureUri,\n          )\n        }\n        requestCalendarAuthorization()\n      } catch (e: GoogleIdTokenParsingException) {\n        Log.e(TAG, \"Error parsing Google ID token\", e)\n        signOutInternally(\"Failed to process Google token\")\n      }\n    } else {\n      Log.w(TAG, \"Received an unexpected credential type: ${credential.type}\")\n      signOutInternally(\"Unsupported credential type.\")\n    }\n  }\n\n  private suspend fun requestCalendarAuthorization() {\n    val requiredScopes = Scope(CalendarScopes.CALENDAR)\n    val authRequest =\n        AuthorizationRequest.builder()\n            .setRequestedScopes(listOf(requiredScopes))\n            .requestOfflineAccess(webClientId)\n            .build()\n    try {\n      val result = authorizationClient.authorize(authRequest).await()\n      if (result.hasResolution()) {\n        Log.d(TAG, \"Authorization requires user consent.\")\n        _authState.update { it.copy(authorizationIntent = result.pendingIntent) }\n      } else {\n        Log.d(TAG, \"Authorization succeeded without user consent.\")\n        val authCode = result.serverAuthCode\n        if (authCode != null) {\n          handleAuthorizationSuccess(authCode)\n        } else {\n          Log.e(TAG, \"Authorization failed with no serverAuthCode.\")\n          signOutInternally(\"Authorization failed with no serverAuthCode.\")\n        }\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"Error during authorization\", e)\n      signOutInternally(\"Error during authorization\")\n    }\n  }\n\n  fun handleAuthorizationResult(intent: Intent) {\n    managerScope.launch {\n      val authorizationResult = authorizationClient.getAuthorizationResultFromIntent(intent)\n      val authCode = authorizationResult.serverAuthCode\n      if (authCode != null) {\n        Log.i(TAG, \"User granted permissions successfully.\")\n        handleAuthorizationSuccess(authCode)\n      } else {\n        Log.w(TAG, \"User denied permissions or an error occurred.\")\n        signOutInternally(\"Calendar permission is required to continue.\")\n      }\n      _authState.update { it.copy(authorizationIntent = null) }\n    }\n  }\n\n  private suspend fun handleAuthorizationSuccess(authCode: String) {\n    val idToken = pendingIdToken\n    if (idToken == null) {\n      Log.e(TAG, \"No pending ID token found for authorization.\")\n      signOutInternally(\"No pending ID token found for authorization.\")\n      return\n    }\n    Log.d(TAG, \"Sending authorization code to backend...\")\n    val exchangeSuccess = sendAuthInfoToBackend(idToken, authCode)\n\n    if (exchangeSuccess) {\n      Log.i(TAG, \"Successfully exchanged tokens with backend.\")\n      _authState.update {\n        it.copy(\n            isSignedIn = true,\n            isLoading = false,\n            authError = null,\n        )\n      }\n      pendingIdToken = null\n    } else {\n      Log.e(TAG, \"Failed to exchange tokens with backend.\")\n      signOutInternally(\"Server could not verify your session.\")\n    }\n  }\n\n  fun signOut() {\n    managerScope.launch {\n      _authState.update { it.copy(isLoading = true) }\n      try {\n        credentialManager.clearCredentialState(ClearCredentialStateRequest())\n        Log.i(TAG, \"Successfully cleared credentials.\")\n      } catch (e: Exception) {\n        Log.e(TAG, \"Error clearing credentials\", e)\n      } finally {\n        _authEvents.emit(AuthEvent.SignedOut)\n        signOutInternally(\"You have been signed out.\")\n      }\n    }\n  }\n\n  private fun signOutInternally(error: String?) {\n    clearBackendToken()\n    clearUserInfo()\n    pendingIdToken = null\n    _authState.value = AuthState(isSignedIn = false, isLoading = false, authError = error)\n    Log.i(TAG, \"Internal sign out completed. Error: $error\")\n  }\n\n  private fun buildGoogleIdOption(\n      filterByAuthorizedAccounts: Boolean,\n      autoSelect: Boolean = false,\n  ): GetGoogleIdOption {\n    return GetGoogleIdOption.Builder()\n        .setFilterByAuthorizedAccounts(filterByAuthorizedAccounts)\n        .setServerClientId(webClientId)\n        .setAutoSelectEnabled(autoSelect)\n        .setNonce(generateNonce())\n        .build()\n  }\n\n  private fun generateNonce(): String {\n    return UUID.randomUUID().toString() // В проде можно другой\n  }\n\n  fun clearAuthError() {\n    _authState.update { it.copy(authError = null) }\n  }\n\n  fun clearAuthorizationIntent() {\n    _authState.update { it.copy(authorizationIntent = null) }\n  }\n\n  @WorkerThread\n  private suspend fun sendAuthInfoToBackend(idToken: String, authCode: String): Boolean =\n      withContext(Dispatchers.IO) {\n        Log.i(TAG, \"Sending Auth Info (JSON) to /auth/google/exchange\")\n        val jsonObject =\n            JSONObject().apply {\n              put(\"id_token\", idToken)\n              put(\"auth_code\", authCode)\n            }\n        val requestBody =\n            jsonObject.toString().toRequestBody(\"application/json; charset=utf-8\".toMediaType())\n        val request =\n            Request.Builder().url(\"$backendBaseUrl/auth/google/exchange\").post(requestBody).build()\n\n        try {\n          okHttpClient.newCall(request).execute().use { response ->\n            val responseBodyString = response.body?.string()\n            if (!response.isSuccessful) {\n              Log.e(TAG, \"Backend error exchanging code: ${response.code} - $responseBodyString\")\n              false\n            } else {\n              Log.i(TAG, \"Backend successfully exchanged tokens. Response: $responseBodyString\")\n              // ----- НОВАЯ ЛОГИКА: ИЗВЛЕКАЕМ И СОХРАНЯЕМ ТОКЕН -----\n              try {\n                val jsonResponse = responseBodyString?.let { JSONObject(it) }\n                val backendToken = jsonResponse?.optString(\"token\", null.toString())\n                if (backendToken != null) { // Доп. проверка на строку \"null\" на всякий случай\n                  saveBackendToken(backendToken)\n                  true // Успех\n                } else {\n                  Log.e(\n                      TAG, \"Backend response is successful, but 'token' field is missing or null.\")\n                  false\n                }\n              } catch (e: JSONException) {\n                Log.e(TAG, \"Failed to parse backend token response.\", e)\n                false\n              }\n            }\n          }\n        } catch (e: Exception) {\n          Log.e(TAG, \"Error processing backend response for auth exchange\", e)\n          false\n        }\n      }\n\n  fun getBackendAuthToken(): String? {\n    return try {\n      Log.d(TAG, \"Attempting to retrieve backend token with key: '$BACKEND_TOKEN_KEY'\")\n\n      val token = sharedPreferences.getString(BACKEND_TOKEN_KEY, null)\n\n      if (token != null) {\n        Log.d(TAG, \"✅ Backend token FOUND in EncryptedSharedPreferences (length: ${token.length})\")\n        Log.d(TAG, \"Token preview: ${token.take(20)}...\")\n      } else {\n        Log.w(TAG, \"❌ Backend token NOT FOUND in EncryptedSharedPreferences\")\n\n        // Дополнительная диагностика\n        val hasKey = sharedPreferences.contains(BACKEND_TOKEN_KEY)\n        Log.d(TAG, \"Key '$BACKEND_TOKEN_KEY' exists in preferences: $hasKey\")\n\n        // Проверим все ключи\n        val allKeys = sharedPreferences.all.keys\n        Log.d(TAG, \"All keys in EncryptedSharedPreferences: $allKeys\")\n      }\n\n      token\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while retrieving backend token from EncryptedSharedPreferences\", e)\n      null\n    }\n  }\n\n  private fun saveBackendToken(token: String) {\n    try {\n      Log.d(TAG, \"Attempting to save backend token with key: '$BACKEND_TOKEN_KEY'\")\n\n      val success = sharedPreferences.edit().putString(BACKEND_TOKEN_KEY, token).commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ Backend token saved successfully to EncryptedSharedPreferences\")\n\n        // Проверяем, что токен действительно сохранился\n        val savedToken = sharedPreferences.getString(BACKEND_TOKEN_KEY, null)\n        if (savedToken == token) {\n          Log.d(TAG, \"✅ Token verification successful - token matches\")\n        } else {\n          Log.e(\n              TAG,\n              \"❌ Token verification FAILED! Expected: ${token.take(20)}..., Got: ${savedToken?.take(20) ?: \"null\"}\")\n        }\n      } else {\n        Log.e(TAG, \"❌ Failed to save backend token - commit() returned false\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while saving backend token to EncryptedSharedPreferences\", e)\n    }\n  }\n\n  private fun clearBackendToken() {\n    try {\n      Log.d(TAG, \"Clearing backend token with key: '$BACKEND_TOKEN_KEY'\")\n      val success = sharedPreferences.edit().remove(BACKEND_TOKEN_KEY).commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ Backend token cleared successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to clear backend token\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while clearing backend token\", e)\n    }\n  }\n\n  private fun saveUserInfo(email: String?, displayName: String?, photoUrl: String?) {\n    try {\n      Log.d(TAG, \"Saving user info to EncryptedSharedPreferences...\")\n\n      val success =\n          sharedPreferences\n              .edit()\n              .putString(USER_EMAIL_KEY, email)\n              .putString(USER_DISPLAY_NAME_KEY, displayName)\n              .putString(USER_PHOTO_URL_KEY, photoUrl)\n              .commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ User info saved successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to save user info\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while saving user info to EncryptedSharedPreferences\", e)\n    }\n  }\n\n  private fun clearUserInfo() {\n    try {\n      val success =\n          sharedPreferences\n              .edit()\n              .remove(USER_EMAIL_KEY)\n              .remove(USER_DISPLAY_NAME_KEY)\n              .remove(USER_PHOTO_URL_KEY)\n              .commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ User info cleared successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to clear user info\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while clearing user info\", e)\n    }\n  }\n}\n\n\nsealed class AuthEvent {\n  object SignedOut : AuthEvent()\n}",
      "info": {
        "size": 17332,
        "last_modified": "2025-08-06T12:31:02.521241",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "AuthState.kt",
      "content": "package com.lpavs.caliinda.core.data.auth\n\nimport android.app.PendingIntent\nimport android.net.Uri\n\ndata class AuthState(\n    val isSignedIn: Boolean = false,\n    val userEmail: String? = null,\n    val authError: String? = null,\n    val isLoading: Boolean = false,\n    val displayName: String? = null,\n    val photoUrl: Uri? = null,\n    val authorizationIntent: PendingIntent? = null\n)\n",
      "info": {
        "size": 386,
        "last_modified": "2025-08-06T12:31:02.529108",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    }
  ]
}