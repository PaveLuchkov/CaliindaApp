{
  "project_info": {
    "name": "event_management",
    "path": "/Users/paveluckov/StudioProjects/CaliindaApp/app/src/main/java/com/lpavs/caliinda/feature/event_management",
    "generated_at": "2025-08-06T10:04:47.851636",
    "total_files": 11,
    "total_size": 137828
  },
  "structure": {
    "ui": {
      "details": {
        "EventDetailsDialog.kt": {
          "type": "file",
          "info": {
            "size": 9343,
            "last_modified": "2025-08-06T10:04:47.800724",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      },
      "shared": {
        "sections": {
          "TimeSection.kt": {
            "type": "file",
            "info": {
              "size": 30731,
              "last_modified": "2025-08-06T10:04:47.817518",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "NameSection.kt": {
            "type": "file",
            "info": {
              "size": 1869,
              "last_modified": "2025-08-06T10:04:47.826618",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "suggestions": {
            "SuggestionsViewModel.kt": {
              "type": "file",
              "info": {
                "size": 2037,
                "last_modified": "2025-08-06T10:04:47.834012",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "getTimeBonus.kt": {
              "type": "file",
              "info": {
                "size": 1763,
                "last_modified": "2025-08-06T10:04:47.838576",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "getSuggestedEventNames.kt": {
              "type": "file",
              "info": {
                "size": 5259,
                "last_modified": "2025-08-06T10:04:47.840281",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          }
        },
        "InteractiveFields.kt": {
          "type": "file",
          "info": {
            "size": 5551,
            "last_modified": "2025-08-06T10:04:47.842359",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        },
        "GeneralElements.kt": {
          "type": "file",
          "info": {
            "size": 10681,
            "last_modified": "2025-08-06T10:04:47.84392",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      },
      "edit": {
        "EditEventScreen.kt": {
          "type": "file",
          "info": {
            "size": 18672,
            "last_modified": "2025-08-06T10:04:47.845764",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      },
      "create": {
        "CreateEventScreen.kt": {
          "type": "file",
          "info": {
            "size": 19249,
            "last_modified": "2025-08-06T10:04:47.847769",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      }
    },
    "vm": {
      "EventManagementViewModel.kt": {
        "type": "file",
        "info": {
          "size": 32673,
          "last_modified": "2025-08-06T10:04:47.849733",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    }
  },
  "files": [
    {
      "path": "ui/details/EventDetailsDialog.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.details\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.wrapContentHeight\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material.icons.filled.LocationOn\nimport androidx.compose.material.icons.filled.Repeat\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FilledIconButton\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.MaterialShapes\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.minimumInteractiveComponentSize\nimport androidx.compose.material3.toShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.rotate\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.window.Dialog\nimport androidx.compose.ui.window.DialogProperties\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.ui.util.DateTimeFormatterUtil\nimport com.lpavs.caliinda.core.ui.util.DateTimeFormatterUtil.formatRRule\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils.parseToInstant\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun CustomEventDetailsDialog(\n    event: EventDto,\n    userTimeZone: String,\n    onDismissRequest: () -> Unit,\n    viewModel: CalendarViewModel,\n    eventManagementViewModel: EventManagementViewModel\n) {\n  val context = LocalContext.current\n  val currentLocale = LocalConfiguration.current.getLocales().get(0)\n  val timeFormatterLambda: (EventDto) -> String =\n      remember(viewModel, userTimeZone, currentLocale) {\n        { event ->\n          DateTimeFormatterUtil.formatEventDetailsTime(context, event, userTimeZone, currentLocale)\n        }\n      }\n  val currentTime by viewModel.currentTime.collectAsStateWithLifecycle()\n  val isCurrent =\n      remember(currentTime, event.startTime, event.endTime) {\n        val start = parseToInstant(event.startTime, userTimeZone)\n        val end = parseToInstant(event.endTime, userTimeZone)\n        start != null && end != null && !currentTime.isBefore(start) && currentTime.isBefore(end)\n      }\n  Dialog(\n      onDismissRequest = onDismissRequest,\n      properties =\n          DialogProperties(\n              dismissOnBackPress = true,\n              dismissOnClickOutside = true,\n              usePlatformDefaultWidth = false)) {\n        Surface(\n            modifier = Modifier.fillMaxWidth(0.9f).wrapContentHeight(),\n            shape = RoundedCornerShape(25.dp),\n            color = if (!isCurrent) colorScheme.primaryContainer else colorScheme.tertiaryContainer,\n            tonalElevation = 8.dp) {\n              val onCardText =\n                  if (!isCurrent) colorScheme.onPrimaryContainer\n                  else colorScheme.onTertiaryContainer\n              Box(modifier = Modifier.fillMaxWidth()) {\n                Box(\n                    modifier =\n                        Modifier.align(Alignment.BottomEnd)\n                            .size(250.dp)\n                            .rotate(75f)\n                            .offset(y = (-50).dp, x = 50.dp)\n                            .clip(MaterialShapes.Cookie7Sided.toShape())\n                            .border(\n                                width = 2.dp,\n                                color = onCardText.copy(alpha = 0.2f),\n                                shape = MaterialShapes.Cookie7Sided.toShape())\n                            .background(onCardText.copy(alpha = 0f))) {}\n\n                Column(\n                    modifier =\n                        Modifier.padding(top = 24.dp, start = 24.dp, end = 24.dp, bottom = 12.dp),\n                    horizontalAlignment = Alignment.Start) {\n                      Text(\n                          text = event.summary,\n                          style = typography.displaySmall.copy(fontWeight = FontWeight.SemiBold),\n                          color = onCardText)\n                      Spacer(modifier = Modifier.height(2.dp))\n                      Row {\n                        Text(\n                            text = timeFormatterLambda(event),\n                            color = onCardText,\n                            style = typography.headlineSmall.copy(fontWeight = FontWeight.Normal),\n                            maxLines = 2)\n                      }\n                      Spacer(modifier = Modifier.height(16.dp))\n\n                      if (!event.description.isNullOrBlank()) {\n                        Text(\n                            text = event.description,\n                            style = typography.bodyMedium,\n                            color = onCardText)\n                        Spacer(modifier = Modifier.height(16.dp))\n                      }\n\n                      if (!event.location.isNullOrBlank()) {\n                        DetailRow(Icons.Filled.LocationOn, event.location, color = onCardText)\n                        Spacer(modifier = Modifier.height(16.dp))\n                      }\n\n                      if (!event.recurrenceRule.isNullOrEmpty()) {\n                        DetailRow(\n                            Icons.Filled.Repeat,\n                            formatRRule(event.recurrenceRule, zoneIdString = userTimeZone),\n                            color = onCardText)\n                      }\n                      Spacer(modifier = Modifier.height(20.dp))\n                      Row(\n                          modifier = Modifier.fillMaxWidth(),\n                          verticalAlignment = Alignment.CenterVertically,\n                          horizontalArrangement = Arrangement.End) {\n                            Button(\n                                onClick = { eventManagementViewModel.requestEditEvent(event) },\n                                contentPadding = PaddingValues(horizontal = 12.dp)) {\n                                  Icon(Icons.Filled.Edit, contentDescription = \"Edit\")\n                                  Spacer(Modifier.size(ButtonDefaults.IconSpacing))\n                                  Text(\"Edit\") // Или локализованная строка\n                                }\n                            //                    Spacer(modifier = Modifier.width(4.dp))\n                            FilledIconButton(\n                                onClick = {\n                                  eventManagementViewModel.requestDeleteConfirmation(event)\n                                },\n                                modifier =\n                                    Modifier.minimumInteractiveComponentSize()\n                                        .size(\n                                            IconButtonDefaults.smallContainerSize(\n                                                IconButtonDefaults.IconButtonWidthOption.Narrow)),\n                                shape = IconButtonDefaults.smallRoundShape) {\n                                  Icon(\n                                      imageVector = Icons.Filled.Delete,\n                                      contentDescription = \"Delete\",\n                                  )\n                                }\n                          }\n                    }\n              }\n            }\n      }\n}\n\n@Composable\nprivate fun DetailRow(icon: ImageVector, value: String, color: Color) {\n  Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {\n    Icon(imageVector = icon, contentDescription = \"Описание иконки\")\n    Spacer(Modifier.size(ButtonDefaults.IconSpacing))\n    Text(text = value, style = typography.bodyLarge, color = color)\n    Spacer(modifier = Modifier.height(8.dp))\n  }\n}\n",
      "info": {
        "size": 9343,
        "last_modified": "2025-08-06T10:04:47.800724",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/sections/TimeSection.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections\n\nimport android.text.format.DateFormat\nimport android.util.Log\nimport androidx.annotation.StringRes\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.animateContentSize\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.slideOutVertically\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.horizontalScroll\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material3.FilterChip\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.input.ImeAction\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.event_management.ui.shared.DatePickerField\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerField\nimport java.time.DayOfWeek\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter\nimport java.time.format.FormatStyle\nimport java.time.format.TextStyle\nimport java.util.Locale\n\nenum class RecurrenceEndType {\n  NEVER,\n  DATE,\n  COUNT\n}\n\ndata class EventDateTimeState(\n    val startDate: LocalDate,\n    val startTime: LocalTime?,\n    val endDate: LocalDate,\n    val endTime: LocalTime?,\n    val isAllDay: Boolean,\n    val isRecurring: Boolean,\n    val recurrenceRule: String? = null,\n    val selectedWeekdays: Set<DayOfWeek> = emptySet(),\n    val recurrenceEndType: RecurrenceEndType = RecurrenceEndType.NEVER,\n    val recurrenceEndDate: LocalDate? = null,\n    val recurrenceCount: Int? = null\n)\n\n@Composable\nfun EventDateTimePicker(\n    modifier: Modifier = Modifier,\n    state: EventDateTimeState,\n    onStateChange: (EventDateTimeState) -> Unit,\n    isLoading: Boolean = false,\n    onRequestShowStartDatePicker: () -> Unit,\n    onRequestShowStartTimePicker: () -> Unit,\n    onRequestShowEndDatePicker: () -> Unit,\n    onRequestShowEndTimePicker: () -> Unit,\n    onRequestShowRecurrenceEndDatePicker: () -> Unit,\n) {\n  Log.d(\"EventDateTimePicker\", \"Received state: $state\")\n  var isAllDay by remember { mutableStateOf(state.isAllDay) }\n  var isOneDay by remember { mutableStateOf(state.startDate == state.endDate) }\n\n  var dateTimeError by remember { mutableStateOf<String?>(null) }\n  val context = LocalContext.current\n\n  val allDay = stringResource(R.string.all_day)\n  val oneDay = stringResource(R.string.one_day)\n  val recEvent = stringResource(R.string.recurrence_event)\n  val endsLabel = stringResource(R.string.recurrence_ends)\n  val endNeverLabel = stringResource(R.string.recurrence_end_never)\n  val endDateLabel = stringResource(R.string.recurrence_end_date)\n  val endCountLabel = stringResource(R.string.recurrence_end_count)\n  val recurrenceCountFieldLabel = stringResource(R.string.recurrence_count_field)\n\n  val weekdays = remember { DayOfWeek.entries.toTypedArray() }\n\n  // --- Форматтеры для отображения (без изменений) ---\n  val deviceDateFormatter = remember {\n    DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.getDefault())\n  }\n  val deviceTimeFormatter =\n      remember(context) {\n        val pattern = if (DateFormat.is24HourFormat(context)) \"HH:mm\" else \"h:mm a\"\n        DateTimeFormatter.ofPattern(pattern, Locale.getDefault())\n      }\n  LaunchedEffect(state.isAllDay) {\n    if (isAllDay != state.isAllDay) {\n      isAllDay = state.isAllDay\n    }\n  }\n  LaunchedEffect(state.startDate, state.endDate) {\n    val actualIsOneDay = state.startDate == state.endDate\n    if (isOneDay != actualIsOneDay) {\n      isOneDay = actualIsOneDay\n    }\n  }\n\n  LaunchedEffect(state) {\n    dateTimeError = null\n    val actualIsOneDay = state.startDate == state.endDate\n\n    if (!actualIsOneDay && state.endDate.isBefore(state.startDate)) {\n      dateTimeError = context.getString(R.string.error_end_date_before_start)\n    } else if (!state.isAllDay) {\n      if (state.startTime == null) {\n        dateTimeError = context.getString(R.string.error_start_time_missing)\n      } else if (state.endTime == null) {\n        dateTimeError = context.getString(R.string.error_end_time_missing)\n      } else {\n        val startDateTime = state.startTime.atDate(state.startDate)\n        val endDateTime = state.endTime.atDate(state.endDate)\n        if (!startDateTime.isBefore(endDateTime)) {\n          dateTimeError = context.getString(R.string.error_end_time_not_after_start)\n        }\n      }\n    }\n  }\n\n  Column(modifier = modifier) {\n    // --- Filter Chips ---\n    Row(\n        modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp),\n        horizontalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally),\n    ) {\n      // --- Чип \"All Day\" ---\n      FilterChip(\n          selected = isAllDay,\n          onClick = {\n            val newIsAllDay = !isAllDay\n\n            val newState: EventDateTimeState\n            if (newIsAllDay) {\n              newState = state.copy(isAllDay = true, startTime = null, endTime = null)\n            } else {\n              val defaultStartTime =\n                  state.startTime\n                      ?: LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0)\n\n              var newEndTime = state.endTime\n              var newEndDate = state.endDate\n\n              if (state.startDate == state.endDate) {\n                if (newEndTime == null || !defaultStartTime.isBefore(newEndTime)) {\n                  newEndTime = defaultStartTime.plusHours(1)\n                }\n                if (newEndTime != null) {\n                  newEndTime = newEndTime.withNano(0)\n                }\n\n                if (newEndTime != null) {\n                  if (newEndTime.isBefore(defaultStartTime)) {\n                    newEndDate = state.startDate.plusDays(1)\n                  }\n                }\n              } else {\n                if (newEndTime == null) {\n                  newEndTime = defaultStartTime.plusHours(1)\n                }\n                if (newEndTime != null) {\n                  newEndTime = newEndTime.withNano(0)\n                }\n              }\n\n              newState =\n                  state.copy(\n                      isAllDay = false,\n                      startTime = defaultStartTime,\n                      endTime = newEndTime,\n                      endDate = newEndDate)\n            }\n            onStateChange(newState)\n          },\n          label = { Text(allDay) },\n          enabled = !isLoading)\n\n      // --- Чип \"One Day\" ---\n      FilterChip(\n          selected = isOneDay,\n          onClick = {\n            val currentActualIsOneDay = state.startDate == state.endDate\n            val targetIsOneDay = !currentActualIsOneDay\n\n            val newEndDateCandidate: LocalDate\n            var newEndTimeCandidate = state.endTime\n\n            if (targetIsOneDay) {\n              newEndDateCandidate = state.startDate\n\n              if (!state.isAllDay && state.startTime != null) {\n                val currentStartTime = state.startTime\n                if (newEndTimeCandidate == null ||\n                    !currentStartTime.isBefore(newEndTimeCandidate)) {\n                  newEndTimeCandidate = currentStartTime.plusHours(1).withNano(0)\n                  if (newEndTimeCandidate.isBefore(currentStartTime)) {\n                    newEndTimeCandidate = LocalTime.of(23, 59, 0, 0)\n                  }\n                }\n              }\n            } else {\n              newEndDateCandidate = state.startDate.plusDays(1)\n            }\n            onStateChange(state.copy(endDate = newEndDateCandidate, endTime = newEndTimeCandidate))\n          },\n          label = { Text(oneDay) },\n          enabled = !isLoading)\n\n      // --- Чип \"Recurring\" ---\n      FilterChip(\n          selected = state.isRecurring,\n          onClick = {\n            val newIsRecurring = !state.isRecurring\n            val newRule =\n                if (!newIsRecurring) {\n                  null\n                } else {\n                  state.recurrenceRule ?: RecurrenceOption.Daily.rruleValue\n                }\n            onStateChange(state.copy(isRecurring = newIsRecurring, recurrenceRule = newRule))\n          },\n          label = { Text(recEvent) },\n          enabled = !isLoading)\n    }\n\n    AnimatedVisibility(\n        visible = dateTimeError != null,\n        enter = fadeIn() + expandVertically(),\n        exit = fadeOut() + shrinkVertically()) {\n          Column {\n            Text(\n                text = dateTimeError ?: \"\",\n                color = colorScheme.error,\n                style = typography.bodySmall,\n                modifier = Modifier.padding(horizontal = 8.dp))\n            Spacer(modifier = Modifier.height(4.dp))\n          }\n        }\n\n    // --- Поля ввода Даты/Времени ---\n    Column(\n        modifier = Modifier.animateContentSize(animationSpec = tween(300)),\n        verticalArrangement = Arrangement.spacedBy(8.dp)) {\n          AnimatedContent(\n              targetState = Pair(isAllDay, isOneDay),\n              transitionSpec = {\n                if (targetState.first != initialState.first ||\n                        targetState.second != initialState.second) {\n                      (fadeIn(animationSpec = tween(220, delayMillis = 90)) +\n                          slideInVertically(\n                              initialOffsetY = { it / 4 },\n                              animationSpec = tween(270, delayMillis = 90))) togetherWith\n                          (fadeOut(animationSpec = tween(90)) +\n                              slideOutVertically(\n                                  targetOffsetY = { -it / 4 }, animationSpec = tween(120)))\n                    } else {\n                      fadeIn(animationSpec = tween(0)) togetherWith\n                          fadeOut(animationSpec = tween(0))\n                    }\n                    .using(SizeTransform(clip = true, sizeAnimationSpec = { _, _ -> tween(250) }))\n              },\n              label = \"DateTimeFieldsAnimation\") { targetLayoutState ->\n                val (showAllDay, showOneDay) = targetLayoutState\n                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {\n                  when {\n                    showAllDay && showOneDay -> {\n                      DatePickerField(\n                          state.startDate,\n                          deviceDateFormatter,\n                          isLoading,\n                          onRequestShowStartDatePicker,\n                          Modifier.fillMaxWidth().padding(horizontal = 50.dp))\n                    }\n\n                    showAllDay -> {\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(8.dp),\n                          Alignment.Top) {\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.weight(1f))\n                            DatePickerField(\n                                state.endDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowEndDatePicker,\n                                Modifier.weight(1f))\n                          }\n                    }\n\n                    showOneDay -> {\n                      Column(\n                          horizontalAlignment = Alignment.CenterHorizontally,\n                          verticalArrangement = Arrangement.spacedBy(8.dp)) {\n                            Row(\n                                Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                                Arrangement.spacedBy(4.dp, Alignment.CenterHorizontally),\n                                Alignment.CenterVertically) {\n                                  TimePickerField(\n                                      state.startTime,\n                                      deviceTimeFormatter,\n                                      isLoading,\n                                      onRequestShowStartTimePicker,\n                                      Modifier.width(100.dp),\n                                      onLongClick = {\n                                        val selectedTime = LocalTime.now()\n                                        var newEndTime = state.endTime\n                                        if (state.startDate == state.endDate &&\n                                            state.endTime != null &&\n                                            !selectedTime.isBefore(state.endTime)) {\n                                          newEndTime = selectedTime.plusHours(1).withNano(0)\n                                        }\n                                        onStateChange(\n                                            state.copy(\n                                                startTime = selectedTime, endTime = newEndTime))\n                                      })\n                                  Box(\n                                      modifier =\n                                          Modifier.width(10.dp)\n                                              .height(1.dp)\n                                              .background(color = colorScheme.onBackground))\n                                  TimePickerField(\n                                      state.endTime,\n                                      deviceTimeFormatter,\n                                      isLoading,\n                                      onRequestShowEndTimePicker,\n                                      Modifier.width(100.dp),\n                                  )\n                                }\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.width(218.dp))\n                          }\n                    }\n\n                    else -> {\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(16.dp, Alignment.CenterHorizontally),\n                          Alignment.Top) {\n                            TimePickerField(\n                                state.startTime,\n                                deviceTimeFormatter,\n                                isLoading,\n                                onRequestShowStartTimePicker,\n                                Modifier.weight(1f),\n                                onLongClick = {\n                                  val selectedTime = LocalTime.now()\n                                  var newEndTime = state.endTime\n                                  if (state.startDate == state.endDate &&\n                                      state.endTime != null &&\n                                      !selectedTime.isBefore(state.endTime)) {\n                                    newEndTime = selectedTime.plusHours(1).withNano(0)\n                                  }\n                                  onStateChange(\n                                      state.copy(startTime = selectedTime, endTime = newEndTime))\n                                })\n                            TimePickerField(\n                                state.endTime,\n                                deviceTimeFormatter,\n                                isLoading,\n                                onRequestShowEndTimePicker,\n                                Modifier.weight(1f))\n                          }\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(8.dp),\n                          Alignment.Top) {\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.weight(1f))\n                            DatePickerField(\n                                state.endDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowEndDatePicker,\n                                Modifier.weight(1f))\n                          }\n                    }\n                  }\n                }\n              } // End AnimatedContent\n        } // End Column for Date/Time fields with animateContentSize\n\n    // --- Настройки повторения (АНИМИРОВАННЫЕ) ---\n    AnimatedVisibility(\n        visible = state.isRecurring,\n        enter =\n            fadeIn(animationSpec = tween(150, delayMillis = 50)) +\n                expandVertically(animationSpec = tween(300)),\n        exit = fadeOut(animationSpec = tween(150)) + shrinkVertically(animationSpec = tween(300)),\n        modifier = Modifier.padding(top = 8.dp)) {\n          Column {\n            // --- Чипы для выбора частоты RRULE ---\n            Row(\n                modifier =\n                    Modifier.fillMaxWidth()\n                        .padding(horizontal = 8.dp)\n                        .horizontalScroll(rememberScrollState()), // Горизонтальная прокрутка\n                horizontalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally),\n            ) {\n              // Вычисляем текущий выбор один раз\n              val currentSelection =\n                  remember(state.recurrenceRule) { RecurrenceOption.fromRule(state.recurrenceRule) }\n\n              // --- Явно создаем каждый чип ---\n              // Чип \"Ежедневно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Daily,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Еженедельно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Weekly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Ежемесячно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Monthly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Ежегодно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Yearly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n            }\n            AnimatedVisibility(\n                visible =\n                    state.recurrenceRule ==\n                        RecurrenceOption.Weekly.rruleValue, // Показываем только для Weekly\n                enter =\n                    fadeIn(animationSpec = tween(150, delayMillis = 50)) +\n                        expandVertically(animationSpec = tween(300)),\n                exit =\n                    fadeOut(animationSpec = tween(150)) +\n                        shrinkVertically(animationSpec = tween(300)),\n            ) {\n              Column {\n                // --- Чипы для дней недели ---\n                Row(\n                    modifier =\n                        Modifier.fillMaxWidth()\n                            .padding(horizontal = 8.dp)\n                            .horizontalScroll(rememberScrollState()),\n                    // Центрируем дни недели, если их немного\n                    horizontalArrangement =\n                        Arrangement.spacedBy(4.dp, Alignment.CenterHorizontally)) {\n                      weekdays.forEach { day ->\n                        val isSelected = day in state.selectedWeekdays\n                        FilterChip(\n                            selected = isSelected,\n                            onClick = {\n                              val currentDays = state.selectedWeekdays\n                              val newDays =\n                                  if (isSelected) {\n                                    // Не даем убрать последний выбранный день, если он один\n                                    if (currentDays.size > 1) currentDays - day else currentDays\n                                  } else {\n                                    currentDays + day\n                                  }\n                              onStateChange(state.copy(selectedWeekdays = newDays))\n                            },\n                            label = {\n                              Text(day.getDisplayName(TextStyle.SHORT, Locale.getDefault()))\n                            },\n                            enabled = !isLoading)\n                      }\n                    }\n              }\n            }\n            Column(\n                modifier = Modifier.padding(top = 16.dp),\n                horizontalAlignment = Alignment.CenterHorizontally) {\n                  Text(\n                      text = endsLabel, // \"Ending\"\n                      style = typography.titleSmall,\n                      modifier = Modifier.padding(horizontal = 8.dp),\n                      textAlign = TextAlign.Center)\n                  // --- Чипы для выбора типа окончания (NEVER, DATE, COUNT) ---\n                  Row(\n                      modifier =\n                          Modifier.fillMaxWidth()\n                              .padding(horizontal = 8.dp)\n                              .horizontalScroll(rememberScrollState()),\n                      horizontalArrangement =\n                          Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally)) {\n                        // Чип \"Never\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.NEVER,\n                            onClick = {\n                              // Устанавливаем тип, сбрасываем дату и количество\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.NEVER,\n                                      recurrenceEndDate = null,\n                                      recurrenceCount = null))\n                            },\n                            label = { Text(endNeverLabel) },\n                            enabled = !isLoading)\n                        // Чип \"On date\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.DATE,\n                            onClick = {\n                              val defaultEndDate =\n                                  state.recurrenceEndDate\n                                      ?: state.startDate.plusMonths(1) // Пример: через месяц\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.DATE,\n                                      recurrenceEndDate = defaultEndDate,\n                                      recurrenceCount = null))\n                              // Запрашиваем показ пикера, если дата была null\n                              if (state.recurrenceEndDate == null) {\n                                onRequestShowRecurrenceEndDatePicker()\n                              }\n                            },\n                            label = { Text(endDateLabel) },\n                            enabled = !isLoading)\n                        // Чип \"After...\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.COUNT,\n                            onClick = {\n                              val defaultCount = state.recurrenceCount ?: 10\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.COUNT,\n                                      recurrenceEndDate = null,\n                                      recurrenceCount = defaultCount))\n                            },\n                            label = { Text(endCountLabel) },\n                            enabled = !isLoading)\n                      }\n\n                  // --- Поле для выбора даты окончания (UNTIL) ---\n                  AnimatedVisibility(\n                      visible = state.recurrenceEndType == RecurrenceEndType.DATE,\n                      modifier = Modifier.padding(top = 8.dp)) {\n                        DatePickerField(\n                            // \"End Date\"\n                            date = state.recurrenceEndDate,\n                            dateFormatter = deviceDateFormatter,\n                            isLoading = isLoading,\n                            onClick = onRequestShowRecurrenceEndDatePicker, // Открываем пикер\n                            modifier = Modifier.fillMaxWidth().padding(horizontal = 50.dp))\n                      }\n\n                  // --- Поле для ввода количества (COUNT) ---\n                  AnimatedVisibility(\n                      visible = state.recurrenceEndType == RecurrenceEndType.COUNT,\n                      modifier = Modifier.padding(top = 8.dp)) {\n                        OutlinedTextField(\n                            value = state.recurrenceCount?.toString() ?: \"\",\n                            onValueChange = { text ->\n                              val count =\n                                  text.filter { it.isDigit() }.toIntOrNull()?.coerceAtLeast(1)\n                              onStateChange(state.copy(recurrenceCount = count))\n                            },\n                            label = { Text(recurrenceCountFieldLabel) }, // \"Number of times\"\n                            keyboardOptions =\n                                KeyboardOptions(\n                                    keyboardType = KeyboardType.Number, imeAction = ImeAction.Done),\n                            singleLine = true,\n                            modifier = Modifier.fillMaxWidth().padding(horizontal = 50.dp),\n                            shape = RoundedCornerShape(cuid.ContainerCornerRadius),\n                            enabled = !isLoading,\n                            isError = state.recurrenceCount == null // Ошибка, если пусто\n                            )\n                      }\n                } // --- КОНЕЦ СЕКЦИИ ОКОНЧАНИЯ ---\n          }\n        } // End AnimatedVisibility for Recurrence\n  } // End Outer Column\n}\n\n// --- Вспомогательные Composable для полей ---\n@Composable\nprivate fun FilterChipForOption(\n    option: RecurrenceOption,\n    currentSelection: RecurrenceOption,\n    isLoading: Boolean,\n    state: EventDateTimeState,\n    onStateChange: (EventDateTimeState) -> Unit\n) {\n  FilterChip(\n      selected = (option == currentSelection),\n      onClick = {\n        onStateChange(\n            state.copy(\n                recurrenceRule = option.rruleValue,\n                isRecurring = (option != RecurrenceOption.None)))\n      },\n      label = { Text(stringResource(option.labelResId)) },\n      enabled = !isLoading,\n      leadingIcon =\n          if (option == currentSelection) {\n            null\n          } else null)\n}\n\nsealed class RecurrenceOption(@StringRes val labelResId: Int, val rruleValue: String?) {\n  data object None : RecurrenceOption(R.string.recurrence_none, null)\n\n  data object Daily : RecurrenceOption(R.string.recurrence_daily, \"FREQ=DAILY\")\n\n  data object Weekly : RecurrenceOption(R.string.recurrence_weekly, \"FREQ=WEEKLY\")\n\n  data object Monthly : RecurrenceOption(R.string.recurrence_monthly, \"FREQ=MONTHLY\")\n\n  data object Yearly : RecurrenceOption(R.string.recurrence_yearly, \"FREQ=YEARLY\")\n\n  companion object {\n    val ALL_OPTIONS: List<RecurrenceOption> = listOf(None, Daily, Weekly, Monthly, Yearly)\n\n    fun fromRule(rule: String?): RecurrenceOption {\n      return when (rule) {\n        Daily.rruleValue -> Daily\n        Weekly.rruleValue -> Weekly\n        Monthly.rruleValue -> Monthly\n        Yearly.rruleValue -> Yearly\n        else -> None\n      }\n    }\n  }\n}\n",
      "info": {
        "size": 30731,
        "last_modified": "2025-08-06T10:04:47.817518",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/sections/NameSection.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections\n\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.event_management.ui.shared.ChipsRow\nimport com.lpavs.caliinda.feature.event_management.ui.shared.CustomOutlinedTextField\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\n\ndata class SugNameChips(val key: String, val name: String, val fullText: String)\n\n@Composable\nfun EventNameSection(\n    summary: String,\n    summaryError: String?,\n    onSummaryChange: (String) -> Unit,\n    onSummaryErrorChange: (String?) -> Unit,\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    isLoading: Boolean,\n    suggestedChips: List<SugNameChips>\n) {\n  CustomOutlinedTextField(\n      value = summary,\n      onValueChange = {\n        onSummaryChange(it)\n        onSummaryErrorChange(null)\n      },\n      label = stringResource(R.string.event_name),\n      modifier = Modifier.fillMaxWidth(),\n      isError = summaryError != null,\n      supportingText = { if (summaryError != null) Text(summaryError) },\n      enabled = !isLoading,\n  )\n\n  val lazyListState = rememberLazyListState()\n  LaunchedEffect(suggestedChips) { lazyListState.animateScrollToItem(index = 0) }\n  ChipsRow(\n      chips = suggestedChips,\n      onChipClick = { chip ->\n        onSummaryChange(chip.fullText)\n        suggestionsViewModel.onChipClicked(chip)\n      },\n      enabled = !isLoading,\n      lazyListState = lazyListState)\n}\n",
      "info": {
        "size": 1869,
        "last_modified": "2025-08-06T10:04:47.826618",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/sections/suggestions/SuggestionsViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport android.app.Application\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.core.data.repository.SuggestionsRepository\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport java.time.LocalTime\nimport javax.inject.Inject\n\n@HiltViewModel\nclass SuggestionsViewModel\n@Inject\nconstructor(\n    private val suggestionsRepository: SuggestionsRepository,\n    private val application: Application\n) : ViewModel() {\n  private val _suggestionChips = MutableStateFlow<List<SugNameChips>>(emptyList())\n  val suggestionChips: StateFlow<List<SugNameChips>> = _suggestionChips.asStateFlow()\n\n  private val _timeContext = MutableStateFlow(LocalTime.now())\n\n  init {\n    viewModelScope.launch { _timeContext.collect { time -> loadAndSortSuggestions(time) } }\n  }\n\n  fun updateSortContext(startTime: LocalTime?, isAllDay: Boolean) {\n    if (!isAllDay) {\n      _timeContext.value = startTime\n    } else {\n      _timeContext.value = LocalTime.now()\n    }\n  }\n\n  fun onChipClicked(chip: SugNameChips) {\n    viewModelScope.launch {\n      suggestionsRepository.incrementWeight(chip.key)\n      loadAndSortSuggestions(_timeContext.value)\n    }\n  }\n\n  private fun loadAndSortSuggestions(currentTime: LocalTime) {\n    viewModelScope.launch {\n      val weights = suggestionsRepository.getWeights()\n      val baseChips = getSuggestedEventNames(application.applicationContext)\n      val sortedChips =\n          baseChips.sortedByDescending { chip ->\n            val clickWeight = weights[chip.key] ?: 0\n            val timeBonus = getTimeBasedBonus(chip.key, currentTime)\n            clickWeight + timeBonus\n          }\n      _suggestionChips.value = sortedChips\n    }\n  }\n}\n",
      "info": {
        "size": 2037,
        "last_modified": "2025-08-06T10:04:47.834012",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/sections/suggestions/getTimeBonus.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport java.time.LocalTime\n\nfun getTimeBasedBonus(chipKey: String, time: LocalTime): Int {\n  val priority1Bonus = 100\n  val priority2Bonus = 75\n  val hour = time.hour\n  val key = chipKey\n\n  // Приоритет 1 по времени\n  val morningP1 = setOf(\"breakfast\", \"gym\")\n  val dayP1 = setOf(\"work\", \"meeting\")\n  val eveningP1 = setOf(\"dinner\", \"relax\")\n  val nightP1 = setOf(\"sleep\", \"relax\")\n\n  // Приоритет 2 по времени\n  val morningP2 = setOf(\"walking\", \"doctor\", \"pet\", \"reading\", \"cooking\")\n  val dayP2 =\n      setOf(\n          \"lunch\", \"call\", \"errand\", \"appointment\", \"project\", \"presentation\", \"study\", \"shopping\")\n  val eveningP2 =\n      setOf(\n          \"relax\",\n          \"movie\",\n          \"date\",\n          \"party\",\n          \"cooking\",\n          \"walking\",\n          \"hobby\",\n          \"gym\",\n          \"reading\",\n          \"pet\",\n          \"call\")\n  val nightP2 = setOf(\"reading\", \"movie\", \"party\", \"date\", \"pet\", \"cleaning\", \"hobby\")\n\n  return when {\n    // Приоритет 1 – проверяется первым\n    key in morningP1 && hour in 5..10 -> priority1Bonus\n    key in dayP1 && hour in 9..17 -> priority1Bonus\n    key in eveningP1 && hour in 18..22 -> priority1Bonus\n    key in nightP1 && (hour in 22..23 || hour in 0..1) -> priority1Bonus\n\n    // Приоритет 2 – проверяется только если не сработал приоритет 1\n    key in morningP2 && hour in 6..11 -> priority2Bonus\n    key in dayP2 && hour in 11..17 -> priority2Bonus\n    key in eveningP2 && hour in 17..23 -> priority2Bonus\n    key in nightP2 && (hour in 22..23 || hour in 0..3) -> priority2Bonus\n\n    else -> 0\n  }\n}\n",
      "info": {
        "size": 1763,
        "last_modified": "2025-08-06T10:04:47.838576",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/sections/suggestions/getSuggestedEventNames.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport android.content.Context\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\n\nfun getSuggestedEventNames(context: Context): List<SugNameChips> {\n  return listOf(\n      SugNameChips(\n          key = \"project\",\n          context.getString(R.string.suggested_event_project),\n          context.getString(R.string.suggested_event_project_full)),\n      SugNameChips(\n          key = \"work\",\n          context.getString(R.string.suggested_event_work),\n          context.getString(R.string.suggested_event_work_full)),\n      SugNameChips(\n          key = \"dinner\",\n          context.getString(R.string.suggested_event_dinner),\n          context.getString(R.string.suggested_event_dinner_full)),\n      SugNameChips(\n          key = \"meeting\",\n          context.getString(R.string.suggested_event_meeting),\n          context.getString(R.string.suggested_event_meeting_full)),\n      SugNameChips(\n          key = \"coffee\",\n          context.getString(R.string.suggested_event_coffee),\n          context.getString(R.string.suggested_event_coffee_full)),\n      SugNameChips(\n          key = \"lunch\",\n          context.getString(R.string.suggested_event_lunch),\n          context.getString(R.string.suggested_event_lunch_full)),\n      SugNameChips(\n          key = \"shopping\",\n          context.getString(R.string.suggested_event_shopping),\n          context.getString(R.string.suggested_event_shopping_full)),\n      SugNameChips(\n          key = \"appointment\",\n          context.getString(R.string.suggested_event_appointment),\n          context.getString(R.string.suggested_event_appointment_full)),\n      SugNameChips(\n          key = \"travel\",\n          context.getString(R.string.suggested_event_travel),\n          context.getString(R.string.suggested_event_travel_full)),\n      SugNameChips(\n          key = \"party\",\n          context.getString(R.string.suggested_event_party),\n          context.getString(R.string.suggested_event_party_full)),\n      SugNameChips(\n          key = \"movie\",\n          context.getString(R.string.suggested_event_movie),\n          context.getString(R.string.suggested_event_movie_full)),\n      SugNameChips(\n          key = \"study\",\n          context.getString(R.string.suggested_event_study),\n          context.getString(R.string.suggested_event_study_full)),\n      SugNameChips(\n          key = \"gym\",\n          context.getString(R.string.suggested_event_gym),\n          context.getString(R.string.suggested_event_gym_full)),\n      SugNameChips(\n          key = \"relax\",\n          context.getString(R.string.suggested_event_relax),\n          context.getString(R.string.suggested_event_relax_full)),\n      SugNameChips(\n          key = \"reading\",\n          context.getString(R.string.suggested_event_reading),\n          context.getString(R.string.suggested_event_reading_full)),\n      SugNameChips(\n          key = \"cleaning\",\n          context.getString(R.string.suggested_event_cleaning),\n          context.getString(R.string.suggested_event_cleaning_full)),\n      SugNameChips(\n          key = \"cooking\",\n          context.getString(R.string.suggested_event_cooking),\n          context.getString(R.string.suggested_event_cooking_full)),\n      SugNameChips(\n          key = \"walking\",\n          context.getString(R.string.suggested_event_walking),\n          context.getString(R.string.suggested_event_walking_full)),\n      SugNameChips(\n          key = \"hobby\",\n          context.getString(R.string.suggested_event_hobby),\n          context.getString(R.string.suggested_event_hobby_full)),\n      SugNameChips(\n          key = \"date\",\n          context.getString(R.string.suggested_event_date),\n          context.getString(R.string.suggested_event_date_full)),\n      SugNameChips(\n          key = \"doctor\",\n          context.getString(R.string.suggested_event_doctor),\n          context.getString(R.string.suggested_event_doctor_full)),\n      SugNameChips(\n          key = \"birthday\",\n          context.getString(R.string.suggested_event_birthday),\n          context.getString(R.string.suggested_event_birthday_full)),\n      SugNameChips(\n          key = \"presentation\",\n          context.getString(R.string.suggested_event_presentation),\n          context.getString(R.string.suggested_event_presentation_full)),\n      SugNameChips(\n          key = \"call\",\n          context.getString(R.string.suggested_event_call),\n          context.getString(R.string.suggested_event_call_full)),\n      SugNameChips(\n          key = \"errand\",\n          context.getString(R.string.suggested_event_errand),\n          context.getString(R.string.suggested_event_errand_full)),\n      SugNameChips(\n          key = \"sleep\",\n          context.getString(R.string.suggested_event_sleep),\n          context.getString(R.string.suggested_event_sleep_full)),\n      SugNameChips(\n          key = \"breakfast\",\n          context.getString(R.string.suggested_event_breakfast),\n          context.getString(R.string.suggested_event_breakfast_full)),\n      SugNameChips(\n          key = \"pet\",\n          context.getString(R.string.suggested_event_pet),\n          context.getString(R.string.suggested_event_pet_full)))\n}\n",
      "info": {
        "size": 5259,
        "last_modified": "2025-08-06T10:04:47.840281",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/InteractiveFields.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.OutlinedTextFieldDefaults\nimport androidx.compose.material3.SuggestionChip\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.hapticfeedback.HapticFeedbackType\nimport androidx.compose.ui.platform.LocalHapticFeedback\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter\n\n@Composable\nfun CustomOutlinedTextField(\n    value: String,\n    onValueChange: (String) -> Unit,\n    label: String,\n    modifier: Modifier = Modifier,\n    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,\n    enabled: Boolean = true,\n    isError: Boolean = false,\n    supportingText: (@Composable () -> Unit)? = null\n) {\n  OutlinedTextField(\n      value = value,\n      onValueChange = onValueChange,\n      label = { Text(text = label, textAlign = TextAlign.Center) },\n      modifier = modifier.fillMaxWidth().padding(horizontal = 8.dp),\n      shape = RoundedCornerShape(cuid.ContainerCornerRadius),\n      colors =\n          OutlinedTextFieldDefaults.colors(\n              focusedContainerColor = colorScheme.surfaceContainerLow,\n              unfocusedContainerColor = colorScheme.surfaceContainerLow,\n          ),\n      keyboardOptions = keyboardOptions,\n      textStyle = typography.headlineMedium.copy(textAlign = TextAlign.Center),\n      enabled = enabled,\n      singleLine = true,\n      isError = isError,\n      supportingText = supportingText)\n}\n\n@Composable\nfun ChipsRow(\n    chips: List<SugNameChips>,\n    onChipClick: (SugNameChips) -> Unit,\n    enabled: Boolean,\n    lazyListState: LazyListState\n) {\n  LazyRow(\n      state = lazyListState,\n      modifier = Modifier.fillMaxWidth().padding(horizontal = cuid.padding),\n      horizontalArrangement = Arrangement.spacedBy(cuid.padding),\n      contentPadding = PaddingValues(cuid.padding)) {\n        items(chips, key = { it.name }) { chip ->\n          SuggestionChip(\n              onClick = { onChipClick(chip) },\n              label = { Text(chip.name) },\n              modifier = Modifier.height(35.dp),\n              enabled = enabled)\n        }\n      }\n}\n\n@Composable\ninternal fun DatePickerField(\n    date: LocalDate?,\n    dateFormatter: DateTimeFormatter,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n) {\n  ModernClickableTextField(\n      value = date?.format(dateFormatter) ?: \"\",\n      isLoading = isLoading,\n      onClick = onClick,\n      modifier = modifier)\n}\n\n@Composable\ninternal fun TimePickerField(\n    time: LocalTime?,\n    timeFormatter: DateTimeFormatter,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n    onLongClick: (() -> Unit)? = null,\n) {\n  ModernClickableTextField(\n      value = time?.format(timeFormatter) ?: \"--:--\",\n      isLoading = isLoading,\n      onClick = onClick,\n      onLongClick = onLongClick,\n      modifier = modifier)\n}\n\n@Composable\nprivate fun ModernClickableTextField(\n    value: String,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n    onLongClick: (() -> Unit)? = null,\n) {\n  val haptics = LocalHapticFeedback.current\n  Box(\n      modifier =\n          modifier\n              .height(45.dp)\n              .clip(shape = RoundedCornerShape(cuid.ContainerCornerRadius))\n              .background(colorScheme.secondaryContainer)) {\n        Row(\n            modifier =\n                Modifier.fillMaxSize()\n                    .combinedClickable(\n                        enabled = !isLoading,\n                        onClick = onClick,\n                        onLongClick = {\n                          haptics.performHapticFeedback(HapticFeedbackType.LongPress)\n                          onLongClick?.invoke()\n                        },\n                        indication = null,\n                        interactionSource = remember { MutableInteractionSource() }),\n            horizontalArrangement = Arrangement.Center,\n            verticalAlignment = Alignment.CenterVertically) {\n              Text(text = value, color = colorScheme.onSecondaryContainer)\n            }\n      }\n}\n",
      "info": {
        "size": 5551,
        "last_modified": "2025-08-06T10:04:47.842359",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/shared/GeneralElements.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.layout.widthIn\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.foundation.selection.selectable\nimport androidx.compose.foundation.selection.selectableGroup\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.AlertDialog\nimport androidx.compose.material3.BasicAlertDialog\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.LocalContentColor\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.shapes\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.NavigationBarDefaults.Elevation\nimport androidx.compose.material3.RadioButton\nimport androidx.compose.material3.RadioButtonDefaults\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.semantics.Role\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.window.DialogProperties\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.ui.theme.cuid\n\n/**\n * Content [AdaptiveContainer] - container for any content. [TimePickerDialog] - timepicker\n * [DeleteConfirmationDialog] - delete confirmation dialog\n */\n@Composable\nfun AdaptiveContainer(modifier: Modifier = Modifier, content: @Composable ColumnScope.() -> Unit) {\n  val cornerRadius = cuid.SettingsItemCornerRadius\n  Column(\n      modifier =\n          Modifier.fillMaxWidth()\n              .clip(RoundedCornerShape(cornerRadius))\n              .background(color = colorScheme.surfaceContainer)\n              .padding(cuid.ContainerPadding)\n              .then(modifier),\n      horizontalAlignment = Alignment.CenterHorizontally,\n      verticalArrangement = Arrangement.Center,\n      content = content)\n}\n\n@Composable\nfun TimePickerDialog(\n    title: String = stringResource(R.string.pick_time),\n    onDismissRequest: () -> Unit,\n    confirmButton: @Composable (() -> Unit),\n    dismissButton: @Composable (() -> Unit)? = null,\n    content: @Composable () -> Unit,\n) {\n  AlertDialog(\n      onDismissRequest = onDismissRequest,\n      title = { Text(title) },\n      text = {\n        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) { content() }\n      },\n      confirmButton = confirmButton,\n      dismissButton = dismissButton)\n}\n\n@Composable\nfun DeleteConfirmationDialog(onConfirm: () -> Unit, onDismiss: () -> Unit) {\n  AlertDialog(\n      onDismissRequest = onDismiss,\n      title = { Text(text = stringResource(R.string.delete_conf)) },\n      text = { Text(text = stringResource(R.string.delete_confirmation_message)) },\n      confirmButton = {\n        Button(\n            onClick = { onConfirm() },\n            colors =\n                ButtonDefaults.buttonColors(\n                    containerColor = colorScheme.primary, contentColor = colorScheme.onPrimary)) {\n              Text(text = stringResource(R.string.delete))\n            }\n      },\n      dismissButton = {\n        TextButton(onClick = onDismiss) { Text(text = stringResource(R.string.cancel)) }\n      })\n}\n\nenum class RecurringDeleteChoice {\n  SINGLE_INSTANCE,\n  THIS_AND_FOLLOWING,\n  ALL_IN_SERIES\n}\n\n@Composable\nfun RecurringEventDeleteOptionsDialog(\n    eventName: String,\n    onDismiss: () -> Unit,\n    onOptionSelected: (RecurringDeleteChoice) -> Unit\n) {\n  var selectedOption by remember { mutableStateOf(RecurringDeleteChoice.SINGLE_INSTANCE) }\n  val radioOptions =\n      listOf(\n          RecurringDeleteChoice.SINGLE_INSTANCE to stringResource(R.string.delete_single_instance),\n          RecurringDeleteChoice.ALL_IN_SERIES to stringResource(R.string.delete_all_in_series),\n          RecurringDeleteChoice.THIS_AND_FOLLOWING to\n              stringResource(R.string.delete_this_and_following))\n\n  AlertDialog(\n      onDismissRequest = onDismiss,\n      title = { Text(text = stringResource(R.string.delete_recurring_event_title)) },\n      text = {\n        Column(modifier = Modifier.selectableGroup()) {\n          Text(\n              text = stringResource(R.string.delete_recurring_event_prompt, eventName),\n              style = typography.bodyMedium,\n              modifier = Modifier.padding(bottom = 16.dp))\n\n          radioOptions.forEach { (option, label) ->\n            Row(\n                Modifier.fillMaxWidth()\n                    .selectable(\n                        selected = (option == selectedOption),\n                        onClick = { selectedOption = option },\n                        role = Role.RadioButton)\n                    .padding(vertical = 8.dp),\n                verticalAlignment = Alignment.CenterVertically) {\n                  RadioButton(\n                      selected = (option == selectedOption),\n                      onClick = null,\n                      colors =\n                          RadioButtonDefaults.colors(\n                              selectedColor =\n                                  when (option) {\n                                    RecurringDeleteChoice.ALL_IN_SERIES -> {\n                                      if (selectedOption == option) colorScheme.error\n                                      else colorScheme.primary\n                                    }\n                                    RecurringDeleteChoice.THIS_AND_FOLLOWING -> {\n                                      if (selectedOption == option) colorScheme.tertiary\n                                      else colorScheme.primary\n                                    }\n                                    else -> colorScheme.primary\n                                  }))\n                  Spacer(Modifier.width(8.dp))\n                  Text(\n                      text = label,\n                      style = typography.bodyLarge,\n                      color =\n                          when (option) {\n                            RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.error\n                            else -> LocalContentColor.current\n                          })\n                }\n          }\n        }\n      },\n      confirmButton = {\n        Button(\n            onClick = {\n              onOptionSelected(selectedOption)\n              onDismiss()\n            },\n            colors =\n                ButtonDefaults.buttonColors(\n                    containerColor =\n                        when (selectedOption) {\n                          RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.error\n                          RecurringDeleteChoice.THIS_AND_FOLLOWING -> colorScheme.tertiary\n                          else -> colorScheme.primary\n                        },\n                    contentColor =\n                        when (selectedOption) {\n                          RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.onError\n                          RecurringDeleteChoice.THIS_AND_FOLLOWING -> colorScheme.onTertiary\n                          else -> colorScheme.onPrimary\n                        })) {\n              Text(\n                  text =\n                      when (selectedOption) {\n                        RecurringDeleteChoice.THIS_AND_FOLLOWING ->\n                            stringResource(R.string.stop_repeating)\n                        else -> stringResource(R.string.delete)\n                      })\n            }\n      },\n      dismissButton = { TextButton(onClick = onDismiss) { Text(stringResource(R.string.cancel)) } })\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RecurringEventEditOptionsDialog(\n    eventName: String,\n    onDismiss: () -> Unit,\n    onOptionSelected: (EventUpdateMode) -> Unit,\n    modifier: Modifier = Modifier,\n    properties: DialogProperties = DialogProperties()\n) {\n  BasicAlertDialog(\n      onDismissRequest = onDismiss,\n      modifier = modifier.widthIn(min = 280.dp, max = 560.dp),\n      properties = properties,\n  ) {\n    Surface(\n        shape = shapes.extraLarge,\n        color = colorScheme.surface,\n        tonalElevation = Elevation,\n        modifier = Modifier.wrapContentSize()) {\n          Column(\n              modifier =\n                  Modifier.padding(top = 24.dp, bottom = 24.dp, start = 24.dp, end = 24.dp)) {\n                Text(\n                    text = stringResource(R.string.edit_recurring_event_title),\n                    style = typography.headlineSmall,\n                    modifier = Modifier.padding(bottom = 16.dp))\n\n                Text(\n                    text = stringResource(R.string.edit_recurring_event_prompt, eventName),\n                    style = typography.bodyMedium,\n                    modifier = Modifier.padding(bottom = 24.dp))\n\n                TextButton(\n                    onClick = { onOptionSelected(EventUpdateMode.SINGLE_INSTANCE) },\n                    modifier = Modifier.fillMaxWidth()) {\n                      Text(stringResource(R.string.edit_single_instance))\n                    }\n\n                Spacer(modifier = Modifier.height(8.dp))\n\n                TextButton(\n                    onClick = { onOptionSelected(EventUpdateMode.ALL_IN_SERIES) },\n                    modifier = Modifier.fillMaxWidth()) {\n                      Text(stringResource(R.string.edit_all_in_series))\n                    }\n\n                Spacer(modifier = Modifier.height(24.dp))\n\n                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {\n                  TextButton(onClick = onDismiss) { Text(stringResource(R.string.cancel)) }\n                }\n              }\n        }\n  }\n}\n",
      "info": {
        "size": 10681,
        "last_modified": "2025-08-06T10:04:47.84392",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/edit/EditEventScreen.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.edit\n\nimport android.text.format.DateFormat\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.ExitTransition\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.DatePicker\nimport androidx.compose.material3.DatePickerDialog\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.SelectableDates\nimport androidx.compose.material3.SheetValue\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TimePicker\nimport androidx.compose.material3.rememberDatePickerState\nimport androidx.compose.material3.rememberTimePickerState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.feature.event_management.ui.shared.AdaptiveContainer\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerDialog\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimePicker\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventNameSection\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceEndType\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementUiEvent\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport java.time.Instant\nimport java.time.LocalTime\nimport java.time.ZoneId\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun EditEventScreen(\n    viewModel: EventManagementViewModel,\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    userTimeZone: String,\n    eventToEdit: EventDto,\n    selectedUpdateMode: EventUpdateMode,\n    onDismiss: () -> Unit,\n    currentSheetValue: SheetValue,\n\n) {\n  var summary by remember(eventToEdit.id) { mutableStateOf(eventToEdit.summary) }\n  var description by remember(eventToEdit.id) { mutableStateOf(eventToEdit.description ?: \"\") }\n  var location by remember(eventToEdit.id) { mutableStateOf(eventToEdit.location ?: \"\") }\n\n  var summaryError by remember { mutableStateOf<String?>(null) }\n  var validationError by remember { mutableStateOf<String?>(null) }\n\n  val uiState by viewModel.uiState.collectAsState()\n\n  var generalError by remember { mutableStateOf<String?>(null) }\n  val userTimeZoneId = remember { ZoneId.of(userTimeZone) }\n\n  val context = LocalContext.current\n\n    val initialEventDateTimeState = remember(eventToEdit.id) {\n        viewModel.parseEventToState(eventToEdit)\n    }\n  var eventDateTimeState by remember(eventToEdit.id) { mutableStateOf(initialEventDateTimeState) }\n  LaunchedEffect(initialEventDateTimeState) {\n    Log.d(\"EditEventScreen\", \"Initial EventDateTimeState for UI: $initialEventDateTimeState\")\n  }\n\n  var showStartDatePicker by remember { mutableStateOf(false) }\n  var showStartTimePicker by remember { mutableStateOf(false) }\n  var showEndDatePicker by remember { mutableStateOf(false) }\n  var showEndTimePicker by remember { mutableStateOf(false) }\n  var showRecurrenceEndDatePicker by remember { mutableStateOf(false) }\n\n  LaunchedEffect(key1 = true) {\n    viewModel.eventFlow.collect { event ->\n      when (event) {\n        is EventManagementUiEvent.ShowMessage -> {}\n        is EventManagementUiEvent.OperationSuccess -> {\n          onDismiss()\n        }\n      }\n    }\n  }\n  LaunchedEffect(eventDateTimeState.startTime) {\n    suggestionsViewModel.updateSortContext(\n        eventDateTimeState.startTime, eventDateTimeState.isAllDay)\n  }\n  val suggestedChips by suggestionsViewModel.suggestionChips.collectAsStateWithLifecycle()\n\n    val onSaveClick: () -> Unit = {\n        viewModel.updateEvent(\n            summary = summary,\n            description = description,\n            location = location,\n            dateTimeState = eventDateTimeState,\n            updateMode = selectedUpdateMode\n        )\n    }\n\n  Row(\n      modifier = Modifier.fillMaxWidth().padding(horizontal = 4.dp, vertical = 0.dp),\n      verticalAlignment = Alignment.CenterVertically,\n      horizontalArrangement = Arrangement.Center) {\n        AnimatedContent(\n            targetState = currentSheetValue,\n            transitionSpec = {\n              (EnterTransition.None)\n                  .togetherWith(ExitTransition.None)\n                  .using(\n                      SizeTransform(\n                          clip = false,\n                          sizeAnimationSpec = { _, _ ->\n                            spring(\n                                dampingRatio = Spring.DampingRatioLowBouncy,\n                                stiffness = Spring.StiffnessMediumLow)\n                          }))\n            },\n            label = \"SaveButtonAnimation\") { targetSheetValue\n              -> // TODO исправить чтобы выключалась на загрузке\n              val expandedSize = ButtonDefaults.LargeContainerHeight\n              val defaultSize = ButtonDefaults.MediumContainerHeight\n\n              val isNotCompactState = targetSheetValue == SheetValue.Expanded\n\n              val size = if (!isNotCompactState) defaultSize else expandedSize\n\n              Button(\n                  onClick = onSaveClick,\n                  enabled = !uiState.isLoading,\n                  modifier = Modifier.heightIn(size),\n                  contentPadding = ButtonDefaults.contentPaddingFor(size)) {\n                    if (uiState.isLoading) {\n                      LoadingIndicator(\n                          color = colorScheme.onPrimary,\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    } else {\n                      Icon(\n                          imageVector = Icons.Filled.Check,\n                          contentDescription = stringResource(R.string.save),\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    }\n                  }\n            }\n      }\n  Column(\n      modifier =\n          Modifier.verticalScroll(rememberScrollState()).padding(horizontal = 16.dp).fillMaxWidth(),\n  ) {\n    AdaptiveContainer {\n      EventNameSection(\n          summary = summary,\n          summaryError = summaryError,\n          onSummaryChange = { summary = it },\n          onSummaryErrorChange = { summaryError = it },\n          isLoading = uiState.isLoading,\n          suggestedChips = suggestedChips)\n    }\n    AdaptiveContainer {\n      EventDateTimePicker(\n          state = eventDateTimeState,\n          onStateChange = { newState ->\n            eventDateTimeState = newState\n            validationError = null\n          },\n          isLoading = uiState.isLoading,\n          onRequestShowStartDatePicker = { showStartDatePicker = true },\n          onRequestShowStartTimePicker = { showStartTimePicker = true },\n          onRequestShowEndDatePicker = { showEndDatePicker = true },\n          onRequestShowEndTimePicker = { showEndTimePicker = true },\n          onRequestShowRecurrenceEndDatePicker = { showRecurrenceEndDatePicker = true },\n          modifier = Modifier.fillMaxWidth())\n    }\n    validationError?.let { Text(it, color = colorScheme.error, style = typography.bodySmall) }\n\n    AdaptiveContainer {\n      OutlinedTextField(\n          value = description,\n          onValueChange = { description = it },\n          label = { Text(stringResource(R.string.description)) },\n          modifier = Modifier.fillMaxWidth().height(100.dp),\n          maxLines = 4,\n          enabled = !uiState.isLoading,\n          shape = RoundedCornerShape(25.dp))\n      OutlinedTextField(\n          value = location,\n          onValueChange = { location = it },\n          label = { Text(stringResource(R.string.location)) },\n          modifier = Modifier.fillMaxWidth(),\n          singleLine = true,\n          enabled = !uiState.isLoading,\n          shape = RoundedCornerShape(25.dp))\n    }\n    generalError?.let { Text(it, color = colorScheme.error, style = typography.bodyMedium) }\n    Spacer(modifier = Modifier.height(16.dp))\n  }\n\n  val currentDateTimeState = eventDateTimeState\n\n  if (showStartDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.startDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli())\n    DatePickerDialog(\n        onDismissRequest = { showStartDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      currentDateTimeState.copy(\n                          startDate = selectedDate,\n                          endDate =\n                              if (selectedDate.isAfter(currentDateTimeState.endDate) ||\n                                  currentDateTimeState.startTime == null)\n                                  selectedDate\n                              else currentDateTimeState.endDate)\n                }\n                showStartDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n  if (showStartTimePicker) {\n    val initialTime = currentDateTimeState.startTime ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showStartTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                var newEndTime = currentDateTimeState.endTime\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.endTime != null &&\n                    !selectedTime.isBefore(currentDateTimeState.endTime)) {\n                  newEndTime = selectedTime.plusHours(1).withNano(0)\n                }\n                eventDateTimeState =\n                    currentDateTimeState.copy(startTime = selectedTime, endTime = newEndTime)\n                showStartTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n\n  if (showEndDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.endDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli(),\n            selectableDates =\n                object : SelectableDates {\n                  val startMillis =\n                      currentDateTimeState.startDate\n                          .atStartOfDay(userTimeZoneId)\n                          .toInstant()\n                          .toEpochMilli()\n\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    return utcTimeMillis >= startMillis\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= currentDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState = currentDateTimeState.copy(endDate = selectedDate)\n                }\n                showEndDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n\n  if (showEndTimePicker) {\n    val initialTime =\n        currentDateTimeState.endTime\n            ?: currentDateTimeState.startTime?.plusHours(1)\n            ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showEndTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.startTime != null &&\n                    !currentDateTimeState.startTime.isBefore(selectedTime)) {\n                  Toast.makeText(\n                          context, R.string.error_end_time_not_after_start, Toast.LENGTH_SHORT)\n                      .show()\n                } else {\n                  eventDateTimeState = currentDateTimeState.copy(endTime = selectedTime)\n                  showEndTimePicker = false\n                }\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n  if (showRecurrenceEndDatePicker) {\n    val initialSelectedDateMillis =\n        eventDateTimeState.recurrenceEndDate\n            ?.atStartOfDay(userTimeZoneId)\n            ?.toInstant()\n            ?.toEpochMilli()\n            ?: eventDateTimeState.startDate\n                .plusMonths(1)\n                .atStartOfDay(userTimeZoneId)\n                .toInstant()\n                .toEpochMilli()\n\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis = initialSelectedDateMillis,\n            selectableDates =\n                object : SelectableDates {\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    val selectedLocalDate =\n                        Instant.ofEpochMilli(utcTimeMillis).atZone(userTimeZoneId).toLocalDate()\n                    return !selectedLocalDate.isBefore(eventDateTimeState.startDate)\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= eventDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showRecurrenceEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      eventDateTimeState.copy(\n                          recurrenceEndDate = selectedDate,\n                          recurrenceEndType = RecurrenceEndType.DATE,\n                          recurrenceCount = null)\n                }\n                showRecurrenceEndDatePicker = false\n              },\n          ) {\n            Text(\"OK\")\n          }\n        },\n        dismissButton = {\n          TextButton(onClick = { showRecurrenceEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n}",
      "info": {
        "size": 18672,
        "last_modified": "2025-08-06T10:04:47.845764",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "ui/create/CreateEventScreen.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.create\n\nimport android.text.format.DateFormat\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.ExitTransition\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.DatePicker\nimport androidx.compose.material3.DatePickerDialog\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.SelectableDates\nimport androidx.compose.material3.SheetValue\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TimePicker\nimport androidx.compose.material3.rememberDatePickerState\nimport androidx.compose.material3.rememberTimePickerState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.event_management.ui.shared.AdaptiveContainer\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerDialog\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimePicker\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimeState\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventNameSection\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceEndType\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementUiEvent\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport java.time.Instant\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.ZoneId\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun CreateEventScreen(\n    viewModel: EventManagementViewModel = hiltViewModel(),\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    userTimeZone: String,\n    initialDate: LocalDate,\n    onDismiss: () -> Unit,\n    currentSheetValue: SheetValue\n) {\n  var summary by remember { mutableStateOf(\"\") }\n  var description by remember { mutableStateOf(\"\") }\n  var location by remember { mutableStateOf(\"\") }\n  val userTimeZoneId = remember { ZoneId.of(userTimeZone) }\n\n  var summaryError by remember { mutableStateOf<String?>(null) }\n  var validationError by remember { mutableStateOf<String?>(null) }\n\n  var generalError by remember { mutableStateOf<String?>(null) }\n\n  val context = LocalContext.current\n  val uiState by viewModel.uiState.collectAsState()\n  var showStartDatePicker by remember { mutableStateOf(false) }\n  var showStartTimePicker by remember { mutableStateOf(false) }\n  var showEndDatePicker by remember { mutableStateOf(false) }\n  var showEndTimePicker by remember { mutableStateOf(false) }\n  var showRecurrenceEndDatePicker by remember { mutableStateOf(false) }\n\n  var eventDateTimeState by remember {\n    val defaultStartTime = LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0)\n    val defaultEndTime = LocalTime.now().plusHours(2).withMinute(0).withSecond(0).withNano(0)\n    var effectiveEndDate = initialDate\n\n    if (defaultEndTime.isBefore(defaultStartTime)) {\n      effectiveEndDate = initialDate.plusDays(1)\n    }\n\n    mutableStateOf(\n        EventDateTimeState(\n            startDate = initialDate,\n            startTime = LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0),\n            endDate = effectiveEndDate,\n            endTime = LocalTime.now().plusHours(2).withMinute(0).withSecond(0).withNano(0),\n            isAllDay = false,\n            selectedWeekdays = emptySet(),\n            recurrenceEndType = RecurrenceEndType.NEVER,\n            isRecurring = false,\n            recurrenceRule = null))\n  }\n\n  LaunchedEffect(key1 = true) {\n    viewModel.eventFlow.collect { event ->\n      when (event) {\n        is EventManagementUiEvent.ShowMessage -> {\n          //          Toast.makeText(context, event.message, Toast.LENGTH_SHORT).show()\n        }\n        is EventManagementUiEvent.OperationSuccess -> {\n          onDismiss()\n        }\n      }\n    }\n  }\n  LaunchedEffect(eventDateTimeState.startTime) {\n    suggestionsViewModel.updateSortContext(\n        eventDateTimeState.startTime, eventDateTimeState.isAllDay)\n  }\n  val suggestedChips by suggestionsViewModel.suggestionChips.collectAsStateWithLifecycle()\n\n  val onSaveClick: () -> Unit = saveLambda@{\n      viewModel.createEvent(\n          summary = summary,\n          description = description,\n          location = location,\n          dateTimeState = eventDateTimeState\n      )\n    }\n\n\n  Row(\n      modifier = Modifier.fillMaxWidth().padding(horizontal = 4.dp, vertical = 0.dp),\n      verticalAlignment = Alignment.CenterVertically,\n      horizontalArrangement = Arrangement.Center) {\n        AnimatedContent(\n            targetState = currentSheetValue,\n            transitionSpec = {\n              (EnterTransition.None)\n                  .togetherWith(ExitTransition.None)\n                  .using(\n                      SizeTransform(\n                          clip = false,\n                          sizeAnimationSpec = { _, _ ->\n                            spring(\n                                dampingRatio = Spring.DampingRatioLowBouncy,\n                                stiffness = Spring.StiffnessMediumLow)\n                          }))\n            },\n            label = \"SaveButtonAnimation\") { targetSheetValue ->\n              val expandedSize = ButtonDefaults.LargeContainerHeight\n              val defaultSize = ButtonDefaults.MediumContainerHeight\n\n              val isNotCompactState = targetSheetValue == SheetValue.Expanded\n\n              val size = if (!isNotCompactState) defaultSize else expandedSize\n\n              Button(\n                  onClick = onSaveClick,\n                  enabled = !uiState.isLoading,\n                  modifier = Modifier.heightIn(size),\n                  contentPadding = ButtonDefaults.contentPaddingFor(size)) {\n                    if (uiState.isLoading) {\n                      LoadingIndicator(\n                          color = colorScheme.onPrimary,\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    } else {\n                      Icon(\n                          imageVector = Icons.Filled.Check,\n                          contentDescription = \"Сохранить\",\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    }\n                  }\n            }\n      }\n\n  Column(\n      modifier =\n          Modifier.verticalScroll(rememberScrollState())\n              .padding(horizontal = 16.dp, vertical = 4.dp)\n              .fillMaxWidth(),\n      verticalArrangement = Arrangement.spacedBy(4.dp)) {\n        AdaptiveContainer {\n          EventNameSection(\n              summary = summary,\n              summaryError = summaryError,\n              onSummaryChange = { summary = it },\n              onSummaryErrorChange = { summaryError = it },\n              isLoading = uiState.isLoading,\n              suggestedChips = suggestedChips)\n        }\n        AdaptiveContainer {\n          EventDateTimePicker(\n              state = eventDateTimeState,\n              onStateChange = { newState ->\n                eventDateTimeState = newState\n                validationError = null\n              },\n              isLoading = uiState.isLoading,\n              onRequestShowStartDatePicker = { showStartDatePicker = true },\n              onRequestShowStartTimePicker = { showStartTimePicker = true },\n              onRequestShowEndDatePicker = { showEndDatePicker = true },\n              onRequestShowEndTimePicker = { showEndTimePicker = true },\n              onRequestShowRecurrenceEndDatePicker = { showRecurrenceEndDatePicker = true },\n              modifier = Modifier.fillMaxWidth())\n        }\n        validationError?.let { Text(it, color = colorScheme.error, style = typography.bodySmall) }\n\n        AdaptiveContainer {\n          OutlinedTextField(\n              value = description,\n              onValueChange = { description = it },\n              label = { Text(stringResource(R.string.description)) },\n              modifier = Modifier.fillMaxWidth().height(100.dp),\n              maxLines = 4,\n              enabled = !uiState.isLoading,\n              shape = RoundedCornerShape(25.dp))\n          OutlinedTextField(\n              value = location,\n              onValueChange = { location = it },\n              label = { Text(stringResource(R.string.location)) },\n              modifier = Modifier.fillMaxWidth(),\n              singleLine = true,\n              enabled = !uiState.isLoading,\n              shape = RoundedCornerShape(25.dp))\n        }\n        generalError?.let { Text(it, color = colorScheme.error, style = typography.bodyMedium) }\n        Spacer(modifier = Modifier.height(16.dp))\n      }\n\n  val currentDateTimeState = eventDateTimeState\n\n  if (showStartDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.startDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli())\n    DatePickerDialog(\n        onDismissRequest = { showStartDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      currentDateTimeState.copy(\n                          startDate = selectedDate,\n                          endDate =\n                              if (selectedDate.isAfter(currentDateTimeState.endDate) ||\n                                  currentDateTimeState.startTime == null)\n                                  selectedDate\n                              else currentDateTimeState.endDate)\n                }\n                showStartDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n  if (showStartTimePicker) {\n    val initialTime = currentDateTimeState.startTime ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showStartTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                var newEndTime = currentDateTimeState.endTime\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.endTime != null &&\n                    !selectedTime.isBefore(currentDateTimeState.endTime)) {\n                  newEndTime = selectedTime.plusHours(1).withNano(0)\n                }\n                eventDateTimeState =\n                    currentDateTimeState.copy(startTime = selectedTime, endTime = newEndTime)\n                showStartTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n\n  if (showEndDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.endDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli(),\n            selectableDates =\n                object : SelectableDates {\n                  val startMillis =\n                      currentDateTimeState.startDate\n                          .atStartOfDay(userTimeZoneId)\n                          .toInstant()\n                          .toEpochMilli()\n\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    return utcTimeMillis >= startMillis\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= currentDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState = currentDateTimeState.copy(endDate = selectedDate)\n                }\n                showEndDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n\n  if (showEndTimePicker) {\n    val initialTime =\n        currentDateTimeState.endTime\n            ?: currentDateTimeState.startTime?.plusHours(1)\n            ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showEndTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n\n                var newFinalEndDate = currentDateTimeState.endDate\n\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.startTime != null &&\n                    selectedTime.isBefore(currentDateTimeState.startTime)) {\n                  newFinalEndDate = currentDateTimeState.startDate.plusDays(1)\n                }\n\n                eventDateTimeState =\n                    currentDateTimeState.copy(endTime = selectedTime, endDate = newFinalEndDate)\n                showEndTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n  if (showRecurrenceEndDatePicker) {\n    val initialSelectedDateMillis =\n        eventDateTimeState.recurrenceEndDate\n            ?.atStartOfDay(userTimeZoneId)\n            ?.toInstant()\n            ?.toEpochMilli()\n            ?: eventDateTimeState.startDate\n                .plusMonths(1)\n                .atStartOfDay(userTimeZoneId)\n                .toInstant()\n                .toEpochMilli()\n\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis = initialSelectedDateMillis,\n            selectableDates =\n                object : SelectableDates {\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    val selectedLocalDate =\n                        Instant.ofEpochMilli(utcTimeMillis).atZone(userTimeZoneId).toLocalDate()\n                    return !selectedLocalDate.isBefore(eventDateTimeState.startDate)\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= eventDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showRecurrenceEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      eventDateTimeState.copy(\n                          recurrenceEndDate = selectedDate,\n                          recurrenceEndType = RecurrenceEndType.DATE,\n                          recurrenceCount = null)\n                }\n                showRecurrenceEndDatePicker = false\n              },\n          ) {\n            Text(\"OK\")\n          }\n        },\n        dismissButton = {\n          TextButton(onClick = { showRecurrenceEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n}\n",
      "info": {
        "size": 19249,
        "last_modified": "2025-08-06T10:04:47.847769",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "vm/EventManagementViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.vm\n\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.EventDeleteMode\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport com.lpavs.caliinda.core.data.repository.CalendarRepository\nimport com.lpavs.caliinda.core.data.repository.SettingsRepository\nimport com.lpavs.caliinda.core.data.utils.UiText\nimport com.lpavs.caliinda.core.ui.util.IDateTimeUtils\nimport com.lpavs.caliinda.feature.calendar.ui.components.IFunMessages\nimport com.lpavs.caliinda.feature.event_management.ui.shared.RecurringDeleteChoice\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimeState\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceEndType\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceOption\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport java.time.DayOfWeek\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.OffsetDateTime\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\nimport java.time.format.DateTimeParseException\nimport javax.inject.Inject\n\n@HiltViewModel\nclass EventManagementViewModel\n@Inject\nconstructor(\n    settingsRepository: SettingsRepository,\n    private val calendarRepository: CalendarRepository,\n    private val funMessages: IFunMessages,\n    private val dateTimeUtils: IDateTimeUtils\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(EventManagementUiState())\n    val uiState: StateFlow<EventManagementUiState> = _uiState.asStateFlow()\n\n    private val _eventFlow = MutableSharedFlow<EventManagementUiEvent>()\n    val eventFlow: SharedFlow<EventManagementUiEvent> = _eventFlow.asSharedFlow()\n\n    val timeZone: StateFlow<String> =\n        settingsRepository.timeZoneFlow.stateIn(\n            viewModelScope, SharingStarted.WhileSubscribed(5000), ZoneId.systemDefault().id\n        )\n    private val untilFormatter = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n\n    fun confirmEventUpdate(updatedEventData: EventRequest, modeFromUi: EventUpdateMode) {\n        val originalEvent = _uiState.value.eventBeingEdited ?: return\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true, operationError = null) }\n            val result =\n                calendarRepository.updateEvent(\n                    eventId = originalEvent.id, updateData = updatedEventData, mode = modeFromUi\n                )\n            _uiState.update { it.copy(isLoading = false) }\n            if (result.isSuccess) {\n                val message = funMessages.getEventUpdatedMessage(originalEvent.summary)\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n            } else {\n                val message =\n                    result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                        ?: funMessages.getUpdateErrorMessage()\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n            }\n        }\n    }\n\n    fun createEvent(\n        summary: String,\n        description: String,\n        location: String,\n        dateTimeState: EventDateTimeState\n    ) {\n        viewModelScope.launch {\n            // 1. Валидация\n            if (!validateInput(summary, dateTimeState)) {\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(UiText.from(R.string.error_check_input_data)))\n                return@launch\n            }\n\n            _uiState.update { it.copy(isLoading = true, operationError = null) }\n\n            // 2. Форматирование строк времени\n            val (startStr, endStr) = formatEventTimesForSaving(dateTimeState)\n            if (startStr == null || endStr == null) {\n                _uiState.update { it.copy(isLoading = false) }\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(UiText.from(R.string.error_failed_to_format_datetime)))\n                Log.e(TAG, \"Failed to format strings based on state: $dateTimeState and TimeZone: ${timeZone.value}\")\n                return@launch\n            }\n\n            // 3. Построение RRULE\n            val finalRecurrenceRule = buildRecurrenceRule(dateTimeState)\n            Log.d(TAG, \"Final RRULE to send: $finalRecurrenceRule\")\n\n\n            // 4. Создание объекта запроса\n            val request = EventRequest(\n                summary = summary.trim(),\n                startTime = startStr,\n                endTime = endStr,\n                isAllDay = dateTimeState.isAllDay,\n                timeZoneId = if (dateTimeState.isAllDay) null else timeZone.value,\n                description = description.trim().takeIf { it.isNotEmpty() },\n                location = location.trim().takeIf { it.isNotEmpty() },\n                recurrence = finalRecurrenceRule?.let { listOf(\"RRULE:$it\") }\n            )\n\n            // 5. Отправка в репозиторий\n            val result = calendarRepository.createEvent(request)\n            _uiState.update { it.copy(isLoading = false) }\n\n            // 6. Обработка результата\n            if (result.isSuccess) {\n                val message = funMessages.getEventCreatedMessage(request.summary)\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n            } else {\n                val message =\n                    result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                        ?: funMessages.getCreateErrorMessage()\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n            }\n        }\n    }\n\n    fun updateEvent(\n        summary: String,\n        description: String,\n        location: String,\n        dateTimeState: EventDateTimeState,\n        updateMode: EventUpdateMode\n    ) {\n        viewModelScope.launch {\n            val originalEvent = uiState.value.eventBeingEdited\n            if (originalEvent == null) {\n                Log.e(TAG, \"updateEvent called but originalEvent is null\")\n                return@launch\n            }\n\n            if (!validateInput(summary, dateTimeState)) {\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(UiText.from(R.string.error_check_input_data)))\n                return@launch\n            }\n\n            _uiState.update { it.copy(isLoading = true) }\n\n            val (startStr, endStr) = formatEventTimesForSaving(dateTimeState)\n            if (startStr == null || endStr == null) {\n                _uiState.update { it.copy(isLoading = false) }\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(UiText.from(R.string.error_failed_to_format_datetime)))\n                return@launch\n            }\n\n            val finalRecurrenceRule = buildRecurrenceRule(dateTimeState)\n\n            val updateRequest = buildUpdateEventApiRequest(\n                originalEvent = originalEvent,\n                currentSummary = summary.trim(),\n                currentDescription = description.trim(),\n                currentLocation = location.trim(),\n                currentDateTimeState = dateTimeState,\n                formattedStartStr = startStr,\n                formattedEndStr = endStr,\n                finalRRuleStringFromUi = finalRecurrenceRule,\n                selectedUpdateMode = updateMode\n            )\n\n            if (updateRequest == null) {\n                _uiState.update { it.copy(isLoading = false) }\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(UiText.from(R.string.no_changes_to_save)))\n                _eventFlow.emit(EventManagementUiEvent.OperationSuccess) // Закрываем экран\n                return@launch\n            }\n\n            confirmEventUpdate(updateRequest, updateMode)\n        }\n    }\n\n    private fun validateInput(summary: String, state: EventDateTimeState): Boolean {\n        if (summary.isBlank()) {\n            // Можно добавить специальное событие для подсветки поля, если нужно\n            return false\n        }\n        if (!state.isAllDay && (state.startTime == null || state.endTime == null)) {\n            return false\n        }\n        val (start, end) = formatEventTimesForSaving(state)\n        return start != null && end != null\n    }\n\n    private fun formatEventTimesForSaving(state: EventDateTimeState): Pair<String?, String?> {\n        return if (state.isAllDay) {\n            val formatter = DateTimeFormatter.ISO_LOCAL_DATE\n            val startDateStr = try { state.startDate.format(formatter) } catch (_: Exception) { null }\n            // Для all-day событий, конечная дата должна быть на день позже и не включаться\n            val effectiveEndDate = state.endDate.plusDays(1)\n            val endDateStr = try { effectiveEndDate.format(formatter) } catch (_: Exception) { null }\n            Pair(startDateStr, endDateStr)\n        } else {\n            val timeZoneId = timeZone.value\n            if (timeZoneId.isBlank()) {\n                Log.e(TAG, \"Cannot format timed event without TimeZone ID!\")\n                return Pair(null, null)\n            }\n            // Используем ISO_OFFSET_DATE_TIME для бэкенда\n            val startTimeIso = dateTimeUtils.formatDateTimeToIsoWithOffset(\n                state.startDate, state.startTime, false, timeZoneId\n            )\n            val endTimeIso = dateTimeUtils.formatDateTimeToIsoWithOffset(\n                state.endDate, state.endTime, false, timeZoneId\n            )\n            Pair(startTimeIso, endTimeIso)\n        }\n    }\n\n    private fun buildRecurrenceRule(state: EventDateTimeState): String? {\n        val baseRule = state.recurrenceRule?.takeIf { it.isNotBlank() } ?: return null\n\n        val ruleParts = mutableListOf(baseRule) // Начинаем с FREQ=...\n\n        if (baseRule == RecurrenceOption.Weekly.rruleValue && state.selectedWeekdays.isNotEmpty()) {\n            val bydayString = state.selectedWeekdays.sorted().joinToString(\",\") { day ->\n                when (day) {\n                    DayOfWeek.MONDAY -> \"MO\"\n                    DayOfWeek.TUESDAY -> \"TU\"\n                    DayOfWeek.WEDNESDAY -> \"WE\"\n                    DayOfWeek.THURSDAY -> \"TH\"\n                    DayOfWeek.FRIDAY -> \"FR\"\n                    DayOfWeek.SATURDAY -> \"SA\"\n                    DayOfWeek.SUNDAY -> \"SU\"\n                }\n            }\n            ruleParts.add(\"BYDAY=$bydayString\")\n        }\n\n        when (state.recurrenceEndType) {\n            RecurrenceEndType.DATE -> {\n                state.recurrenceEndDate?.let { endDate ->\n                    val endDateTimeUtc = endDate\n                        .atTime(23, 59, 59)\n                        .atZone(ZoneId.of(timeZone.value))\n                        .withZoneSameInstant(ZoneOffset.UTC)\n                    val untilString = untilFormatter.format(endDateTimeUtc)\n                    ruleParts.add(\"UNTIL=$untilString\")\n                }\n            }\n            RecurrenceEndType.COUNT -> {\n                state.recurrenceCount?.let { count -> ruleParts.add(\"COUNT=$count\") }\n            }\n            RecurrenceEndType.NEVER -> { /* Ничего не добавляем */ }\n        }\n\n        return ruleParts.joinToString(\";\")\n    }\n\n    fun parseEventToState(event: EventDto): EventDateTimeState {\n        val userTimeZoneId = timeZone.value\n        val isAllDay = event.isAllDay\n\n        var parsedStartDate: LocalDate = LocalDate.now()\n        var parsedStartTime: LocalTime? = null\n        var parsedEndDate: LocalDate = LocalDate.now()\n        var parsedEndTime: LocalTime? = null\n\n        try {\n            if (isAllDay) {\n                parsedStartDate = LocalDate.parse(event.startTime, DateTimeFormatter.ISO_LOCAL_DATE)\n                parsedEndDate = LocalDate.parse(event.endTime, DateTimeFormatter.ISO_LOCAL_DATE).minusDays(1)\n            } else {\n                val startInstant = dateTimeUtils.parseToInstant(event.startTime, userTimeZoneId)\n                val endInstant = dateTimeUtils.parseToInstant(event.endTime, userTimeZoneId)\n\n                if (startInstant != null) {\n                    val startZonedDateTime = startInstant.atZone(ZoneId.of(userTimeZoneId))\n                    parsedStartDate = startZonedDateTime.toLocalDate()\n                    parsedStartTime = startZonedDateTime.toLocalTime().withNano(0)\n                }\n                if (endInstant != null) {\n                    val endZonedDateTime = endInstant.atZone(ZoneId.of(userTimeZoneId))\n                    parsedEndDate = endZonedDateTime.toLocalDate()\n                    parsedEndTime = endZonedDateTime.toLocalTime().withNano(0)\n                }\n            }\n        } catch (e: Exception) {\n            Log.e(TAG, \"Error parsing event date/time for editing: ${e.message}\")\n            val now = ZonedDateTime.now(ZoneId.of(userTimeZoneId))\n            parsedStartDate = now.toLocalDate()\n            parsedStartTime = if (!isAllDay) now.toLocalTime().plusHours(1).withMinute(0) else null\n            parsedEndDate = parsedStartDate\n            parsedEndTime = if (!isAllDay) parsedStartTime?.plusHours(1) else null\n        }\n\n        // ... (остальная логика парсинга RRULE остается без изменений) ...\n        var recurrenceOption: RecurrenceOption? = null\n        var selectedWeekdays: Set<DayOfWeek> = emptySet()\n        var recurrenceEndType = RecurrenceEndType.NEVER\n        var recurrenceEndDate: LocalDate? = null\n        var recurrenceCount: Int? = null\n        var isRecurring = false\n\n        event.recurrenceRule?.let { rruleString ->\n            isRecurring = true\n            val rules = rruleString.split(';')\n            rules.forEach { rulePart ->\n                val parts = rulePart.split('=')\n                if (parts.size == 2) {\n                    val key = parts[0]\n                    val value = parts[1]\n                    when (key) {\n                        \"FREQ\" -> {\n                            recurrenceOption = RecurrenceOption.ALL_OPTIONS.find { it.rruleValue == \"FREQ=$value\" }\n                        }\n                        \"BYDAY\" -> {\n                            selectedWeekdays =\n                                value\n                                    .split(',')\n                                    .mapNotNull { dayStr ->\n                                        when (dayStr) {\n                                            \"MO\" -> DayOfWeek.MONDAY\n                                            \"TU\" -> DayOfWeek.TUESDAY\n                                            \"WE\" -> DayOfWeek.WEDNESDAY\n                                            \"TH\" -> DayOfWeek.THURSDAY\n                                            \"FR\" -> DayOfWeek.FRIDAY\n                                            \"SA\" -> DayOfWeek.SATURDAY\n                                            \"SU\" -> DayOfWeek.SUNDAY\n                                            else -> null\n                                        }\n                                    }\n                                    .toSet()\n                        }\n                        \"UNTIL\" -> {\n                            try {\n                                val zonedDateTime = ZonedDateTime.parse(value, untilFormatter.withZone(ZoneOffset.UTC))\n                                recurrenceEndDate = zonedDateTime.withZoneSameInstant(ZoneId.of(userTimeZoneId)).toLocalDate()\n                                recurrenceEndType = RecurrenceEndType.DATE\n                            } catch (e: Exception) {\n                                Log.e(TAG, \"Error parsing UNTIL value: $value - ${e.message}\")\n                            }\n                        }\n                        \"COUNT\" -> {\n                            recurrenceCount = value.toIntOrNull()\n                            if (recurrenceCount != null) recurrenceEndType = RecurrenceEndType.COUNT\n                        }\n                    }\n                }\n            }\n        }\n\n        return EventDateTimeState(\n            startDate = parsedStartDate,\n            startTime = parsedStartTime,\n            endDate = parsedEndDate,\n            endTime = parsedEndTime,\n            isAllDay = isAllDay,\n            isRecurring = isRecurring,\n            recurrenceRule = recurrenceOption?.rruleValue,\n            selectedWeekdays = selectedWeekdays,\n            recurrenceEndType = recurrenceEndType,\n            recurrenceEndDate = recurrenceEndDate,\n            recurrenceCount = recurrenceCount\n        )\n    }\n\n    private fun buildUpdateEventApiRequest(\n        originalEvent: EventDto,\n        currentSummary: String,\n        currentDescription: String,\n        currentLocation: String,\n        currentDateTimeState: EventDateTimeState,\n        formattedStartStr: String,\n        formattedEndStr: String,\n        finalRRuleStringFromUi: String?,\n        selectedUpdateMode: EventUpdateMode\n    ): EventRequest? {\n        var hasChanges = false\n\n        val summaryUpdate = currentSummary.takeIf { it != originalEvent.summary }?.also { hasChanges = true }\n        val descriptionUpdate = currentDescription.takeIf { it != (originalEvent.description ?: \"\") }?.also { hasChanges = true }\n        val locationUpdate = currentLocation.takeIf { it != (originalEvent.location ?: \"\") }?.also { hasChanges = true }\n\n        var startTimeUpdate: String? = null\n        var endTimeUpdate: String? = null\n        var isAllDayUpdate: Boolean? = null\n        var timeZoneIdUpdate: String? = null\n\n        val originalRRuleString = originalEvent.recurrenceRule?.takeIf { it.isNotBlank() }\n        val currentRRuleString = finalRRuleStringFromUi?.takeIf { it.isNotBlank() }\n        val recurrenceRuleChanged = currentRRuleString != originalRRuleString\n\n        val isOnlyRecurrenceChangeForAllEvents =\n            recurrenceRuleChanged &&\n                    selectedUpdateMode == EventUpdateMode.ALL_IN_SERIES &&\n                    currentSummary == originalEvent.summary &&\n                    currentDescription == (originalEvent.description ?: \"\") &&\n                    currentLocation == (originalEvent.location ?: \"\") &&\n                    currentDateTimeState.isAllDay == originalEvent.isAllDay\n\n        if (!isOnlyRecurrenceChangeForAllEvents) {\n            if (currentDateTimeState.isAllDay != originalEvent.isAllDay) {\n                isAllDayUpdate = currentDateTimeState.isAllDay\n                hasChanges = true\n            }\n\n            val originalStartTimeState = parseEventToState(originalEvent)\n            val (originalStartStr, originalEndStr) = formatEventTimesForSaving(originalStartTimeState)\n\n            if (formattedStartStr != originalStartStr) {\n                startTimeUpdate = formattedStartStr\n                hasChanges = true\n            }\n            if (formattedEndStr != originalEndStr) {\n                endTimeUpdate = formattedEndStr\n                hasChanges = true\n            }\n\n            if (!currentDateTimeState.isAllDay) {\n                if (timeZone.value.isNotBlank()) {\n                    if (isAllDayUpdate == false || (isAllDayUpdate == null && (startTimeUpdate != null || endTimeUpdate != null))) {\n                        timeZoneIdUpdate = timeZone.value\n                        // Считаем изменение таймзоны изменением только если она действительно поменялась, а не просто добавляется\n                        // hasChanges = true\n                    }\n                }\n            }\n        }\n\n        var recurrenceForApiRequest: List<String>? = null\n        if (recurrenceRuleChanged) {\n            hasChanges = true\n            recurrenceForApiRequest = if (currentRRuleString != null) {\n                listOf(\"RRULE:$currentRRuleString\")\n            } else {\n                emptyList() // Для удаления правила\n            }\n        }\n\n        if (selectedUpdateMode == EventUpdateMode.SINGLE_INSTANCE && recurrenceForApiRequest != null) {\n            recurrenceForApiRequest = null // Нельзя менять правило для одного экземпляра\n        }\n\n        if (!hasChanges) {\n            Log.d(TAG, \"No actual changes to save after considering all fields.\")\n            return null\n        }\n\n        return EventRequest(\n            summary = summaryUpdate,\n            description = descriptionUpdate,\n            location = locationUpdate,\n            startTime = startTimeUpdate,\n            endTime = endTimeUpdate,\n            isAllDay = isAllDayUpdate,\n            timeZoneId = timeZoneIdUpdate,\n            recurrence = recurrenceForApiRequest\n        )\n    }\n    fun requestDeleteConfirmation(event: EventDto) {\n        _uiState.update {\n            val isActuallyRecurring = event.recurringEventId != null || event.originalStartTime != null\n            Log.d(\n                TAG,\n                \"requestDeleteConfirmation for event: ${event.id}, summary: '${event.summary}', isAllDay: ${event.isAllDay}, recurringId: ${event.recurringEventId}, originalStart: ${event.originalStartTime}, calculatedIsRecurring: $isActuallyRecurring\"\n            )\n\n            it.copy(\n                eventPendingDeletion = event,\n                showDeleteConfirmationDialog = !isActuallyRecurring,\n                showRecurringDeleteOptionsDialog = isActuallyRecurring,\n            )\n        }\n    }\n\n    fun cancelDelete() {\n        _uiState.update {\n            it.copy(\n                eventPendingDeletion = null,\n                showDeleteConfirmationDialog = false,\n                showRecurringDeleteOptionsDialog = false\n            )\n        }\n    }\n\n    fun confirmDeleteEvent() {\n        val eventToDelete = _uiState.value.eventPendingDeletion ?: return\n\n        viewModelScope.launch {\n            _uiState.update {\n                it.copy(\n                    isLoading = true,\n                    showDeleteConfirmationDialog = false,\n                    eventPendingDeletion = null,\n                    operationError = null\n                )\n            }\n\n            val result = calendarRepository.deleteEvent(eventToDelete.id, EventDeleteMode.DEFAULT)\n            _uiState.update { it.copy(isLoading = false) }\n            if (result.isSuccess) {\n                val message = funMessages.getEventDeletedMessage(eventToDelete.summary)\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n            } else {\n                val errorMessage: UiText =\n                    result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                        ?: run { funMessages.getDeleteErrorMessage() }\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n            }\n        }\n    }\n\n    fun confirmRecurringDelete(choice: RecurringDeleteChoice) {\n        val eventToDelete = _uiState.value.eventPendingDeletion ?: return\n        _uiState.update {\n            it.copy(\n                isLoading = true,\n                showDeleteConfirmationDialog = false,\n                eventPendingDeletion = null,\n                operationError = null\n            )\n        }\n\n        when (choice) {\n            RecurringDeleteChoice.SINGLE_INSTANCE -> {\n                viewModelScope.launch {\n                    val result =\n                        calendarRepository.deleteEvent(eventToDelete.id, EventDeleteMode.INSTANCE_ONLY)\n                    _uiState.update { it.copy(isLoading = false) }\n\n                    if (result.isSuccess) {\n                        val message = funMessages.getSeriesDeletedMessage()\n                        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n                    } else {\n                        val errorMessage: UiText =\n                            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                                ?: run { funMessages.getGenericErrorMessage() }\n                        _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n                    }\n                }\n            }\n\n            RecurringDeleteChoice.THIS_AND_FOLLOWING -> {\n                handleThisAndFollowingDelete(eventToDelete)\n            }\n\n            RecurringDeleteChoice.ALL_IN_SERIES -> {\n                val idForBackendCall = eventToDelete.recurringEventId ?: eventToDelete.id\n                viewModelScope.launch {\n                    val result = calendarRepository.deleteEvent(idForBackendCall, EventDeleteMode.DEFAULT)\n                    _uiState.update { it.copy(isLoading = false) }\n\n                    if (result.isSuccess) {\n                        val message = funMessages.getSeriesDeletedMessage()\n                        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n                    } else {\n                        val errorMessage: UiText =\n                            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                                ?: run { funMessages.getGenericErrorMessage() }\n                        _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n                    }\n                }\n            }\n        }\n    }\n\n    private fun handleThisAndFollowingDelete(eventInstance: EventDto) {\n        val originalRRule = eventInstance.recurrenceRule\n        if (originalRRule.isNullOrBlank()) {\n            Log.e(\n                TAG,\n                \"Cannot perform 'this and following' delete: Event ${eventInstance.id} has no recurrence rule.\"\n            )\n            _uiState.update { it.copy(operationError = funMessages.getGenericErrorMessage()) }\n            return\n        }\n\n        val masterEventId = eventInstance.recurringEventId ?: eventInstance.id\n\n        val instanceStartDate: LocalDate =\n            try {\n                OffsetDateTime.parse(eventInstance.startTime, DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n                    .toLocalDate()\n            } catch (_: DateTimeParseException) {\n                try {\n                    LocalDate.parse(eventInstance.startTime, DateTimeFormatter.ISO_LOCAL_DATE)\n                } catch (e2: DateTimeParseException) {\n                    Log.e(\n                        TAG,\n                        \"Failed to parse event start time in any known format: ${eventInstance.startTime}\",\n                        e2\n                    )\n                    _uiState.update { it.copy(operationError = funMessages.getGenericErrorMessage()) }\n                    return\n                }\n            }\n\n        val newUntilDate = instanceStartDate.minusDays(1)\n\n        val untilString =\n            newUntilDate\n                .atTime(23, 59, 59)\n                .atZone(ZoneOffset.UTC)\n                .format(DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\"))\n\n        val ruleParts =\n            originalRRule.split(';').filterNot {\n                it.startsWith(\"UNTIL=\", ignoreCase = true) || it.startsWith(\"COUNT=\", ignoreCase = true)\n            }\n        val newRRuleString = \"RRULE:\" + ruleParts.joinToString(\";\") + \";UNTIL=$untilString\"\n\n        val updateRequest = EventRequest(recurrence = listOf(newRRuleString))\n\n        Log.d(\n            TAG, \"Updating master event $masterEventId to stop recurrence. New RRULE: $newRRuleString\"\n        )\n\n        viewModelScope.launch {\n            val result =\n                calendarRepository.updateEvent(\n                    eventId = masterEventId,\n                    updateData = updateRequest,\n                    mode = EventUpdateMode.ALL_IN_SERIES\n                )\n            _uiState.update { it.copy(isLoading = false) }\n            if (result.isSuccess) {\n                val message = funMessages.getSeriesDeletedMessage()\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n                _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n            } else {\n                val errorMessage: UiText =\n                    result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                        ?: run { funMessages.getGenericErrorMessage() }\n                _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n            }\n        }\n    }\n\n    fun requestEditEvent(event: EventDto) {\n        val isAlreadyRecurring =\n            event.recurringEventId != null ||\n                    event.originalStartTime != null ||\n                    !event.recurrenceRule.isNullOrEmpty()\n\n        _uiState.update {\n            it.copy(\n                eventBeingEdited = event,\n                showRecurringEditOptionsDialog = isAlreadyRecurring,\n                showEditEventDialog = !isAlreadyRecurring,\n                selectedUpdateMode =\n                    if (!isAlreadyRecurring) {\n                        EventUpdateMode.ALL_IN_SERIES\n                    } else {\n                        it.selectedUpdateMode\n                    },\n            )\n        }\n        Log.d(\n            TAG,\n            \"Requested edit for event ID: ${event.id}, isAlreadyRecurring: $isAlreadyRecurring, initial selectedUpdateMode for form: ${_uiState.value.selectedUpdateMode}\"\n        )\n    }\n\n    fun onRecurringEditOptionSelected(choice: EventUpdateMode) {\n        val currentEvent = _uiState.value.eventBeingEdited\n        if (currentEvent == null) {\n            Log.e(TAG, \"onRecurringEditOptionSelected called but eventBeingEdited is null.\")\n            cancelEditEvent()\n            return\n        }\n\n        Log.d(\n            TAG,\n            \"Recurring edit mode selected: $choice for event: ${currentEvent.id}. Current RRULE in event: ${currentEvent.recurrenceRule}\"\n        )\n\n        _uiState.update {\n            it.copy(\n                showRecurringEditOptionsDialog = false,\n                showEditEventDialog = true,\n                selectedUpdateMode = choice\n            )\n        }\n    }\n\n    fun cancelEditEvent() {\n        _uiState.update {\n            it.copy(\n                eventBeingEdited = null,\n                showRecurringEditOptionsDialog = false,\n                showEditEventDialog = false\n            )\n        }\n        Log.d(TAG, \"Event editing cancelled.\")\n    }\n\n    fun requestEventDetails(event: EventDto) {\n        _uiState.update { currentState ->\n            currentState.copy(eventForDetailedView = event, showEventDetailedView = true)\n        }\n        Log.d(TAG, \"Requested event details for event ID: ${event.id}\")\n    }\n\n    fun cancelEventDetails() {\n        _uiState.update { currentState ->\n            currentState.copy(eventForDetailedView = null, showEventDetailedView = false)\n        }\n        Log.d(TAG, \"Cancelled event details view.\")\n    }\n\n    companion object {\n        private const val TAG = \"EventManagementViewModel\"\n    }\n}\n\n\ndata class EventManagementUiState(\n    val operationError: UiText? = null,\n    val isLoading: Boolean = false,\n    val eventToDeleteId: String? = null,\n    val eventPendingDeletion: EventDto? = null,\n    val showDeleteConfirmationDialog: Boolean = false,\n    val showRecurringDeleteOptionsDialog: Boolean = false,\n    val eventBeingEdited: EventDto? = null,\n    val showRecurringEditOptionsDialog: Boolean = false,\n    val showEditEventDialog: Boolean = false,\n    val selectedUpdateMode: EventUpdateMode? = null,\n    val eventForDetailedView: EventDto? = null,\n    val showEventDetailedView: Boolean = false,\n)\n\nsealed class EventManagementUiEvent {\n    data class ShowMessage(val message: UiText) : EventManagementUiEvent()\n    object OperationSuccess : EventManagementUiEvent()\n}",
      "info": {
        "size": 32673,
        "last_modified": "2025-08-06T10:04:47.849733",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    }
  ]
}