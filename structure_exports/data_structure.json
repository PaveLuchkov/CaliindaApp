{
  "structure": {
    "calendar": {
      "CreateEventResult.kt": {
        "type": "file",
        "info": {
          "size": 252,
          "last_modified": "2025-08-02T11:19:26.826234",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "CalendarDataManager.kt": {
        "type": "file",
        "info": {
          "size": 47723,
          "last_modified": "2025-08-02T11:19:26.840763",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "EventNetworkState.kt": {
        "type": "file",
        "info": {
          "size": 214,
          "last_modified": "2025-08-02T11:19:26.849077",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "DeleteEventResult.kt": {
        "type": "file",
        "info": {
          "size": 252,
          "last_modified": "2025-08-02T11:19:26.855582",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "EditEventResult.kt": {
        "type": "file",
        "info": {
          "size": 362,
          "last_modified": "2025-08-02T11:19:26.861617",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    },
    "mapper": {
      "EventMapper.kt": {
        "type": "file",
        "info": {
          "size": 2978,
          "last_modified": "2025-08-02T11:19:26.867478",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    },
    "local": {
      "CalendarEventEntity.kt": {
        "type": "file",
        "info": {
          "size": 1167,
          "last_modified": "2025-08-02T11:19:26.873248",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    }
  },
  "files": [
    {
      "path": "calendar/CreateEventResult.kt",
      "content": "package com.lpavs.caliinda.data.calendar\n\nsealed interface CreateEventResult {\n  object Idle : CreateEventResult\n\n  object Loading : CreateEventResult\n\n  object Success : CreateEventResult\n\n  data class Error(val message: String) : CreateEventResult\n}\n",
      "info": {
        "size": 252,
        "last_modified": "2025-08-02T11:19:26.826234",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "calendar/CalendarDataManager.kt",
      "content": "package com.lpavs.caliinda.data.calendar\n\nimport android.content.Context\nimport android.util.Log\nimport com.google.gson.Gson\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.auth.AuthManager\nimport com.lpavs.caliinda.data.local.CalendarEventEntity\nimport com.lpavs.caliinda.core.data.local.EventDao\nimport com.lpavs.caliinda.data.local.UpdateEventApiRequest\nimport com.lpavs.caliinda.data.mapper.EventMapper\nimport com.lpavs.caliinda.core.data.repository.SettingsRepository\nimport com.lpavs.caliinda.core.data.di.BackendUrl\nimport com.lpavs.caliinda.app.di.IoDispatcher\nimport com.lpavs.caliinda.feature.calendar.data.model.CalendarEvent\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.NonCancellable\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.flow.flatMapLatest\nimport kotlinx.coroutines.flow.flowOn\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.sync.Mutex\nimport kotlinx.coroutines.sync.withLock\nimport kotlinx.coroutines.withContext\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.Request\nimport okhttp3.RequestBody.Companion.toRequestBody\nimport org.json.JSONArray\nimport org.json.JSONException\nimport org.json.JSONObject\nimport java.io.IOException\nimport java.time.LocalDate\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.format.DateTimeFormatter\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Inject\nimport javax.inject.Singleton\nimport kotlin.coroutines.cancellation.CancellationException\nimport kotlin.coroutines.coroutineContext\n\nenum class ApiDeleteEventMode(val value: String) {\n  DEFAULT(\"default\"),\n    INSTANCE_ONLY(\"instance_only\")\n}\n\nenum class ClientEventUpdateMode(val value: String) {\n  SINGLE_INSTANCE(\"single_instance\"),\n  ALL_IN_SERIES(\"all_in_series\")\n}\n\n@Singleton\nclass CalendarDataManager\n@Inject\nconstructor(\n    @ApplicationContext private val context: Context,\n    private val okHttpClient: OkHttpClient,\n    private val eventDao: EventDao,\n    private val authManager: AuthManager,\n    @BackendUrl private val backendBaseUrl: String,\n    private val settingsRepository: SettingsRepository,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n  private val TAG = \"CalendarDataManager\"\n  private val managerScope = CoroutineScope(SupervisorJob() + ioDispatcher)\n\n    companion object {\n    const val INITIAL_LOAD_DAYS_AROUND = 7L\n    const val UPDATE_LOAD_DAYS_AROUND = 5L\n    const val TRIGGER_PREFETCH_THRESHOLD = 2L\n    const val EXPAND_CHUNK_DAYS = 14L\n    const val JUMP_DETECTION_BUFFER_DAYS = 10L\n  }\n\n\n  private val _currentVisibleDate = MutableStateFlow(LocalDate.now())\n  private val _loadedDateRange = MutableStateFlow<ClosedRange<LocalDate>?>(null)\n  private val _rangeNetworkState = MutableStateFlow<EventNetworkState>(EventNetworkState.Idle)\n  private val _createEventResult = MutableStateFlow<CreateEventResult>(CreateEventResult.Idle)\n  private val _deleteEventResult = MutableStateFlow<DeleteEventResult>(DeleteEventResult.Idle)\n  private val _updateEventResult = MutableStateFlow<UpdateEventResult>(UpdateEventResult.Idle)\n    private var fetchJobHolder: JobHolder? = null\n    private val fetchJobMutex = Mutex()\n    private data class JobHolder(val job: Job, val requestedRange: ClosedRange<LocalDate>)\n\n  val currentVisibleDate: StateFlow<LocalDate> = _currentVisibleDate.asStateFlow()\n  val rangeNetworkState: StateFlow<EventNetworkState> = _rangeNetworkState.asStateFlow()\n  val createEventResult: StateFlow<CreateEventResult> = _createEventResult.asStateFlow()\n  val updateEventResult: StateFlow<UpdateEventResult> = _updateEventResult.asStateFlow()\n  val deleteEventResult: StateFlow<DeleteEventResult> = _deleteEventResult.asStateFlow()\n\n  private var activeFetchJob: Job? = null\n\n    /** Устанавливает текущую видимую дату и запускает проверку/загрузку диапазона */\n  fun setCurrentVisibleDate(newDate: LocalDate, forceRefresh: Boolean = false) {\n    Log.d(\n        TAG,\n        \"setCurrentVisibleDate: CALLED with $newDate. Current value: ${_currentVisibleDate.value}\")\n\n        val needsDateUpdate = newDate != _currentVisibleDate.value\n\n    if (!needsDateUpdate && !forceRefresh && _loadedDateRange.value != null) {\n      Log.d(\n          TAG,\n          \"setCurrentVisibleDate: Date $newDate is same, no forceRefresh, range loaded. Skipping.\")\n      return\n    }\n\n    Log.i(TAG, \"setCurrentVisibleDate: Proceeding to set date and check range for $newDate\")\n\n        activeFetchJob?.cancel(\n        CancellationException(\"New date set: $newDate, forceRefresh=$forceRefresh\"))\n    Log.d(TAG, \"setCurrentVisibleDate: Previous activeFetchJob cancelled (if existed).\")\n\n        if (needsDateUpdate) {\n      _currentVisibleDate.value = newDate\n    }\n\n        if (authManager.authState.value.isSignedIn) {\n            activeFetchJob =\n          managerScope.launch {\n            Log.d(\n                TAG,\n                \"setCurrentVisibleDate: New coroutine launched for ensureDateRangeLoadedAround($newDate, forceRefresh=$forceRefresh). Job: ${coroutineContext[Job]}\")\n            try {\n              ensureDateRangeLoadedAround(newDate, forceRefresh)\n            } catch (ce: CancellationException) {\n              Log.d(\n                  TAG,\n                  \"setCurrentVisibleDate: Job ${coroutineContext[Job]} cancelled while ensuring range for $newDate: ${ce.message}\")\n              throw ce\n            } catch (e: Exception) {\n              Log.e(\n                  TAG,\n                  \"setCurrentVisibleDate: Error in ensureDateRangeLoadedAround for $newDate\",\n                  e)\n            } finally {\n              Log.d(\n                  TAG, \"setCurrentVisibleDate: Job ${coroutineContext[Job]} finished for $newDate\")\n            }\n          }\n      Log.d(TAG, \"setCurrentVisibleDate: Assigned new activeFetchJob: $activeFetchJob\")\n    } else {\n            Log.w(\n          TAG,\n          \"setCurrentVisibleDate: Skipping range load for $newDate because user is not signed in.\")\n            activeFetchJob = null\n        }\n  }\n\n    /** Предоставляет Flow событий из БД для указанной даты (эффективная версия) */\n    @OptIn(ExperimentalCoroutinesApi::class)\n    fun getEventsFlowForDate(date: LocalDate): Flow<List<CalendarEvent>> {\n        return settingsRepository.timeZoneFlow\n            .flatMapLatest { timeZoneIdString ->\n                val zoneId = parseTimeZone(timeZoneIdString)\n                val (startMillis, endMillis) = calculateLocalBounds(date, zoneId)\n\n                eventDao.getEventsForDateRangeFlow(startMillis, endMillis)\n                    .map { entityList ->\n                        entityList\n                            .filter { entity -> isEventValidForDate(entity, startMillis, endMillis) }\n                            .map { entity -> EventMapper.mapToDomain(entity, zoneId.toString()) }\n                    }\n            }\n            .catch { e ->\n                Log.e(TAG, \"Error processing events Flow for date $date\", e)\n                emit(emptyList())\n            }\n            .flowOn(ioDispatcher)\n    }\n\n    /** Безопасный парсинг часового пояса */\n    private fun parseTimeZone(timeZoneIdString: String): ZoneId {\n        return try {\n            ZoneId.of(timeZoneIdString.ifEmpty { ZoneId.systemDefault().id })\n        } catch (e: Exception) {\n            Log.w(TAG, \"Invalid timezone: $timeZoneIdString, using system default\", e)\n            ZoneId.systemDefault()\n        }\n    }\n\n    /** Вычисляет границы дня в локальном часовом поясе */\n    private fun calculateLocalBounds(date: LocalDate, zoneId: ZoneId): Pair<Long, Long> {\n        val startOfDay = date.atStartOfDay(zoneId)\n        val endOfDay = startOfDay.plusDays(1)\n\n        return Pair(\n            startOfDay.toInstant().toEpochMilli(),\n            endOfDay.toInstant().toEpochMilli()\n        )\n    }\n\n    /** Проверяет, валидно ли событие для указанной даты */\n    private fun isEventValidForDate(\n        entity: CalendarEventEntity,\n        startMillis: Long,\n        endMillis: Long\n    ): Boolean {\n        return if (!entity.isAllDay) {\n            // Обычное событие: должно пересекаться с границами дня\n            entity.startTimeMillis < endMillis && entity.endTimeMillis > startMillis\n        } else {\n            // Событие \"весь день\": проверяем продолжительность ~24 часа\n            val durationMillis = entity.endTimeMillis - entity.startTimeMillis\n            val twentyFourHoursMillis = TimeUnit.HOURS.toMillis(24)\n            val toleranceMillis = TimeUnit.MINUTES.toMillis(5)\n\n            (durationMillis >= twentyFourHoursMillis - toleranceMillis) &&\n                    (durationMillis <= twentyFourHoursMillis + toleranceMillis) &&\n                    // И должно пересекаться с нашим днем\n                    (entity.startTimeMillis < endMillis && entity.endTimeMillis > startMillis)\n        }\n    }\n\n  /** Создает новое событие через бэкенд */\n  suspend fun createEvent(\n      summary: String,\n      startTimeString: String,\n      endTimeString: String,\n      isAllDay: Boolean,\n      timeZoneId: String?,\n      description: String?,\n      location: String?,\n      recurrenceRule: String?\n  ) {\n      if (summary.isBlank()) {\n          _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_summary_empty))\n          return\n      }\n      if (startTimeString.isBlank() || endTimeString.isBlank()) {\n          _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_start_end_time_required))\n          return\n      }\n\n      _createEventResult.value = CreateEventResult.Loading\n\n      val freshToken = authManager.getBackendAuthToken()\n      if (freshToken == null) {\n          Log.w(TAG, \"Cannot create event: Failed to get fresh ID token.\")\n          _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_authentication))\n          return\n      }\n\n      val requestBody =\n          try {\n              JSONObject()\n                  .apply {\n                      put(\"summary\", summary)\n                      put(\"startTime\", startTimeString)\n                      put(\"endTime\", endTimeString)\n                      put(\"isAllDay\", isAllDay)\n                      if (!isAllDay && timeZoneId != null) {\n                          put(\"timeZoneId\", timeZoneId)\n                      } else {\n                          Log.w(TAG, \"Sending timed event without timeZoneId to backend!\")\n                      }\n\n                      description?.takeIf { it.isNotBlank() }?.let { put(\"description\", it) }\n                      location?.takeIf { it.isNotBlank() }?.let { put(\"location\", it) }\n\n                      recurrenceRule\n                          ?.takeIf { it.isNotBlank() }\n                          ?.let { ruleString ->\n                              val fullRuleString = \"RRULE:$ruleString\"\n                              val recurrenceArray = JSONArray().apply { put(fullRuleString) }\n                              put(\"recurrence\", recurrenceArray)\n                          }\n                  }\n                  .toString()\n                  .toRequestBody(\"application/json; charset=utf-8\".toMediaType())\n          } catch (e: JSONException) {\n              Log.e(TAG, \"Error creating JSON for new event\", e)\n              _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_data_preparation))\n              return\n          }\n\n      val request =\n          Request.Builder()\n              .url(\"$backendBaseUrl/calendar/events\")\n              .header(\"Authorization\", \"Bearer $freshToken\")\n              .post(requestBody)\n              .build()\n\n      try {\n          val response = withContext(ioDispatcher) { okHttpClient.newCall(request).execute() }\n          if (response.isSuccessful) {\n              Log.i(TAG, \"Event created successfully via backend.\")\n              _createEventResult.value = CreateEventResult.Success\n              refreshDate(_currentVisibleDate.value)\n          } else {\n              val errorMsg = parseBackendError(response.body?.string(), response.code)\n              Log.e(TAG, \"Error creating event via backend: ${response.code} - $errorMsg\")\n              _createEventResult.value = CreateEventResult.Error(errorMsg)\n          }\n      } catch (e: IOException) {\n          Log.e(TAG, \"Network error creating event\", e)\n          _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_network) + \": ${e.message}\")\n      } catch (e: Exception) {\n          Log.e(TAG, \"Error creating event\", e)\n          _createEventResult.value = CreateEventResult.Error(context.getString(R.string.error_unknown) + \": ${e.message}\")\n      } finally {\n          if (_createEventResult.value is CreateEventResult.Loading) {\n              _createEventResult.value = CreateEventResult.Idle\n          }\n      }\n  }\n\n  /** Сбрасывает состояние результата создания события */\n  fun consumeCreateEventResult() {\n    _createEventResult.value = CreateEventResult.Idle\n  }\n\n  /**\n   * Запускает процесс удаления события на бэкенде и в локальной БД. Результат операции будет\n   * доступен через [deleteEventResult] StateFlow.\n   *\n   * @param eventId Уникальный идентификатор события для удаления.\n   * @param mode Режим удаления для повторяющихся событий.\n   */\n    /**\n     * Запускает процесс удаления события на бэкенде и в локальной БД. Результат операции будет\n     * доступен через [deleteEventResult] StateFlow.\n     *\n     * @param eventId Уникальный идентификатор события для удаления.\n     * @param mode Режим удаления для повторяющихся событий.\n     */\n    suspend fun deleteEvent(\n        eventId: String,\n        mode: ApiDeleteEventMode = ApiDeleteEventMode.DEFAULT\n    ) {\n        if (_deleteEventResult.value is DeleteEventResult.Loading) {\n            Log.w(\n                TAG,\n                \"deleteEvent called while another deletion is in progress for ID: $eventId. Ignoring.\")\n            return\n        }\n\n        _deleteEventResult.value = DeleteEventResult.Loading\n        Log.i(TAG, \"Attempting to delete event with ID: $eventId, mode: ${mode.value}\")\n\n        val freshToken = authManager.getBackendAuthToken()\n        if (freshToken == null) {\n            Log.e(TAG, \"Cannot delete event $eventId: Failed to get fresh ID token.\")\n            _deleteEventResult.value = DeleteEventResult.Error(context.getString(R.string.error_authentication))\n            return\n        }\n\n        var url = \"$backendBaseUrl/calendar/events/$eventId\"\n        if (mode != ApiDeleteEventMode.DEFAULT) {\n            url += \"?mode=${mode.value}\"\n        }\n        Log.d(TAG, \"Delete request URL: $url\")\n\n        val request =\n            Request.Builder()\n                .url(url)\n                .delete()\n                .header(\"Authorization\", \"Bearer $freshToken\")\n                .build()\n\n        try {\n            val response = withContext(ioDispatcher) { okHttpClient.newCall(request).execute() }\n\n            if (response.isSuccessful) {\n                Log.i(\n                    TAG,\n                    \"Event $eventId successfully processed for deletion on backend (Mode: ${mode.value}, Code: ${response.code}). Deleting locally.\")\n                try {\n                    withContext(ioDispatcher) { eventDao.deleteEventById(eventId) }\n                    Log.i(TAG, \"Event $eventId (or its reference) successfully deleted from local DB.\")\n                    _deleteEventResult.value = DeleteEventResult.Success\n                    refreshDate(_currentVisibleDate.value)\n                } catch (dbError: Exception) {\n                    Log.e(\n                        TAG,\n                        \"Failed to delete event $eventId from local DB after successful backend deletion.\",\n                        dbError)\n                    _deleteEventResult.value =\n                        DeleteEventResult.Error(\n                            context.getString(R.string.error_sync_local_delete_failed))\n                }\n            } else {\n                val errorMsg = parseBackendError(response.body?.string(), response.code)\n                Log.e(\n                    TAG,\n                    \"Error deleting event $eventId (Mode: ${mode.value}) via backend: ${response.code} - $errorMsg\")\n                _deleteEventResult.value = DeleteEventResult.Error(errorMsg)\n            }\n        } catch (e: IOException) {\n            Log.e(TAG, \"Network error deleting event $eventId (Mode: ${mode.value})\", e)\n            _deleteEventResult.value = DeleteEventResult.Error(context.getString(R.string.error_network) + \": ${e.message}\")\n        } catch (e: Exception) {\n            if (e is CancellationException) {\n                Log.w(TAG, \"Delete event $eventId (Mode: ${mode.value}) job was cancelled.\", e)\n                _deleteEventResult.value = DeleteEventResult.Idle\n                throw e\n            }\n            Log.e(TAG, \"Unexpected error deleting event $eventId (Mode: ${mode.value})\", e)\n            _deleteEventResult.value = DeleteEventResult.Error(context.getString(R.string.error_unknown) + \": ${e.message}\")\n        }\n    }\n\n  /**\n   * Сбрасывает состояние результата удаления события в Idle. Вызывать после того, как UI обработал\n   * результат (например, показал Snackbar).\n   */\n  fun consumeDeleteEventResult() {\n    _deleteEventResult.value = DeleteEventResult.Idle\n  }\n\n    suspend fun updateEvent(\n        eventId: String,\n        updateData: UpdateEventApiRequest,\n        mode: ClientEventUpdateMode\n    ) {\n        if (_updateEventResult.value is UpdateEventResult.Loading) {\n            Log.w(\n                TAG, \"updateEvent called while another update is in progress for ID: $eventId. Ignoring.\")\n            return\n        }\n        _updateEventResult.value = UpdateEventResult.Loading\n        Log.i(TAG, \"Attempting to update event ID: $eventId, mode: ${mode.value}, data: $updateData\")\n\n        val freshToken = authManager.getBackendAuthToken()\n        if (freshToken == null) {\n            Log.e(TAG, \"Cannot update event $eventId: Failed to get fresh ID token.\")\n            _updateEventResult.value = UpdateEventResult.Error(context.getString(R.string.error_authentication))\n            return\n        }\n\n        val url = \"$backendBaseUrl/calendar/events/$eventId?update_mode=${mode.value}\"\n        val requestBodyJson =\n            try {\n                Gson().toJson(updateData)\n            } catch (e: Exception) {\n                Log.e(TAG, \"Error serializing updateData to JSON for event $eventId\", e)\n                _updateEventResult.value =\n                    UpdateEventResult.Error(context.getString(R.string.error_update_data_preparation))\n                return\n            }\n\n        val request =\n            Request.Builder()\n                .url(url)\n                .patch(\n                    requestBodyJson.toRequestBody(\n                        \"application/json; charset=utf-8\".toMediaType()))\n                .header(\"Authorization\", \"Bearer $freshToken\")\n                .build()\n\n        try {\n            val response = withContext(ioDispatcher) { okHttpClient.newCall(request).execute() }\n\n            if (response.isSuccessful) {\n                val responseBody = response.body?.string()\n                if (responseBody != null) {\n                    try {\n                        val responseObject = JSONObject(responseBody)\n                        val newEventId = responseObject.optString(\"eventId\", eventId)\n                        Log.i(\n                            TAG,\n                            \"Event $eventId successfully updated on backend (Mode: ${mode.value}). New/Confirmed ID: $newEventId\")\n\n                        _updateEventResult.value = UpdateEventResult.Success(newEventId)\n                        refreshDate(currentVisibleDate.value)\n                    } catch (e: JSONException) {\n                        Log.e(TAG, \"Error parsing successful update response for event $eventId\", e)\n                        _updateEventResult.value =\n                            UpdateEventResult.Error(context.getString(R.string.error_update_server_response))\n                    }\n                } else {\n                    Log.e(TAG, \"Successful update response for event $eventId has empty body.\")\n                    _updateEventResult.value =\n                        UpdateEventResult.Error(context.getString(R.string.error_update_empty_response))\n                }\n            } else {\n                val errorMsg = parseBackendError(response.body?.string(), response.code)\n                Log.e(\n                    TAG,\n                    \"Error updating event $eventId (Mode: ${mode.value}) via backend: ${response.code} - $errorMsg\")\n                _updateEventResult.value = UpdateEventResult.Error(errorMsg)\n            }\n        } catch (e: IOException) {\n            Log.e(TAG, \"Network error updating event $eventId (Mode: ${mode.value})\", e)\n            _updateEventResult.value = UpdateEventResult.Error(context.getString(R.string.error_network) + \": ${e.message}\")\n        } catch (e: Exception) {\n            if (e is CancellationException) {\n                Log.w(TAG, \"Update event $eventId (Mode: ${mode.value}) job was cancelled.\", e)\n                _updateEventResult.value = UpdateEventResult.Idle\n                throw e\n            }\n            Log.e(TAG, \"Unexpected error updating event $eventId (Mode: ${mode.value})\", e)\n            _updateEventResult.value = UpdateEventResult.Error(context.getString(R.string.error_unknown) + \": ${e.message}\")\n        }\n    }\n\n  fun consumeUpdateEventResult() {\n    _updateEventResult.value = UpdateEventResult.Idle\n  }\n\n  /** Принудительно обновляет данные для указанной даты */\n  suspend fun refreshDate(centerDateToRefreshAround: LocalDate) {\n      Log.d(TAG, \"Manual refresh triggered around date: $centerDateToRefreshAround\")\n\n      activeFetchJob?.cancel(CancellationException(\"Manual refresh triggered for $centerDateToRefreshAround\"))\n      Log.d(TAG, \"refreshDate: Previous activeFetchJob (ensure...) cancelled (if existed).\")\n\n      val targetRefreshRangeStart = centerDateToRefreshAround.minusDays(UPDATE_LOAD_DAYS_AROUND)\n      val targetRefreshRangeEnd = centerDateToRefreshAround.plusDays(UPDATE_LOAD_DAYS_AROUND)\n      val targetRefreshRange = targetRefreshRangeStart..targetRefreshRangeEnd\n      Log.d(TAG, \"refreshDate: Target refresh range is $targetRefreshRange\")\n\n      fetchJobMutex.withLock {\n          fetchJobHolder?.job?.cancel(CancellationException(\"Force refresh for $centerDateToRefreshAround\"))\n          fetchJobHolder = null\n          Log.d(TAG, \"refreshDate: Cancelled existing fetchJobHolder due to force refresh.\")\n      }\n\n      launchProtectedFetch(targetRefreshRange, true)\n\n  }\n\n  /** Сбрасывает состояние ошибки сети */\n  fun clearNetworkError() {\n    if (_rangeNetworkState.value is EventNetworkState.Error) {\n      _rangeNetworkState.value = EventNetworkState.Idle\n    }\n  }\n\n    /** Проверяет, нужно ли загружать/расширять диапазон дат */\n  private suspend fun ensureDateRangeLoadedAround(centerDate: LocalDate, forceLoad: Boolean) =\n      withContext(ioDispatcher) {\n          val currentlyLoaded = _loadedDateRange.value\n          val initialOrJumpTargetRange =\n              centerDate.minusDays(INITIAL_LOAD_DAYS_AROUND)..centerDate.plusDays(INITIAL_LOAD_DAYS_AROUND)\n          Log.d(TAG, \"ensureDateRange: center=$centerDate, current=$currentlyLoaded, initialOrJumpTarget=$initialOrJumpTargetRange, forceLoad=$forceLoad\")\n\n          if (forceLoad) {\n              Log.i(TAG, \"Force load requested for $centerDate. Fetching range: $initialOrJumpTargetRange\")\n              fetchJobMutex.withLock {\n                  fetchJobHolder?.job?.cancel(CancellationException(\"Force load for $centerDate\"))\n                  fetchJobHolder = null\n                  Log.d(TAG, \"ensureDateRangeLoadedAround: Cancelled existing fetchJobHolder due to forceLoad.\")\n              }\n              launchProtectedFetch(initialOrJumpTargetRange, true)\n              return@withContext\n          }\n\n          if (currentlyLoaded == null) {\n              Log.i(TAG, \"Initial load for $centerDate. Fetching range: $initialOrJumpTargetRange\")\n              launchProtectedFetch(initialOrJumpTargetRange, true)\n          } else {\n              val isJump =\n                  centerDate < currentlyLoaded.start.minusDays(JUMP_DETECTION_BUFFER_DAYS) ||\n                          centerDate > currentlyLoaded.endInclusive.plusDays(JUMP_DETECTION_BUFFER_DAYS)\n\n              if (isJump) {\n                  Log.i(TAG, \"Jump detected for $centerDate. Fetching new range: $initialOrJumpTargetRange\")\n                  fetchJobMutex.withLock {\n                      fetchJobHolder?.job?.cancel(CancellationException(\"Jump detected for $centerDate\"))\n                      fetchJobHolder = null\n                      Log.d(TAG, \"ensureDateRangeLoadedAround: Cancelled existing fetchJobHolder due to jump.\")\n                  }\n                  launchProtectedFetch(initialOrJumpTargetRange, true)\n              } else {\n                  var rangeToFetchDeltaStart: LocalDate? = null\n                  var rangeToFetchDeltaEnd: LocalDate? = null\n\n                  if (centerDate >= currentlyLoaded.endInclusive.minusDays(TRIGGER_PREFETCH_THRESHOLD)) {\n                      rangeToFetchDeltaStart = currentlyLoaded.endInclusive.plusDays(1)\n                      rangeToFetchDeltaEnd = rangeToFetchDeltaStart.plusDays(EXPAND_CHUNK_DAYS - 1)\n                      Log.i(TAG, \"Forward prefetch triggered at $centerDate. Need to fetch DELTA: [$rangeToFetchDeltaStart .. $rangeToFetchDeltaEnd]\")\n                  } else if (centerDate <= currentlyLoaded.start.plusDays(TRIGGER_PREFETCH_THRESHOLD)) {\n                      rangeToFetchDeltaEnd = currentlyLoaded.start.minusDays(1)\n                      rangeToFetchDeltaStart = rangeToFetchDeltaEnd.minusDays(EXPAND_CHUNK_DAYS - 1)\n                      Log.i(TAG, \"Backward prefetch triggered at $centerDate. Need to fetch DELTA: [$rangeToFetchDeltaStart .. $rangeToFetchDeltaEnd]\")\n                  }\n\n                  if (rangeToFetchDeltaStart != null && rangeToFetchDeltaEnd != null) {\n                      launchProtectedFetch(rangeToFetchDeltaStart..rangeToFetchDeltaEnd, false)\n                  } else {\n                      Log.d(TAG, \"No delta load needed for $centerDate. It is comfortably within $currentlyLoaded.\")\n                  }\n              }\n          }\n      }\n    /**\n     * Загружает данные для диапазона дат с бэкенда и сохраняет в БД.\n     *\n     * @param startDate Начало диапазона для запроса к бэкенду (может быть дельта).\n     * @param endDate Конец диапазона для запроса к бэкенду (может быть дельта).\n     * @param replaceWholeLoadedRangeWithThis true - если _loadedDateRange должен быть полностью\n     *   заменен на [startDate].[endDate]. false - если [startDate].[endDate] это дельта и ее нужно\n     *   объединить с текущим _loadedDateRange.\n     */\n    private suspend fun fetchAndStoreDateRange(\n        startDate: LocalDate,\n        endDate: LocalDate,\n        replaceWholeLoadedRangeWithThis: Boolean\n    ) {\n\n        var freshToken: String? = null\n        var attempts = 0\n        val maxAttempts = 3\n        val retryDelay = 500L\n\n        Log.d(\n            TAG,\n            \"FADR: Attempting to get token for $startDate to $endDate. Current job: ${coroutineContext[Job]}\")\n        while (freshToken == null && attempts < maxAttempts) {\n            attempts++\n            try {\n                freshToken = authManager.getBackendAuthToken()\n                if (freshToken == null && attempts < maxAttempts) {\n                    Log.w(\n                        TAG,\n                        \"FADR: Failed to get token (attempt $attempts/$maxAttempts) for $startDate to $endDate. Retrying in ${retryDelay}ms...\")\n                    delay(retryDelay)\n                }\n            } catch (e: CancellationException) {\n                Log.i(\n                    TAG,\n                    \"FADR: Token acquisition explicitly CANCELLED for $startDate to $endDate. Job: ${coroutineContext[Job]}\")\n                throw e\n            }\n        }\n\n        if (freshToken == null) {\n            Log.w(\n                TAG,\n                \"FADR: Cannot fetch range $startDate-$endDate. Failed to get fresh ID token after $maxAttempts attempts.\")\n            _rangeNetworkState.value = EventNetworkState.Error(context.getString(R.string.error_authentication))\n            return\n        }\n        Log.d(TAG, \"FADR: Token acquired for $startDate to $endDate.\")\n\n        _rangeNetworkState.value = EventNetworkState.Loading\n        Log.i(\n            TAG,\n            \"FADR: Set state to Loading for $startDate to $endDate. About to enter NonCancellable. Job: ${coroutineContext[Job]}\")\n\n        try {\n            withContext(NonCancellable) {\n                Log.i(\n                    TAG,\n                    \"[NC] ENTER NonCancellable block for $startDate to $endDate. Current Job: ${coroutineContext[Job]}\")\n\n                val url =\n                    \"$backendBaseUrl/calendar/events/range\" +\n                            \"?startDate=${startDate.format(DateTimeFormatter.ISO_LOCAL_DATE)}\" +\n                            \"&endDate=${endDate.format(DateTimeFormatter.ISO_LOCAL_DATE)}\"\n\n                val request =\n                    Request.Builder().url(url).get().header(\"Authorization\", \"Bearer $freshToken\").build()\n\n                try {\n                    val responseBodyString =\n                        okHttpClient.newCall(request).execute().use { response ->\n                            if (!response.isSuccessful) {\n                                val errorMsg = parseBackendError(response.body?.string(), response.code)\n                                Log.e(\n                                    TAG,\n                                    \"[NC] Error fetching range from backend for $startDate to $endDate: ${response.code} - $errorMsg\")\n                                _rangeNetworkState.value =\n                                    EventNetworkState.Error(context.getString(R.string.error_server) + \": $errorMsg (${response.code})\")\n                                return@withContext\n                            }\n                            response.body?.string()\n                        }\n\n                    if (_rangeNetworkState.value is EventNetworkState.Error) {\n                        Log.w(\n                            TAG,\n                            \"[NC] Skipping further processing for $startDate to $endDate due to earlier error in NC block.\")\n                        return@withContext\n                    }\n\n                    if (responseBodyString.isNullOrBlank()) {\n                        Log.w(TAG, \"[NC] Empty response body for range $startDate to $endDate.\")\n                        saveEventsToDb(emptyList(), startDate, endDate)\n                        updateLoadedRange(startDate..endDate, replaceWholeLoadedRangeWithThis)\n                        _rangeNetworkState.value = EventNetworkState.Idle\n                        Log.i(TAG, \"[NC] Successfully processed EMPTY response for $startDate to $endDate.\")\n                    } else {\n                        Log.i(\n                            TAG,\n                            \"[NC] Range received from network for $startDate to $endDate. Size: ${responseBodyString.length}\")\n                        val networkEvents = parseEventsResponse(responseBodyString)\n                        saveEventsToDb(networkEvents, startDate, endDate)\n                        updateLoadedRange(startDate..endDate, replaceWholeLoadedRangeWithThis)\n                        _rangeNetworkState.value = EventNetworkState.Idle\n                        Log.i(TAG, \"[NC] Successfully processed NON-EMPTY response for $startDate to $endDate.\")\n                    }\n                } catch (e: IOException) {\n                    Log.e(\n                        TAG, \"[NC] IOException during network call/processing for $startDate to $endDate\", e)\n                    _rangeNetworkState.value = EventNetworkState.Error(context.getString(R.string.error_network) + \" (in NC): ${e.message}\")\n                } catch (e: JSONException) {\n                    Log.e(TAG, \"[NC] JSONException during parsing for $startDate to $endDate\", e)\n                    _rangeNetworkState.value =\n                        EventNetworkState.Error(context.getString(R.string.error_json_parsing) + \" (in NC): ${e.message}\")\n                } catch (e: Exception) {\n                    Log.e(TAG, \"[NC] Unexpected Exception for $startDate to $endDate\", e)\n                    _rangeNetworkState.value =\n                        EventNetworkState.Error(context.getString(R.string.error_unknown) + \" (in NC): ${e.message}\")\n                }\n                Log.i(\n                    TAG,\n                    \"[NC] EXIT NonCancellable block for $startDate to $endDate. Final state: ${_rangeNetworkState.value}\")\n            }\n        } catch (e: CancellationException) {\n            Log.i(\n                TAG,\n                \"FADR: Operation CANCELLED for $startDate to $endDate *before* NonCancellable block (but after setting Loading). Job: ${coroutineContext[Job]}\")\n            throw e\n        } catch (e: Exception) {\n            Log.e(\n                TAG,\n                \"FADR: Generic Exception for $startDate to $endDate (outside NC block, or unhandled before NC). Job: ${coroutineContext[Job]}\",\n                e)\n            _rangeNetworkState.value =\n                EventNetworkState.Error(context.getString(R.string.error_unknown) + \" (outside NC): ${e.message}\")\n        } finally {\n            if (_rangeNetworkState.value is EventNetworkState.Loading) {\n                Log.w(\n                    TAG,\n                    \"FADR FINALLY: State still Loading for $startDate to $endDate. This implies cancellation/error before NC block completed its state update. Resetting to Idle. Job: ${coroutineContext[Job]}\")\n                _rangeNetworkState.value = EventNetworkState.Idle\n            }\n            Log.d(\n                TAG,\n                \"FADR: FINALLY block executed for $startDate to $endDate. Current _rangeNetworkState: ${_rangeNetworkState.value}. Job: ${coroutineContext[Job]}\")\n        }\n    }\n\n  /** Сохраняет события в БД, очищая старые данные для диапазона */\n  private suspend fun saveEventsToDb(\n      networkEvents: List<CalendarEvent>,\n      startDate: LocalDate,\n      endDate: LocalDate\n  ) =\n      withContext(ioDispatcher) {\n        val currentTimeZoneId =\n            try {\n              settingsRepository.timeZoneFlow\n                  .first()\n                  .ifEmpty { ZoneId.systemDefault().id }\n            } catch (e: Exception) {\n              Log.w(TAG, \"Could not get timezone from settings, using system default.\", e)\n              ZoneId.systemDefault().id\n            }\n        val zoneId =\n            try {\n              ZoneId.of(currentTimeZoneId)\n            } catch (e: Exception) {\n              ZoneId.systemDefault()\n            }\n\n        val eventEntities =\n            networkEvents.mapNotNull { EventMapper.mapToEntity(it, zoneId.toString()) }\n\n        val startRangeMillis = startDate.atStartOfDay(ZoneOffset.UTC).toInstant().toEpochMilli()\n        val endRangeMillis =\n            endDate.plusDays(1).atStartOfDay(ZoneOffset.UTC).toInstant().toEpochMilli()\n\n        Log.d(\n            TAG,\n            \"Updating DB for range $startDate to $endDate. Deleting range [$startRangeMillis, $endRangeMillis), Inserting ${eventEntities.size} events.\")\n        eventDao.clearAndInsertEventsForRange(startRangeMillis, endRangeMillis, eventEntities)\n        Log.i(TAG, \"DB updated for range $startDate to $endDate.\")\n      }\n\n  /** Обновляет состояние _loadedDateRange */\n  private fun updateLoadedRange(fetchedRange: ClosedRange<LocalDate>, replace: Boolean) {\n    if (replace) {\n      _loadedDateRange.value = fetchedRange\n      Log.d(TAG, \"Replaced loaded range with: $fetchedRange\")\n    } else {\n      _loadedDateRange.update { current ->\n        val updatedRange = current?.union(fetchedRange) ?: fetchedRange\n        Log.d(\n            TAG,\n            \"Merged fetched range $fetchedRange with current ${current}. New loaded range: $updatedRange\")\n        updatedRange\n      }\n    }\n  }\n\n    /** Парсит JSON-ответ со списком событий */\n    private fun parseEventsResponse(jsonString: String): List<CalendarEvent> {\n        val events = mutableListOf<CalendarEvent>()\n        try {\n            val jsonArray = JSONArray(jsonString)\n            for (i in 0 until jsonArray.length()) {\n                try {\n                    val eventObject = jsonArray.getJSONObject(i)\n                    val isAllDay = eventObject.optBoolean(\"isAllDay\", false)\n                    val startTimeStr = eventObject.optString(\"startTime\")\n                    val endTimeStr = eventObject.optString(\"endTime\")\n                    val id = eventObject.optString(\"id\")\n                    val summary = eventObject.optString(\"summary\", context.getString(R.string.event_no_title))\n                    val description: String? =\n                        if (eventObject.has(\"description\") && !eventObject.isNull(\"description\")) {\n                            eventObject.getString(\"description\")\n                        } else {\n                            null\n                        }\n                    val location: String? =\n                        if (eventObject.has(\"location\") && !eventObject.isNull(\"location\")) {\n                            eventObject.getString(\"location\")\n                        } else {\n                            null\n                        }\n                    val recurringEventId: String?\n                    if (eventObject.has(\"recurringEventId\") && !eventObject.isNull(\"recurringEventId\")) {\n                        val str = eventObject.getString(\"recurringEventId\")\n                        recurringEventId = if (str != \"null\") str.trim().takeIf { it.isNotEmpty() } else null\n                    } else {\n                        recurringEventId = null\n                    }\n                    val originalStartTimeObj: Any? = eventObject.opt(\"originalStartTime\")\n                    val originalStartTime =\n                        if (originalStartTimeObj is String && originalStartTimeObj != \"null\") {\n                            originalStartTimeObj.trim().takeIf { it.isNotEmpty() }\n                        } else {\n                            null\n                        }\n\n                    var finalRRuleForCalendarEvent: String? = null\n                    if (eventObject.has(\"recurrenceRule\") && !eventObject.isNull(\"recurrenceRule\")) {\n                        val rawRecurrenceRuleFromApi = eventObject.getString(\"recurrenceRule\")\n\n                        if (rawRecurrenceRuleFromApi != \"null\" && rawRecurrenceRuleFromApi.isNotBlank()) {\n                            if (rawRecurrenceRuleFromApi.startsWith(\"RRULE:\")) {\n                                finalRRuleForCalendarEvent = rawRecurrenceRuleFromApi.removePrefix(\"RRULE:\")\n                            } else {\n                                finalRRuleForCalendarEvent = rawRecurrenceRuleFromApi\n                                Log.w(\n                                    TAG,\n                                    \"Received recurrenceRule from backend without 'RRULE:' prefix: $rawRecurrenceRuleFromApi for event $id\")\n                            }\n                        }\n                    }\n\n                    if (id.isNullOrEmpty() || startTimeStr.isNullOrEmpty()) {\n                        Log.w(\n                            TAG,\n                            \"Skipping event due to missing id or startTime in JSON object: ${eventObject.optString(\"summary\")}\")\n                        continue\n                    }\n\n                    events.add(\n                        CalendarEvent(\n                            id = id,\n                            summary = summary,\n                            startTime = startTimeStr,\n                            endTime =\n                                endTimeStr.takeIf { !it.isNullOrEmpty() }\n                                    ?: startTimeStr,\n                            description = description,\n                            location = location,\n                            isAllDay = isAllDay,\n                            recurringEventId = recurringEventId,\n                            originalStartTime = originalStartTime,\n                            recurrenceRule = finalRRuleForCalendarEvent))\n                } catch (e: JSONException) {\n                    Log.e(TAG, \"Error parsing individual event object at index $i: ${e.localizedMessage}\")\n                }\n            }\n        } catch (e: JSONException) {\n            Log.e(TAG, \"Failed to parse events JSON array\", e)\n            throw e\n        }\n        return events\n    }\n\n    private fun parseBackendError(responseBody: String?, code: Int): String {\n        return try {\n            val json = JSONObject(responseBody ?: \"{}\")\n            json.optString(\"detail\", context.getString(R.string.error_server_code_format, code))\n        } catch (e: JSONException) {\n            context.getString(R.string.error_server_code_format, code)\n        }\n    }\n\n    private fun launchProtectedFetch(rangeToFetch: ClosedRange<LocalDate>, replaceWholeLoadedRange: Boolean) {\n        managerScope.launch {\n            fetchJobMutex.withLock {\n                val currentActiveJobDetails = fetchJobHolder?.takeIf { it.job.isActive }\n\n                if (currentActiveJobDetails != null) {\n                    val currentlyFetchingRange = currentActiveJobDetails.requestedRange\n\n                    if (rangeToFetch.start >= currentlyFetchingRange.start && rangeToFetch.endInclusive <= currentlyFetchingRange.endInclusive) {\n                        Log.d(TAG, \"launchProtectedFetch: New range $rangeToFetch is covered by ongoing $currentlyFetchingRange. Skipping.\")\n                        return@launch\n                    }\n                    if (_rangeNetworkState.value == EventNetworkState.Loading) {\n                        Log.d(TAG, \"launchProtectedFetch: Network is already Loading (for $currentlyFetchingRange). New request for $rangeToFetch will be deferred. Skipping new launch.\")\n                        return@launch\n                    }\n                    Log.d(TAG, \"launchProtectedFetch: New range $rangeToFetch. Cancelling previous job (if any was active but not in Loading state) for $currentlyFetchingRange.\")\n                    currentActiveJobDetails.job.cancel(CancellationException(\"Superseded by new fetch for $rangeToFetch\"))\n                }\n\n                _rangeNetworkState.value = EventNetworkState.Loading\n                Log.i(TAG, \"launchProtectedFetch: Set _rangeNetworkState to Loading. Starting fetch for $rangeToFetch.\")\n\n                val newActualFetchJob = managerScope.launch {\n                    try {\n                        fetchAndStoreDateRange(rangeToFetch.start, rangeToFetch.endInclusive, replaceWholeLoadedRange)\n                    } catch (e: CancellationException) {\n                        Log.i(TAG, \"launchProtectedFetch/newActualFetchJob: Fetch job for $rangeToFetch was cancelled.\", e)\n                        throw e\n                    } catch (e: Exception) {\n                        Log.e(TAG, \"launchProtectedFetch/newActualFetchJob: Exception in fetch job for $rangeToFetch\", e)\n                        if (_rangeNetworkState.value !is EventNetworkState.Error && _rangeNetworkState.value != EventNetworkState.Idle) {\n                            _rangeNetworkState.value = EventNetworkState.Error(\"FADR Error unhandled: ${e.message}\")\n                        }\n                    } finally {\n                        fetchJobMutex.withLock {\n                            if (fetchJobHolder?.job == coroutineContext[Job]) {\n                                fetchJobHolder = null\n                                Log.d(TAG, \"launchProtectedFetch (finally of newActualFetchJob): Cleared fetchJobHolder for $rangeToFetch.\")\n                            }\n                        }\n                        if (_rangeNetworkState.value == EventNetworkState.Loading && !coroutineContext.isActive) {\n                            Log.w(TAG, \"launchProtectedFetch (finally of newActualFetchJob): Job for $rangeToFetch ended, but state is still Loading. Resetting to Idle.\")\n                            _rangeNetworkState.value = EventNetworkState.Idle\n                        }\n                    }\n                }\n                fetchJobHolder = JobHolder(newActualFetchJob, rangeToFetch)\n            }\n        }\n    }\n\n    /**\n     * Очищает все локальные данные о событиях в БД.\n     * Вызывается при выходе пользователя из системы.\n     */\n    suspend fun clearLocalDataOnSignOut() {\n        Log.i(TAG, \"Starting local database clear on sign out...\")\n        try {\n            withContext(ioDispatcher) {\n                eventDao.deleteAllEvents()\n                Log.i(TAG, \"Local database cleared successfully.\")\n            }\n            _loadedDateRange.value = null\n            Log.d(TAG, \"Reset _loadedDateRange state.\")\n\n        } catch (e: Exception) {\n            Log.e(TAG, \"Failed to clear local database on sign out\", e)\n        }\n    }\n\n    private fun ClosedRange<LocalDate>.union(other: ClosedRange<LocalDate>): ClosedRange<LocalDate> {\n    val newStart = minOf(this.start, other.start)\n    val newEnd = maxOf(this.endInclusive, other.endInclusive)\n    return newStart..newEnd\n  }\n\n  private fun minOf(a: LocalDate, b: LocalDate): LocalDate = if (a.isBefore(b)) a else b\n\n  private fun maxOf(a: LocalDate, b: LocalDate): LocalDate = if (a.isAfter(b)) a else b\n}\n",
      "info": {
        "size": 47723,
        "last_modified": "2025-08-02T11:19:26.840763",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "calendar/EventNetworkState.kt",
      "content": "package com.lpavs.caliinda.data.calendar\n\nsealed interface EventNetworkState {\n  object Idle : EventNetworkState\n\n  object Loading : EventNetworkState\n\n  data class Error(val message: String) : EventNetworkState\n}\n",
      "info": {
        "size": 214,
        "last_modified": "2025-08-02T11:19:26.849077",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "calendar/DeleteEventResult.kt",
      "content": "package com.lpavs.caliinda.data.calendar\n\nsealed interface DeleteEventResult {\n  object Idle : DeleteEventResult\n\n  object Loading : DeleteEventResult\n\n  object Success : DeleteEventResult\n\n  data class Error(val message: String) : DeleteEventResult\n}\n",
      "info": {
        "size": 252,
        "last_modified": "2025-08-02T11:19:26.855582",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "calendar/EditEventResult.kt",
      "content": "package com.lpavs.caliinda.data.calendar\n\nsealed interface UpdateEventResult {\n  object Idle : UpdateEventResult\n\n  object Loading : UpdateEventResult\n\n  data class Success(val updatedEventId: String) :\n      UpdateEventResult // Возвращаем ID, т.к. он может измениться\n\n  data class Error(val message: String) : UpdateEventResult\n}\n",
      "info": {
        "size": 362,
        "last_modified": "2025-08-02T11:19:26.861617",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "mapper/EventMapper.kt",
      "content": "package com.lpavs.caliinda.data.mapper\n\nimport android.util.Log\nimport com.lpavs.caliinda.data.local.CalendarEventEntity\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils\nimport com.lpavs.caliinda.feature.calendar.data.model.CalendarEvent // Твоя модель для UI/сети\nimport java.time.Instant\nimport java.time.temporal.ChronoUnit\n\nobject EventMapper {\n\n  private const val TAG = \"EventMapper\"\n\n  // Принимает ID часового пояса как параметр\n  fun mapToEntity(event: CalendarEvent, zoneIdString: String): CalendarEventEntity? {\n    try {\n      val isAllDayEvent = event.isAllDay\n      val startTimeInstant: Instant? = DateTimeUtils.parseToInstant(event.startTime, zoneIdString)\n\n      if (startTimeInstant == null) {\n        Log.w(\n            TAG,\n            \"Failed to parse start time for event '${event.summary}' ('${event.startTime}'), skipping.\")\n        return null\n      }\n      val startTimeMillis = startTimeInstant.toEpochMilli()\n\n      val endTimeInstant: Instant? = DateTimeUtils.parseToInstant(event.endTime, zoneIdString)\n\n      val endTimeMillis: Long =\n          when {\n            endTimeInstant != null && endTimeInstant.toEpochMilli() > startTimeMillis -> {\n              endTimeInstant.toEpochMilli()\n            }\n            isAllDayEvent -> {\n              startTimeInstant.plus(1, ChronoUnit.DAYS).toEpochMilli()\n            }\n            else -> {\n              Log.w(\n                  TAG,\n                  \"Event '${event.summary}' (not all-day or no end time) using start time as end time.\")\n              startTimeMillis\n            }\n          }\n\n      return CalendarEventEntity(\n          id = event.id,\n          summary = event.summary,\n          startTimeMillis = startTimeMillis,\n          endTimeMillis = endTimeMillis,\n          description = event.description,\n          location = event.location,\n          isAllDay = isAllDayEvent,\n          recurringEventId = event.recurringEventId, // Из event (domain)\n          originalStartTimeString = event.originalStartTime,\n          recurrenceRuleString = event.recurrenceRule)\n    } catch (e: Exception) {\n      Log.e(TAG, \"Error mapping CalendarEvent to Entity: ${event.id}\", e)\n      return null\n    }\n  }\n\n\n  fun mapToDomain(entity: CalendarEventEntity, zoneIdString: String): CalendarEvent {\n    val startTimeStr = DateTimeUtils.formatMillisToIsoString(entity.startTimeMillis, zoneIdString)\n    val endTimeStr = DateTimeUtils.formatMillisToIsoString(entity.endTimeMillis, zoneIdString)\n\n    return CalendarEvent(\n        id = entity.id,\n        summary = entity.summary,\n        startTime = startTimeStr ?: \"\",\n        endTime = endTimeStr ?: \"\",\n        description = entity.description,\n        location = entity.location,\n        isAllDay = entity.isAllDay,\n        recurringEventId = entity.recurringEventId,\n        originalStartTime = entity.originalStartTimeString,\n        recurrenceRule = entity.recurrenceRuleString)\n  }\n}\n",
      "info": {
        "size": 2978,
        "last_modified": "2025-08-02T11:19:26.867478",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "local/CalendarEventEntity.kt",
      "content": "package com.lpavs.caliinda.data.local\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"calendar_events\")\ndata class CalendarEventEntity(\n    @PrimaryKey val id: String, // Google Calendar Event ID (естественный ключ)\n    val summary: String,\n    val startTimeMillis: Long, // Время начала в миллисекундах UTC\n    val endTimeMillis: Long, // Время конца в миллисекундах UTC\n    val description: String?,\n    val location: String?,\n    val isAllDay: Boolean = false,\n    val recurringEventId: String? = null, // Новое поле\n    val originalStartTimeString: String? = null, // Новое поле (храним как строку)\n    val lastFetchedMillis: Long = System.currentTimeMillis(),\n    val recurrenceRuleString: String? = null,\n)\n\ndata class UpdateEventApiRequest(\n    val summary: String? = null,\n    val startTime: String? = null,\n    val endTime: String? = null,\n    val isAllDay: Boolean? = null,\n    val timeZoneId: String? = null,\n    val description: String? = null,\n    val location: String? = null,\n    val recurrence: List<String>? = null\n)\n",
      "info": {
        "size": 1167,
        "last_modified": "2025-08-02T11:19:26.873248",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    }
  ]
}