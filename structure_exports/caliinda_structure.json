{
  "project_info": {
    "name": "caliinda",
    "path": "/Users/paveluckov/StudioProjects/CaliindaApp/app/src/main/java/com/lpavs/caliinda",
    "generated_at": "2025-08-06T08:35:04.246211",
    "total_files": 71,
    "total_size": 421880
  },
  "structure": {
    "core": {
      "ui": {
        "util": {
          "DateTimeUtils.kt": {
            "type": "file",
            "info": {
              "size": 4112,
              "last_modified": "2025-08-06T08:35:03.996703",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "BackgroundShapes.kt": {
            "type": "file",
            "info": {
              "size": 5946,
              "last_modified": "2025-08-06T08:35:04.016721",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "DateTimeFormatterUtil.kt": {
            "type": "file",
            "info": {
              "size": 8880,
              "last_modified": "2025-08-06T08:35:04.025802",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "components": {
        },
        "theme": {
          "ValDefaults.kt": {
            "type": "file",
            "info": {
              "size": 1992,
              "last_modified": "2025-08-06T08:35:04.034461",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "Color.kt": {
            "type": "file",
            "info": {
              "size": 41,
              "last_modified": "2025-08-06T08:35:04.040451",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "Theme.kt": {
            "type": "file",
            "info": {
              "size": 2856,
              "last_modified": "2025-08-06T08:35:04.048866",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "Type.kt": {
            "type": "file",
            "info": {
              "size": 1069,
              "last_modified": "2025-08-06T08:35:04.056294",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        }
      },
      "common": {
        "Exceptions.kt": {
          "type": "file",
          "info": {
            "size": 278,
            "last_modified": "2025-08-06T08:35:04.062478",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        },
        "EventNetworkState.kt": {
          "type": "file",
          "info": {
            "size": 212,
            "last_modified": "2025-08-06T08:35:04.065096",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      },
      "data": {
        "repository": {
          "mapper": {
            "EventMapper.kt": {
              "type": "file",
              "info": {
                "size": 3015,
                "last_modified": "2025-08-06T08:35:04.068219",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "SuggestionsRepository.kt": {
            "type": "file",
            "info": {
              "size": 1376,
              "last_modified": "2025-08-06T08:35:04.071223",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "CalendarRepository.kt": {
            "type": "file",
            "info": {
              "size": 18417,
              "last_modified": "2025-08-06T08:35:04.073174",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "SettingsRepository.kt": {
            "type": "file",
            "info": {
              "size": 2380,
              "last_modified": "2025-08-06T08:35:04.075012",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "CalendarEventEntity.kt": {
            "type": "file",
            "info": {
              "size": 591,
              "last_modified": "2025-08-06T08:35:04.076909",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "di": {
          "DataStore.kt": {
            "type": "file",
            "info": {
              "size": 969,
              "last_modified": "2025-08-06T08:35:04.079911",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "NetworkModule.kt": {
            "type": "file",
            "info": {
              "size": 2719,
              "last_modified": "2025-08-06T08:35:04.081662",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "StorageModule.kt": {
            "type": "file",
            "info": {
              "size": 982,
              "last_modified": "2025-08-06T08:35:04.083542",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "TimeTicker.kt": {
            "type": "file",
            "info": {
              "size": 1317,
              "last_modified": "2025-08-06T08:35:04.086685",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "auth": {
          "AuthManager.kt": {
            "type": "file",
            "info": {
              "size": 17332,
              "last_modified": "2025-08-06T08:35:04.090435",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "AuthState.kt": {
            "type": "file",
            "info": {
              "size": 386,
              "last_modified": "2025-08-06T08:35:04.093918",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "utils": {
          "Resources.kt": {
            "type": "file",
            "info": {
              "size": 1471,
              "last_modified": "2025-08-06T08:35:04.096711",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "local": {
          "CalendarLocalDataSource.kt": {
            "type": "file",
            "info": {
              "size": 3243,
              "last_modified": "2025-08-06T08:35:04.099266",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "AppDatabase.kt": {
            "type": "file",
            "info": {
              "size": 531,
              "last_modified": "2025-08-06T08:35:04.10126",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "remote": {
          "dto": {
            "EventDto.kt": {
              "type": "file",
              "info": {
                "size": 665,
                "last_modified": "2025-08-06T08:35:04.104219",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "EventRequest.kt": {
              "type": "file",
              "info": {
                "size": 417,
                "last_modified": "2025-08-06T08:35:04.10644",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "CalendarApiService.kt": {
            "type": "file",
            "info": {
              "size": 1269,
              "last_modified": "2025-08-06T08:35:04.109102",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "EventUpdateMode.kt": {
            "type": "file",
            "info": {
              "size": 166,
              "last_modified": "2025-08-06T08:35:04.110828",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "EventDeleteMode.kt": {
            "type": "file",
            "info": {
              "size": 150,
              "last_modified": "2025-08-06T08:35:04.112782",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "CalendarRemoteDataSource.kt": {
            "type": "file",
            "info": {
              "size": 5179,
              "last_modified": "2025-08-06T08:35:04.114561",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        }
      }
    },
    "app": {
      "CaliindaApplication.kt": {
        "type": "file",
        "info": {
          "size": 321,
          "last_modified": "2025-08-06T08:35:04.118804",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "MainActivity.kt": {
        "type": "file",
        "info": {
          "size": 1337,
          "last_modified": "2025-08-06T08:35:04.120786",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "di": {
        "DispatchersModule.kt": {
          "type": "file",
          "info": {
            "size": 806,
            "last_modified": "2025-08-06T08:35:04.122466",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        },
        "AppConfigModule.kt": {
          "type": "file",
          "info": {
            "size": 1054,
            "last_modified": "2025-08-06T08:35:04.124153",
            "mime_type": "text/plain",
            "extension": ".kt"
          }
        }
      }
    },
    "navigation": {
      "AppNavHost.kt": {
        "type": "file",
        "info": {
          "size": 4007,
          "last_modified": "2025-08-06T08:35:04.129581",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      },
      "NavRoutes.kt": {
        "type": "file",
        "info": {
          "size": 302,
          "last_modified": "2025-08-06T08:35:04.132426",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    },
    "feature": {
      "settings": {
        "ui": {
          "AgentSettingsScreen.kt": {
            "type": "file",
            "info": {
              "size": 5979,
              "last_modified": "2025-08-06T08:35:04.136028",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "LogInDialog.kt": {
            "type": "file",
            "info": {
              "size": 5935,
              "last_modified": "2025-08-06T08:35:04.138302",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "SettingsScreen.kt": {
            "type": "file",
            "info": {
              "size": 10437,
              "last_modified": "2025-08-06T08:35:04.140092",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "TermsOfUseSettings.kt": {
            "type": "file",
            "info": {
              "size": 2058,
              "last_modified": "2025-08-06T08:35:04.141895",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "TimeSettingsScreen.kt": {
            "type": "file",
            "info": {
              "size": 5814,
              "last_modified": "2025-08-06T08:35:04.143733",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "vm": {
          "SettingsViewModel.kt": {
            "type": "file",
            "info": {
              "size": 1417,
              "last_modified": "2025-08-06T08:35:04.146417",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        }
      },
      "calendar": {
        "ui": {
          "CalendarScreen.kt": {
            "type": "file",
            "info": {
              "size": 18279,
              "last_modified": "2025-08-06T08:35:04.150036",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "CalendarState.kt": {
            "type": "file",
            "info": {
              "size": 552,
              "last_modified": "2025-08-06T08:35:04.152323",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "components": {
            "DayEventsPage.kt": {
              "type": "file",
              "info": {
                "size": 10153,
                "last_modified": "2025-08-06T08:35:04.154915",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "CardsList.kt": {
              "type": "file",
              "info": {
                "size": 9611,
                "last_modified": "2025-08-06T08:35:04.156645",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "BottomBar.kt": {
              "type": "file",
              "info": {
                "size": 8489,
                "last_modified": "2025-08-06T08:35:04.159993",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "FunMessages.kt": {
              "type": "file",
              "info": {
                "size": 11423,
                "last_modified": "2025-08-06T08:35:04.163205",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "CalendarAppBar.kt": {
              "type": "file",
              "info": {
                "size": 5497,
                "last_modified": "2025-08-06T08:35:04.166959",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "EventCard.kt": {
              "type": "file",
              "info": {
                "size": 25024,
                "last_modified": "2025-08-06T08:35:04.171609",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "CalendarViewModel.kt": {
            "type": "file",
            "info": {
              "size": 8945,
              "last_modified": "2025-08-06T08:35:04.175677",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "data": {
          "onEventResults": {
            "CreateEventResult.kt": {
              "type": "file",
              "info": {
                "size": 275,
                "last_modified": "2025-08-06T08:35:04.180602",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "DeleteEventResult.kt": {
              "type": "file",
              "info": {
                "size": 275,
                "last_modified": "2025-08-06T08:35:04.182446",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "EditEventResult.kt": {
              "type": "file",
              "info": {
                "size": 385,
                "last_modified": "2025-08-06T08:35:04.184099",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          }
        }
      },
      "event_management": {
        "ui": {
          "details": {
            "EventDetailsDialog.kt": {
              "type": "file",
              "info": {
                "size": 9343,
                "last_modified": "2025-08-06T08:35:04.188476",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "shared": {
            "sections": {
              "TimeSection.kt": {
                "type": "file",
                "info": {
                  "size": 30731,
                  "last_modified": "2025-08-06T08:35:04.191196",
                  "mime_type": "text/plain",
                  "extension": ".kt"
                }
              },
              "NameSection.kt": {
                "type": "file",
                "info": {
                  "size": 1869,
                  "last_modified": "2025-08-06T08:35:04.193979",
                  "mime_type": "text/plain",
                  "extension": ".kt"
                }
              },
              "suggestions": {
                "SuggestionsViewModel.kt": {
                  "type": "file",
                  "info": {
                    "size": 2037,
                    "last_modified": "2025-08-06T08:35:04.195607",
                    "mime_type": "text/plain",
                    "extension": ".kt"
                  }
                },
                "getTimeBonus.kt": {
                  "type": "file",
                  "info": {
                    "size": 1763,
                    "last_modified": "2025-08-06T08:35:04.19923",
                    "mime_type": "text/plain",
                    "extension": ".kt"
                  }
                },
                "getSuggestedEventNames.kt": {
                  "type": "file",
                  "info": {
                    "size": 5259,
                    "last_modified": "2025-08-06T08:35:04.20219",
                    "mime_type": "text/plain",
                    "extension": ".kt"
                  }
                }
              }
            },
            "InteractiveFields.kt": {
              "type": "file",
              "info": {
                "size": 5551,
                "last_modified": "2025-08-06T08:35:04.208201",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            },
            "GeneralElements.kt": {
              "type": "file",
              "info": {
                "size": 10681,
                "last_modified": "2025-08-06T08:35:04.211203",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "edit": {
            "EditEventScreen.kt": {
              "type": "file",
              "info": {
                "size": 33912,
                "last_modified": "2025-08-06T08:35:04.214037",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "create": {
            "CreateEventScreen.kt": {
              "type": "file",
              "info": {
                "size": 24882,
                "last_modified": "2025-08-06T08:35:04.217307",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          }
        },
        "vm": {
          "EventManagementViewModel.kt": {
            "type": "file",
            "info": {
              "size": 16384,
              "last_modified": "2025-08-06T08:35:04.221073",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        }
      },
      "agent": {
        "ui": {
          "CustomRotatingMorphShape.kt": {
            "type": "file",
            "info": {
              "size": 1318,
              "last_modified": "2025-08-06T08:35:04.224655",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "RecordButton.kt": {
            "type": "file",
            "info": {
              "size": 12354,
              "last_modified": "2025-08-06T08:35:04.22734",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "AIShape.kt": {
            "type": "file",
            "info": {
              "size": 2044,
              "last_modified": "2025-08-06T08:35:04.22912",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          },
          "AIVisualiezer.kt": {
            "type": "file",
            "info": {
              "size": 10872,
              "last_modified": "2025-08-06T08:35:04.23074",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        },
        "vm": {
        },
        "data": {
          "model": {
            "AiVisualizerState.kt": {
              "type": "file",
              "info": {
                "size": 147,
                "last_modified": "2025-08-06T08:35:04.234202",
                "mime_type": "text/plain",
                "extension": ".kt"
              }
            }
          },
          "AiInteractionManager.kt": {
            "type": "file",
            "info": {
              "size": 23607,
              "last_modified": "2025-08-06T08:35:04.236783",
              "mime_type": "text/plain",
              "extension": ".kt"
            }
          }
        }
      }
    },
    "previews": {
      "Preview.kt": {
        "type": "file",
        "info": {
          "size": 2790,
          "last_modified": "2025-08-06T08:35:04.241501",
          "mime_type": "text/plain",
          "extension": ".kt"
        }
      }
    }
  },
  "files": [
    {
      "path": "core/ui/util/DateTimeUtils.kt",
      "content": "package com.lpavs.caliinda.core.ui.util\n\nimport android.util.Log\nimport java.time.Instant\nimport java.time.LocalDate\nimport java.time.LocalDateTime\nimport java.time.LocalTime\nimport java.time.OffsetDateTime\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.format.DateTimeFormatter\nimport java.time.format.DateTimeParseException\n\nobject DateTimeUtils {\n  fun parseToInstant(dateTimeString: String?, zoneIdString: String): Instant? {\n    if (dateTimeString.isNullOrBlank()) return null\n\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.takeIf { it.isNotEmpty() } ?: ZoneId.systemDefault().id)\n        } catch (e: Exception) {\n          Log.w(\"DateTimeUtils\", \"Invalid zoneId '$zoneIdString', using system default.\", e)\n          ZoneId.systemDefault()\n        }\n\n    return try {\n      OffsetDateTime.parse(dateTimeString).toInstant()\n    } catch (_: DateTimeParseException) {\n      try {\n        LocalDateTime.parse(dateTimeString).atZone(zoneId).toInstant()\n      } catch (_: DateTimeParseException) {\n        try {\n          LocalDate.parse(dateTimeString).atStartOfDay(ZoneOffset.UTC).toInstant()\n        } catch (_: DateTimeParseException) {\n          Log.w(\n              \"DateTimeUtils\",\n              \"Could not parse '$dateTimeString' as OffsetDateTime, LocalDateTime, or LocalDate.\")\n          null\n        }\n      }\n    } catch (e: Exception) {\n      Log.e(\"DateTimeUtils\", \"Generic error parsing date/time string: '$dateTimeString'\", e)\n      null\n    }\n  }\n\n  fun formatMillisToIsoString(millis: Long?, zoneIdString: String): String? {\n    if (millis == null) return null\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.ifEmpty { ZoneId.systemDefault().id })\n        } catch (_: Exception) {\n          ZoneId.systemDefault()\n        }\n    return try {\n      Instant.ofEpochMilli(millis).atZone(zoneId).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n    } catch (e: Exception) {\n      Log.e(\n          \"DateTimeUtils\",\n          \"Error formatting millis $millis to ISO string for zone $zoneIdString\",\n          e)\n      null\n    }\n  }\n\n  fun formatDateTimeToIsoWithOffset(\n      date: LocalDate?,\n      time: LocalTime?,\n      isAllDay: Boolean,\n      zoneIdString: String\n  ): String? {\n    if (date == null) return null\n\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.takeIf { it.isNotEmpty() } ?: ZoneId.systemDefault().id)\n        } catch (e: Exception) {\n          Log.w(\"DateTimeUtils\", \"Invalid zoneId '$zoneIdString', using system default.\", e)\n          ZoneId.systemDefault()\n        }\n\n    if (time == null && !isAllDay) {\n      Log.w(\n          \"DateTimeUtils\",\n          \"Time is required for non-all-day event formatting to ISO offset string.\")\n      return null\n    }\n\n    val effectiveTime = if (isAllDay) LocalTime.MIDNIGHT else time!!\n\n    return try {\n      val zonedDateTime = date.atTime(effectiveTime).atZone(zoneId)\n      zonedDateTime.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n    } catch (e: Exception) {\n      Log.e(\"DateTimeUtils\", \"Error formatting date/time to ISO offset string\", e)\n      null\n    }\n  }\n\n  /**\n   * Форматирует LocalDate и LocalTime в строку ISO 8601 вида \"yyyy-MM-dd'T'HH:mm:ss\" БЕЗ информации\n   * о таймзоне или смещении. Предполагается, что timeZoneId будет отправлен отдельно.\n   *\n   * @param date Дата события.\n   * @param time Время события.\n   * @return Строка \"yyyy-MM-dd'T'HH:mm:ss\" или null при ошибке.\n   */\n  fun formatLocalDateTimeToNaiveIsoString(date: LocalDate?, time: LocalTime?): String? {\n    if (date == null || time == null) {\n      Log.w(\"DateTimeUtils\", \"Date and Time are required for formatting to naive ISO string.\")\n      return null\n    }\n\n    return try {\n      val localDateTime = LocalDateTime.of(date, time)\n      localDateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n    } catch (e: Exception) {\n      Log.e(\"DateTimeUtils\", \"Error formatting LocalDateTime to naive ISO string\", e)\n      null\n    }\n  }\n}\n",
      "info": {
        "size": 4112,
        "last_modified": "2025-08-06T08:35:03.996703",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/util/BackgroundShapes.kt",
      "content": "package com.lpavs.caliinda.core.ui.util\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.MaterialShapes\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.toShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.rotate\nimport androidx.compose.ui.geometry.Rect\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.Matrix\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Path\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.asComposePath\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport androidx.compose.ui.unit.dp\nimport androidx.graphics.shapes.CornerRounding\nimport androidx.graphics.shapes.RoundedPolygon\nimport androidx.graphics.shapes.star\nimport androidx.graphics.shapes.toPath\nimport kotlin.math.max\n\nenum class BackgroundShapeContext {\n  Main,\n  EventCreation\n}\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun BackgroundShapes(context: BackgroundShapeContext = BackgroundShapeContext.Main) {\n  Box(\n      modifier = Modifier.fillMaxSize()\n      //    .graphicsLayer(alpha = 0.5f) // Можно сделать полупрозрачным, если нужно\n      ) {\n        // Используем when для выбора фигур в зависимости от контекста\n        when (context) {\n          BackgroundShapeContext.Main -> {\n\n            val Clover4Leaf = MaterialShapes.Clover4Leaf.toShape()\n            val Cookie4Sided = MaterialShapes.Flower.toShape()\n            val starContainerSize = 300.dp\n            val star2ContainerSize = 200.dp\n\n            // Фигура 1 (звезда 17)\n            Box(\n                modifier =\n                    Modifier.size(starContainerSize)\n                        .align(Alignment.TopEnd)\n                        .offset(x = starContainerSize * 0.2f, y = -starContainerSize * 0.1f)\n                        .rotate(30f)\n                        .clip(Clover4Leaf)\n                        .background(color = Color.Transparent)\n                        .border(\n                            width = 2.dp, color = colorScheme.surfaceVariant, shape = Clover4Leaf))\n\n            // Фигура 2 (звезда 4)\n            Box(\n                modifier =\n                    Modifier.size(star2ContainerSize)\n                        .align(Alignment.TopStart)\n                        .offset(\n                            x = -star2ContainerSize * 0.4f,\n                            y = star2ContainerSize * 1.5f // Позиция относительно TopStart\n                            )\n                        .rotate(80f)\n                        .clip(Cookie4Sided)\n                        .background(colorScheme.surfaceVariant))\n          }\n\n          BackgroundShapeContext.EventCreation -> {\n            val starShape = remember { RoundedPolygon.star(3, rounding = CornerRounding(0.2f)) }\n            val clipStar = remember(starShape) { RoundedPolygonShape(polygon = starShape) }\n            val star2Shape = remember {\n              RoundedPolygon.star(5, rounding = CornerRounding(0.4f), radius = 2f)\n            }\n            val clip2Star = remember(star2Shape) { RoundedPolygonShape(polygon = star2Shape) }\n            val starContainerSize = 200.dp\n            val star2ContainerSize = 300.dp\n\n            // Фигура 1 (звезда 17)\n            Box(\n                modifier =\n                    Modifier.size(starContainerSize)\n                        .align(Alignment.TopEnd)\n                        .offset(x = starContainerSize * 0.2f, y = -starContainerSize * 0.1f)\n                        .graphicsLayer {\n                          shape = clipStar\n                          alpha = 0.99f // Оставляем для надежности\n                        }\n                        .clip(clipStar)\n                        .background(colorScheme.surfaceVariant))\n\n            // Фигура 2 (звезда 4)\n            Box(\n                modifier =\n                    Modifier.size(star2ContainerSize)\n                        .align(Alignment.TopStart)\n                        .offset(\n                            x = -star2ContainerSize * 0.4f,\n                            y = star2ContainerSize * 2f // Позиция относительно TopStart\n                            )\n                        .graphicsLayer { shape = clip2Star }\n                        .clip(clip2Star)\n                        .background(colorScheme.surfaceVariant))\n          }\n        }\n      }\n}\n\nfun RoundedPolygon.getBounds() = calculateBounds().let { Rect(it[0], it[1], it[2], it[3]) }\n\nclass RoundedPolygonShape(\n    private val polygon: RoundedPolygon,\n    private var matrix: Matrix = Matrix()\n) : Shape {\n  private var path = Path()\n\n  override fun createOutline(\n      size: Size,\n      layoutDirection: LayoutDirection,\n      density: Density\n  ): Outline {\n    path.rewind()\n    path = polygon.toPath().asComposePath()\n    matrix.reset()\n    val bounds = polygon.getBounds()\n    val maxDimension = max(bounds.width, bounds.height)\n    matrix.scale(size.width / maxDimension, size.height / maxDimension)\n    matrix.translate(-bounds.left, -bounds.top)\n\n    path.transform(matrix)\n    return Outline.Generic(path)\n  }\n}\n",
      "info": {
        "size": 5946,
        "last_modified": "2025-08-06T08:35:04.016721",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/util/DateTimeFormatterUtil.kt",
      "content": "package com.lpavs.caliinda.core.ui.util\n\nimport android.content.Context\nimport android.text.format.DateFormat\nimport android.util.Log\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.res.stringResource\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport java.time.Instant\nimport java.time.LocalDateTime\nimport java.time.ZoneId\nimport java.time.format.DateTimeFormatter\nimport java.util.Locale\n\nobject DateTimeFormatterUtil {\n  fun formatEventListTime(context: Context, event: EventDto, zoneIdString: String): String {\n    if (event.isAllDay) return R.string.all_day.toString()\n\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.ifEmpty { ZoneId.systemDefault().id })\n        } catch (_: Exception) {\n          ZoneId.systemDefault()\n        }\n\n    val startInstant = DateTimeUtils.parseToInstant(event.startTime, zoneIdString)\n    val endInstant = DateTimeUtils.parseToInstant(event.endTime, zoneIdString)\n\n    val useSystem24HourFormat = DateFormat.is24HourFormat(context)\n\n    fun formatTime(instant: Instant?): String {\n      if (instant == null) return \"\"\n      return try { // Добавим try-catch на всякий случай\n        val localTime = instant.atZone(zoneId).toLocalTime()\n        val hour = localTime.hour\n        val minute = localTime.minute\n\n        // Используем системную настройку вместо параметра use12Hour\n        if (!useSystem24HourFormat) { // Если НЕ 24-часовой формат (т.е. 12-часовой AM/PM)\n          val amPm =\n              if (hour < 12 || hour == 24) \"AM\"\n              else \"PM\" // Скорректировал AM/PM для полуночи/полудня\n          val hour12 =\n              when (hour) {\n                0,\n                12 -> 12 // 00:xx -> 12 AM, 12:xx -> 12 PM\n                else -> hour % 12\n              }\n          if (minute == 0) {\n            \"$hour12 $amPm\" // Формат без минут\n          } else {\n            String.format(\"%d:%02d %s\", hour12, minute, amPm) // Формат с минутами\n          }\n        } else { // Если 24-часовой формат\n          if (minute == 0) {\n            String.format(\"%02d\", hour) // Формат без минут\n          } else {\n            String.format(\"%02d:%02d\", hour, minute) // Формат с минутами\n          }\n        }\n      } catch (e: Exception) {\n        Log.e(\"FormatTime\", \"Error formatting instant manually: $instant\", e)\n        \"\"\n      }\n    }\n    // --- КОНЕЦ ТВОЕЙ ФУНКЦИИ formatTime ---\n\n    return when {\n      startInstant != null && endInstant != null -> {\n        \"${formatTime(startInstant)} - ${formatTime(endInstant)}\"\n      }\n      startInstant != null -> formatTime(startInstant)\n      else -> \"\"\n    }\n  }\n\n  fun formatEventDetailsTime(\n      context: Context,\n      event: EventDto,\n      zoneIdString: String,\n      locale: Locale\n  ): String {\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.ifEmpty { ZoneId.systemDefault().id })\n        } catch (_: Exception) {\n          ZoneId.systemDefault()\n        }\n\n    val startInstant = DateTimeUtils.parseToInstant(event.startTime, zoneIdString)\n    val endInstant = DateTimeUtils.parseToInstant(event.endTime, zoneIdString)\n\n    val useSystem24HourFormat = DateFormat.is24HourFormat(context)\n\n    fun formatTime(instant: Instant?): String {\n      if (instant == null) return \"\"\n      return try { // Добавим try-catch на всякий случай\n        val localTime = instant.atZone(zoneId).toLocalTime()\n        val hour = localTime.hour\n        val minute = localTime.minute\n\n        // Используем системную настройку вместо параметра use12Hour\n        if (!useSystem24HourFormat) { // Если НЕ 24-часовой формат (т.е. 12-часовой AM/PM)\n          val amPm =\n              if (hour < 12 || hour == 24) \"AM\"\n              else \"PM\" // Скорректировал AM/PM для полуночи/полудня\n          val hour12 =\n              when (hour) {\n                0,\n                12 -> 12 // 00:xx -> 12 AM, 12:xx -> 12 PM\n                else -> hour % 12\n              }\n          if (minute == 0) {\n            \"$hour12 $amPm\" // Формат без минут\n          } else {\n            String.format(\"%d:%02d %s\", hour12, minute, amPm) // Формат с минутами\n          }\n        } else { // Если 24-часовой формат\n          if (minute == 0) {\n            String.format(\"%02d\", hour) // Формат без минут\n          } else {\n            String.format(\"%02d:%02d\", hour, minute) // Формат с минутами\n          }\n        }\n      } catch (e: Exception) {\n        Log.e(\"FormatTime\", \"Error formatting instant manually: $instant\", e)\n        \"\"\n      }\n    }\n\n    fun formatDate(instant: Instant?): String {\n      if (instant == null) return \"\"\n      return try {\n        val localDate = instant.atZone(zoneId).toLocalDate()\n        val formatter = DateTimeFormatter.ofPattern(\"d MMMM\", locale)\n        localDate.format(formatter)\n      } catch (e: Exception) {\n        Log.e(\"FormatDate\", \"Error formatting date: $instant\", e)\n        \"\"\n      }\n    }\n    // --- КОНЕЦ ТВОЕЙ ФУНКЦИИ formatTime ---\n\n    return when {\n      startInstant != null && endInstant != null -> {\n        if (event.isAllDay)\n            return formatDate(startInstant) // TODO когда будут события больше одного дней поменять\n        if (formatDate(startInstant) == formatDate(endInstant)) {\n          \"${formatTime(startInstant)} - ${formatTime(endInstant)}\\n${formatDate(endInstant)}\"\n        } else {\n          \"${formatDate(startInstant)} ${formatTime(startInstant)} - ${formatTime(endInstant)} ${formatDate(endInstant)}\"\n        }\n      }\n\n      startInstant != null -> formatTime(startInstant)\n      else -> \"\"\n    }\n  }\n\n  @Composable\n  fun formatRRule(rrule: String, zoneIdString: String): String {\n    val zoneId =\n        try {\n          ZoneId.of(zoneIdString.ifEmpty { ZoneId.systemDefault().id })\n        } catch (_: Exception) {\n          ZoneId.systemDefault()\n        }\n    val currentLocale = LocalConfiguration.current.getLocales().get(0)\n\n    val parts =\n        rrule.removePrefix(\"RRULE:\").split(\";\").associate {\n          val (key, value) = it.split(\"=\")\n          key to value\n        }\n\n    val freq = parts[\"FREQ\"]\n    val byDay = parts[\"BYDAY\"]\n    val until = parts[\"UNTIL\"]\n    val count = parts[\"COUNT\"]\n\n    val freqText =\n        when (freq) {\n          \"DAILY\" -> stringResource(R.string.recurrence_daily_lower)\n          \"WEEKLY\" -> stringResource(R.string.recurrence_weekly_lower)\n          \"MONTHLY\" -> stringResource(R.string.recurrence_monthly_lower)\n          \"YEARLY\" -> stringResource(R.string.recurrence_yearly_lower)\n          else -> stringResource(R.string.recurrence_unknown)\n        }\n\n    val daysText =\n        byDay\n            ?.split(\",\")\n            ?.mapNotNull {\n              when (it) {\n                \"MO\" -> stringResource(R.string.day_monday)\n                \"TU\" -> stringResource(R.string.day_tuesday)\n                \"WE\" -> stringResource(R.string.day_wednesday)\n                \"TH\" -> stringResource(R.string.day_thursday)\n                \"FR\" -> stringResource(R.string.day_friday)\n                \"SA\" -> stringResource(R.string.day_saturday)\n                \"SU\" -> stringResource(R.string.day_sunday)\n                else -> null\n              }\n            }\n            ?.joinToString(\", \")\n            ?.let { stringResource(R.string.recurrence_on_days, it) } ?: \"\"\n\n    val untilDateFormatted =\n        try {\n          until?.let {\n            val formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\")\n            val date = LocalDateTime.parse(it, formatter).atZone(zoneId).toLocalDate()\n            date.format(DateTimeFormatter.ofPattern(\"d MMMM yyyy\", currentLocale))\n          }\n        } catch (_: Exception) {\n          null\n        }\n\n    val untilText = untilDateFormatted?.let { stringResource(R.string.recurrence_until, it) } ?: \"\"\n\n    val countText = count?.let { stringResource(R.string.recurrence_count, it.toInt()) } ?: \"\"\n\n    return buildString {\n          append(stringResource(R.string.recurrence_repeats))\n          append(\" \")\n          append(freqText)\n\n          if (daysText.isNotBlank()) {\n            append(\" \")\n            append(daysText)\n          }\n\n          if (untilText.isNotBlank()) {\n            append(\" \")\n            append(untilText)\n          }\n\n          if (countText.isNotBlank()) {\n            append(\" \")\n            append(countText)\n          }\n        }\n        .trim()\n  }\n}\n",
      "info": {
        "size": 8880,
        "last_modified": "2025-08-06T08:35:04.025802",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/theme/ValDefaults.kt",
      "content": "package com.lpavs.caliinda.core.ui.theme\n\nimport androidx.compose.ui.unit.dp\n\n// --- Константы для UI и логики ---\nobject CalendarUiDefaults {\n  // Размеры и отступы\n  val ItemHorizontalPadding = 16.dp\n  val ItemVerticalPadding = 3.dp // Базовый вертикальный отступ между элементами\n  val MicroItemContentVerticalPadding = 1.dp\n  val StandardItemContentVerticalPadding = 3.dp\n  val AllDayItemPadding = 16.dp\n  val AllDayItemVerticalContentPadding = 6.dp\n  val padding = 8.dp\n  val EventItemCornerRadius = 20.dp\n  val MinEventHeight = 65.dp\n  val MaxEventHeight = 200.dp\n  val MicroEventHeight = 30.dp\n  const val MicroEventMaxDurationMinutes = 25L\n  val MinStarContainerSize = 120.dp // Размер контейнера для декоративной звезды\n  val MaxStarContainerSize = 360.dp // Размер контейнера для декоративной звезды\n\n  // Для настроек\n  val SettingsItemCornerRadius = 25.dp\n\n  // Тени и Z-index\n  val CurrentEventElevation = 8.dp\n\n  const val HeightSigmoidMidpointMinutes = 180.0\n  const val HeightSigmoidScaleFactor = 100.0\n  const val HeightSigmoidSteepness = 4.5\n  const val EVENT_TRANSITION_WINDOW_MINUTES = 60L\n\n  const val ShapeMinVertices = 3\n  const val ShapeMaxVerticesDelta = 5\n  const val ShapeShadowOffsetXMaxModulo = 11\n  const val ShapeShadowOffsetYMin = 3\n  const val ShapeShadowOffsetYMaxModulo = 6\n  const val ShapeOffsetParamMultiplier = 0.1f\n  const val ShapeRadiusSeedMin = 0.4f\n  const val ShapeRadiusSeedRange = 0.4f\n  const val ShapeRadiusSeedRangeModulo = 11\n  const val ShapeMaxRadius = 3f\n  const val ShapeRotationMaxDegrees = 91\n  const val ShapeRotationOffsetDegrees = -45f\n  const val ShapeCornerRounding = 0.95f\n  const val ShapeMainAlpha = 0.95f\n  const val SHAPEINNERRADIUS = 0.3f\n\n  // CreationScreen\n  val ContainerPadding = 10.dp\n  val ContainerCornerRadius = 25.dp\n}\n\nval cuid = CalendarUiDefaults\n",
      "info": {
        "size": 1992,
        "last_modified": "2025-08-06T08:35:04.034461",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/theme/Color.kt",
      "content": "package com.lpavs.caliinda.core.ui.theme\n",
      "info": {
        "size": 41,
        "last_modified": "2025-08-06T08:35:04.040451",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/theme/Theme.kt",
      "content": "package com.lpavs.caliinda.core.ui.theme\n\nimport android.os.Build\nimport androidx.compose.foundation.isSystemInDarkTheme\nimport androidx.compose.material3.ColorScheme\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.darkColorScheme\nimport androidx.compose.material3.dynamicDarkColorScheme\nimport androidx.compose.material3.dynamicLightColorScheme\nimport androidx.compose.material3.lightColorScheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.CompositionLocalProvider\nimport androidx.compose.runtime.compositionLocalOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\n\ndata class FixedAccentColors(\n    val primaryFixed: Color,\n    val onPrimaryFixed: Color,\n    val secondaryFixed: Color,\n    val onSecondaryFixed: Color,\n    val tertiaryFixed: Color,\n    val onTertiaryFixed: Color,\n    val primaryFixedDim: Color,\n    val secondaryFixedDim: Color,\n    val tertiaryFixedDim: Color,\n)\n\nval LocalFixedAccentColors =\n    compositionLocalOf<FixedAccentColors> { error(\"No FixedAccentColors provided\") }\n\n@Composable\nfun rememberFixedAccentColors(\n    colorSchemeLight: ColorScheme,\n    colorSchemeDark: ColorScheme\n): FixedAccentColors {\n  return remember(colorSchemeLight, colorSchemeDark) {\n    FixedAccentColors(\n        primaryFixed = colorSchemeLight.primaryContainer,\n        onPrimaryFixed = colorSchemeLight.onPrimaryContainer,\n        secondaryFixed = colorSchemeLight.secondaryContainer,\n        onSecondaryFixed = colorSchemeLight.onSecondaryContainer,\n        tertiaryFixed = colorSchemeLight.tertiaryContainer,\n        onTertiaryFixed = colorSchemeLight.onTertiaryContainer,\n        primaryFixedDim = colorSchemeDark.primary,\n        secondaryFixedDim = colorSchemeDark.secondary,\n        tertiaryFixedDim = colorSchemeDark.tertiary)\n  }\n}\n\n// -------------------- Calendar Theme --------------------\n\n@Composable\nfun CaliindaTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    dynamicColor: Boolean = true,\n    content: @Composable () -> Unit\n) {\n  val context = LocalContext.current\n\n  val lightColors =\n      when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S ->\n            dynamicLightColorScheme(context)\n        else -> lightColorScheme()\n      }\n\n  val darkColors =\n      when {\n        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S ->\n            dynamicDarkColorScheme(context)\n        else -> darkColorScheme()\n      }\n\n  val colorScheme = if (darkTheme) darkColors else lightColors\n\n  val fixedAccentColors = rememberFixedAccentColors(lightColors, darkColors)\n\n  CompositionLocalProvider(LocalFixedAccentColors provides fixedAccentColors) {\n    MaterialTheme(colorScheme = colorScheme, typography = Typography, content = content)\n  }\n}\n",
      "info": {
        "size": 2856,
        "last_modified": "2025-08-06T08:35:04.048866",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/ui/theme/Type.kt",
      "content": "package com.lpavs.caliinda.core.ui.theme\n\nimport androidx.compose.material3.Typography\nimport androidx.compose.ui.text.TextStyle\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.sp\n\nval Typography =\n    Typography(\n        bodyLarge =\n            TextStyle(\n                fontFamily = FontFamily.Default,\n                fontWeight = FontWeight.Normal,\n                fontSize = 16.sp,\n                lineHeight = 24.sp,\n                letterSpacing = 0.5.sp)\n        /* Other default text styles to override\n        titleLarge = TextStyle(\n            fontFamily = FontFamily.Default,\n            fontWeight = FontWeight.Normal,\n            fontSize = 22.sp,\n            lineHeight = 28.sp,\n            letterSpacing = 0.sp\n        ),\n        labelSmall = TextStyle(\n            fontFamily = FontFamily.Default,\n            fontWeight = FontWeight.Medium,\n            fontSize = 11.sp,\n            lineHeight = 16.sp,\n            letterSpacing = 0.5.sp\n        )\n        */\n        )\n",
      "info": {
        "size": 1069,
        "last_modified": "2025-08-06T08:35:04.056294",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/common/Exceptions.kt",
      "content": "package com.lpavs.caliinda.core.common\n\nclass ApiException(val code: Int, override val message: String?) : Throwable(message)\n\nclass NetworkException(override val message: String?) : Throwable(message)\n\nclass UnknownException(override val message: String?) : Throwable(message)\n",
      "info": {
        "size": 278,
        "last_modified": "2025-08-06T08:35:04.062478",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/common/EventNetworkState.kt",
      "content": "package com.lpavs.caliinda.core.common\n\nsealed interface EventNetworkState {\n  object Idle : EventNetworkState\n\n  object Loading : EventNetworkState\n\n  data class Error(val message: String) : EventNetworkState\n}\n",
      "info": {
        "size": 212,
        "last_modified": "2025-08-06T08:35:04.065096",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/repository/mapper/EventMapper.kt",
      "content": "package com.lpavs.caliinda.core.data.repository.mapper\n\nimport android.util.Log\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.repository.CalendarEventEntity\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils\nimport java.time.Instant\nimport java.time.temporal.ChronoUnit\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass EventMapper @Inject constructor() {\n\n  private val TAG = \"EventMapper\"\n\n  // Принимает ID часового пояса как параметр\n  fun mapToEntity(event: EventDto, zoneIdString: String): CalendarEventEntity? {\n    try {\n      val isAllDayEvent = event.isAllDay\n      val startTimeInstant: Instant? = DateTimeUtils.parseToInstant(event.startTime, zoneIdString)\n\n      if (startTimeInstant == null) {\n        Log.w(\n            TAG,\n            \"Failed to parse start time for event '${event.summary}' ('${event.startTime}'), skipping.\")\n        return null\n      }\n      val startTimeMillis = startTimeInstant.toEpochMilli()\n\n      val endTimeInstant: Instant? = DateTimeUtils.parseToInstant(event.endTime, zoneIdString)\n\n      val endTimeMillis: Long =\n          when {\n            endTimeInstant != null && endTimeInstant.toEpochMilli() > startTimeMillis -> {\n              endTimeInstant.toEpochMilli()\n            }\n            isAllDayEvent -> {\n              startTimeInstant.plus(1, ChronoUnit.DAYS).toEpochMilli()\n            }\n            else -> {\n              Log.w(\n                  TAG,\n                  \"Event '${event.summary}' (not all-day or no end time) using start time as end time.\")\n              startTimeMillis\n            }\n          }\n\n      return CalendarEventEntity(\n          id = event.id,\n          summary = event.summary,\n          startTimeMillis = startTimeMillis,\n          endTimeMillis = endTimeMillis,\n          description = event.description,\n          location = event.location,\n          isAllDay = isAllDayEvent,\n          recurringEventId = event.recurringEventId, // Из event (domain)\n          originalStartTimeString = event.originalStartTime,\n          recurrenceRuleString = event.recurrenceRule)\n    } catch (e: Exception) {\n      Log.e(TAG, \"Error mapping CalendarEvent to Entity: ${event.id}\", e)\n      return null\n    }\n  }\n\n  fun mapToDomain(entity: CalendarEventEntity, zoneIdString: String): EventDto {\n    val startTimeStr = DateTimeUtils.formatMillisToIsoString(entity.startTimeMillis, zoneIdString)\n    val endTimeStr = DateTimeUtils.formatMillisToIsoString(entity.endTimeMillis, zoneIdString)\n\n    return EventDto(\n        id = entity.id,\n        summary = entity.summary,\n        startTime = startTimeStr ?: \"\",\n        endTime = endTimeStr ?: \"\",\n        description = entity.description,\n        location = entity.location,\n        isAllDay = entity.isAllDay,\n        recurringEventId = entity.recurringEventId,\n        originalStartTime = entity.originalStartTimeString,\n        recurrenceRule = entity.recurrenceRuleString)\n  }\n}\n",
      "info": {
        "size": 3015,
        "last_modified": "2025-08-06T08:35:04.068219",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/repository/SuggestionsRepository.kt",
      "content": "package com.lpavs.caliinda.core.data.repository\n\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.core.edit\nimport androidx.datastore.preferences.core.intPreferencesKey\nimport androidx.datastore.preferences.core.stringPreferencesKey\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.flow.map\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass SuggestionsRepository @Inject constructor(private val dataStore: DataStore<Preferences>) {\n\n  private object PreferencesKeys {\n    val SUGGESTION_WEIGHTS = stringPreferencesKey(\"suggestion_weights\")\n  }\n\n  suspend fun incrementWeight(suggestion: String) {\n    val key = intPreferencesKey(\"${suggestion}_weight\")\n    dataStore.edit { preferences ->\n      val currentWeight = preferences[key] ?: 0\n      preferences[key] = currentWeight + 1\n    }\n  }\n\n  suspend fun getWeights(): Map<String, Int> {\n    return dataStore.data\n        .map { preferences ->\n          preferences\n              .asMap()\n              .keys\n              .filter { it.name.endsWith(\"_weight\") }\n              .associate { key ->\n                val chipKey = key.name.removeSuffix(\"_weight\")\n                val weight = preferences[key] as? Int ?: 0\n                chipKey to weight\n              }\n        }\n        .first()\n  }\n}\n",
      "info": {
        "size": 1376,
        "last_modified": "2025-08-06T08:35:04.071223",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/repository/CalendarRepository.kt",
      "content": "package com.lpavs.caliinda.core.data.repository\n\nimport android.util.Log\nimport com.lpavs.caliinda.app.di.IoDispatcher\nimport com.lpavs.caliinda.core.common.EventNetworkState\nimport com.lpavs.caliinda.core.data.auth.AuthEvent\nimport com.lpavs.caliinda.core.data.auth.AuthManager\nimport com.lpavs.caliinda.core.data.local.CalendarLocalDataSource\nimport com.lpavs.caliinda.core.data.remote.CalendarRemoteDataSource\nimport com.lpavs.caliinda.core.data.remote.EventDeleteMode\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport com.lpavs.caliinda.core.data.repository.mapper.EventMapper\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.ExperimentalCoroutinesApi\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.flow.flatMapLatest\nimport kotlinx.coroutines.flow.flowOn\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.isActive\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.sync.Mutex\nimport kotlinx.coroutines.sync.withLock\nimport kotlinx.coroutines.withContext\nimport java.time.LocalDate\nimport java.time.ZoneId\nimport java.util.concurrent.CancellationException\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass CalendarRepository\n@Inject\nconstructor(\n    private val remotreDataSource: CalendarRemoteDataSource,\n    private val localDataSource: CalendarLocalDataSource,\n    private val settingsRepository: SettingsRepository,\n    private val authManager: AuthManager,\n    private val eventMapper: EventMapper,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n  private val _loadedDateRange = MutableStateFlow<ClosedRange<LocalDate>?>(null)\n  private val _rangeNetworkState = MutableStateFlow<EventNetworkState>(EventNetworkState.Idle)\n  private var fetchJobHolder: JobHolder? = null\n  private val fetchJobMutex = Mutex()\n\n  private var lastKnownVisibleDate = LocalDate.now()\n\n  private data class JobHolder(val job: Job, val requestedRange: ClosedRange<LocalDate>)\n\n  private var activeFetchJob: Job? = null\n  private val managerScope = CoroutineScope(SupervisorJob() + ioDispatcher)\n  val rangeNetworkState: StateFlow<EventNetworkState> = _rangeNetworkState.asStateFlow()\n\n  companion object {\n    const val INITIAL_LOAD_DAYS_AROUND = 7L\n    const val UPDATE_LOAD_DAYS_AROUND = 5L\n    const val TRIGGER_PREFETCH_THRESHOLD = 2L\n    const val EXPAND_CHUNK_DAYS = 14L\n    const val JUMP_DETECTION_BUFFER_DAYS = 10L\n    private const val TAG = \"CalendarDataManager\"\n  }\n    init {\n    managerScope.launch {\n        authManager.authEvents.collect() { event ->\n            when (event) {\n                AuthEvent.SignedOut -> clearLocalDataOnSignOut()\n            }\n        }\n    }\n    }\n\n  // --- Секция Предоставление данных ---\n  /** Предоставляет Flow событий из БД для указанной даты */\n  @OptIn(ExperimentalCoroutinesApi::class)\n  fun getEventsFlowForDate(date: LocalDate): Flow<List<EventDto>> {\n    return settingsRepository.timeZoneFlow\n        .flatMapLatest { timeZoneIdString ->\n          val zoneId = parseTimeZone(timeZoneIdString)\n          val (startMillis, endMillis) = calculateLocalBounds(date, zoneId)\n\n          localDataSource.getEventsForDateRangeFlow(startMillis, endMillis).map { entityList ->\n            entityList\n                .filter { entity -> isEventValidForDate(entity, startMillis, endMillis) }\n                .map { entity -> eventMapper.mapToDomain(entity, zoneId.toString()) }\n          }\n        }\n        .catch { e ->\n          Log.e(TAG, \"Error processing events Flow for date $date\", e)\n          emit(emptyList())\n        }\n        .flowOn(ioDispatcher)\n  }\n\n  /** Безопасный парсинг часового пояса */\n  private fun parseTimeZone(timeZoneIdString: String): ZoneId {\n    return try {\n      ZoneId.of(timeZoneIdString.ifEmpty { ZoneId.systemDefault().id })\n    } catch (e: Exception) {\n      Log.w(TAG, \"Invalid timezone: $timeZoneIdString, using system default\", e)\n      ZoneId.systemDefault()\n    }\n  }\n\n  /** Вычисляет границы дня в локальном часовом поясе */\n  private fun calculateLocalBounds(date: LocalDate, zoneId: ZoneId): Pair<Long, Long> {\n    val startOfDay = date.atStartOfDay(zoneId)\n    val endOfDay = startOfDay.plusDays(1)\n\n    return Pair(startOfDay.toInstant().toEpochMilli(), endOfDay.toInstant().toEpochMilli())\n  }\n\n  /** Проверяет, валидно ли событие для указанной даты */\n  private fun isEventValidForDate(\n      entity: CalendarEventEntity,\n      startMillis: Long,\n      endMillis: Long\n  ): Boolean {\n    return if (!entity.isAllDay) {\n      entity.startTimeMillis < endMillis && entity.endTimeMillis > startMillis\n    } else {\n      val durationMillis = entity.endTimeMillis - entity.startTimeMillis\n      val twentyFourHoursMillis = TimeUnit.HOURS.toMillis(24)\n      val toleranceMillis = TimeUnit.MINUTES.toMillis(5)\n\n      (durationMillis >= twentyFourHoursMillis - toleranceMillis) &&\n          (durationMillis <= twentyFourHoursMillis + toleranceMillis) &&\n          (entity.startTimeMillis < endMillis && entity.endTimeMillis > startMillis)\n    }\n  }\n\n  // --- Секция Запрос данных ---\n  suspend fun fetchAndStoreDateRange(range: ClosedRange<LocalDate>, replace: Boolean) {\n    _rangeNetworkState.value = EventNetworkState.Loading\n    val result = remotreDataSource.getEvents(range.start, range.endInclusive)\n    withContext(ioDispatcher) {\n      result\n          .onSuccess { dtoList ->\n            val zoneIdString =\n                settingsRepository.timeZoneFlow.first().ifEmpty { ZoneId.systemDefault().id }\n            val zoneId = ZoneId.of(zoneIdString)\n            val entities = dtoList.mapNotNull { eventMapper.mapToEntity(it, zoneIdString) }\n            val startRangeMillis = range.start.atStartOfDay(zoneId).toInstant().toEpochMilli()\n            val endRangeMillis =\n                range.endInclusive.plusDays(1).atStartOfDay(zoneId).toInstant().toEpochMilli()\n            localDataSource.clearAndInsertEventsForRange(\n                startRangeMillis = startRangeMillis,\n                endRangeMillis = endRangeMillis,\n                newEvents = entities)\n            updateLoadedRange(range, replace)\n            _rangeNetworkState.value = EventNetworkState.Idle\n          }\n          .onFailure { exception ->\n            val errorMessage = exception.message ?: \"Unknown error\"\n            _rangeNetworkState.value = EventNetworkState.Error(errorMessage)\n          }\n    }\n  }\n\n  private fun updateLoadedRange(fetchedRange: ClosedRange<LocalDate>, replace: Boolean) {\n    if (replace) {\n      _loadedDateRange.value = fetchedRange\n      Log.d(TAG, \"Replaced loaded range with: $fetchedRange\")\n    } else {\n      _loadedDateRange.update { current ->\n        val updatedRange = current?.union(fetchedRange) ?: fetchedRange\n        Log.d(\n            TAG,\n            \"Merged fetched range $fetchedRange with current ${current}. New loaded range: $updatedRange\")\n        updatedRange\n      }\n    }\n  }\n\n  private fun ClosedRange<LocalDate>.union(other: ClosedRange<LocalDate>): ClosedRange<LocalDate> {\n    val newStart = minOf(this.start, other.start)\n    val newEnd = maxOf(this.endInclusive, other.endInclusive)\n    return newStart..newEnd\n  }\n\n  /** Принудительно обновляет данные для указанной даты */\n  suspend fun refreshDate(centerDateToRefreshAround: LocalDate) {\n    Log.d(TAG, \"Manual refresh triggered around date: $centerDateToRefreshAround\")\n\n    activeFetchJob?.cancel(\n        CancellationException(\"Manual refresh triggered for $centerDateToRefreshAround\"))\n    Log.d(TAG, \"refreshDate: Previous activeFetchJob (ensure...) cancelled (if existed).\")\n\n    val targetRefreshRangeStart = centerDateToRefreshAround.minusDays(UPDATE_LOAD_DAYS_AROUND)\n    val targetRefreshRangeEnd = centerDateToRefreshAround.plusDays(UPDATE_LOAD_DAYS_AROUND)\n    val targetRefreshRange = targetRefreshRangeStart..targetRefreshRangeEnd\n    Log.d(TAG, \"refreshDate: Target refresh range is $targetRefreshRange\")\n\n    fetchJobMutex.withLock {\n      fetchJobHolder\n          ?.job\n          ?.cancel(CancellationException(\"Force refresh for $centerDateToRefreshAround\"))\n      fetchJobHolder = null\n      Log.d(TAG, \"refreshDate: Cancelled existing fetchJobHolder due to force refresh.\")\n    }\n\n    launchProtectedFetch(targetRefreshRange, true)\n  }\n\n  private fun launchProtectedFetch(rangeToFetch: ClosedRange<LocalDate>, replace: Boolean = true) {\n    managerScope.launch {\n      fetchJobMutex.withLock {\n        val currentActiveJobDetails = fetchJobHolder?.takeIf { it.job.isActive }\n\n        if (currentActiveJobDetails != null) {\n          val currentlyFetchingRange = currentActiveJobDetails.requestedRange\n\n          if (rangeToFetch.start >= currentlyFetchingRange.start &&\n              rangeToFetch.endInclusive <= currentlyFetchingRange.endInclusive) {\n            Log.d(\n                TAG,\n                \"launchProtectedFetch: New range $rangeToFetch is covered by ongoing $currentlyFetchingRange. Skipping.\")\n            return@launch\n          }\n          if (_rangeNetworkState.value == EventNetworkState.Loading) {\n            Log.d(\n                TAG,\n                \"launchProtectedFetch: Network is already Loading (for $currentlyFetchingRange). New request for $rangeToFetch will be deferred. Skipping new launch.\")\n            return@launch\n          }\n          Log.d(\n              TAG,\n              \"launchProtectedFetch: New range $rangeToFetch. Cancelling previous job (if any was active but not in Loading state) for $currentlyFetchingRange.\")\n          currentActiveJobDetails.job.cancel(\n              CancellationException(\"Superseded by new fetch for $rangeToFetch\"))\n        }\n\n        _rangeNetworkState.value = EventNetworkState.Loading\n        Log.i(\n            TAG,\n            \"launchProtectedFetch: Set _rangeNetworkState to Loading. Starting fetch for $rangeToFetch.\")\n\n        val newActualFetchJob =\n            managerScope.launch {\n              try {\n                fetchAndStoreDateRange(rangeToFetch.start..rangeToFetch.endInclusive, replace)\n              } catch (e: kotlin.coroutines.cancellation.CancellationException) {\n                Log.i(\n                    TAG,\n                    \"launchProtectedFetch/newActualFetchJob: Fetch job for $rangeToFetch was cancelled.\",\n                    e)\n                throw e\n              } catch (e: Exception) {\n                Log.e(\n                    TAG,\n                    \"launchProtectedFetch/newActualFetchJob: Exception in fetch job for $rangeToFetch\",\n                    e)\n                if (_rangeNetworkState.value !is EventNetworkState.Error &&\n                    _rangeNetworkState.value != EventNetworkState.Idle) {\n                  _rangeNetworkState.value =\n                      EventNetworkState.Error(\"FADR Error unhandled: ${e.message}\")\n                }\n              } finally {\n                fetchJobMutex.withLock {\n                  if (fetchJobHolder?.job == coroutineContext[Job]) {\n                    fetchJobHolder = null\n                    Log.d(\n                        TAG,\n                        \"launchProtectedFetch (finally of newActualFetchJob): Cleared fetchJobHolder for $rangeToFetch.\")\n                  }\n                }\n                if (_rangeNetworkState.value == EventNetworkState.Loading &&\n                    !coroutineContext.isActive) {\n                  Log.w(\n                      TAG,\n                      \"launchProtectedFetch (finally of newActualFetchJob): Job for $rangeToFetch ended, but state is still Loading. Resetting to Idle.\")\n                  _rangeNetworkState.value = EventNetworkState.Idle\n                }\n              }\n            }\n        fetchJobHolder = JobHolder(newActualFetchJob, rangeToFetch)\n      }\n    }\n  }\n\n  /** Проверяет, нужно ли загружать/расширять диапазон дат */\n  private suspend fun ensureDateRangeLoadedAround(centerDate: LocalDate, forceLoad: Boolean) =\n      withContext(ioDispatcher) {\n        val currentlyLoaded = _loadedDateRange.value\n        val initialOrJumpTargetRange =\n            centerDate.minusDays(INITIAL_LOAD_DAYS_AROUND)..centerDate.plusDays(\n                    INITIAL_LOAD_DAYS_AROUND)\n        Log.d(\n            TAG,\n            \"ensureDateRange: center=$centerDate, current=$currentlyLoaded, initialOrJumpTarget=$initialOrJumpTargetRange, forceLoad=$forceLoad\")\n\n        if (forceLoad) {\n          Log.i(\n              TAG,\n              \"Force load requested for $centerDate. Fetching range: $initialOrJumpTargetRange\")\n          fetchJobMutex.withLock {\n            fetchJobHolder?.job?.cancel(CancellationException(\"Force load for $centerDate\"))\n            fetchJobHolder = null\n            Log.d(\n                TAG,\n                \"ensureDateRangeLoadedAround: Cancelled existing fetchJobHolder due to forceLoad.\")\n          }\n          launchProtectedFetch(initialOrJumpTargetRange, true)\n          return@withContext\n        }\n\n        if (currentlyLoaded == null) {\n          Log.i(TAG, \"Initial load for $centerDate. Fetching range: $initialOrJumpTargetRange\")\n          launchProtectedFetch(initialOrJumpTargetRange, true)\n        } else {\n          val isJump =\n              centerDate < currentlyLoaded.start.minusDays(JUMP_DETECTION_BUFFER_DAYS) ||\n                  centerDate > currentlyLoaded.endInclusive.plusDays(JUMP_DETECTION_BUFFER_DAYS)\n\n          if (isJump) {\n            Log.i(\n                TAG, \"Jump detected for $centerDate. Fetching new range: $initialOrJumpTargetRange\")\n            fetchJobMutex.withLock {\n              fetchJobHolder?.job?.cancel(CancellationException(\"Jump detected for $centerDate\"))\n              fetchJobHolder = null\n              Log.d(\n                  TAG,\n                  \"ensureDateRangeLoadedAround: Cancelled existing fetchJobHolder due to jump.\")\n            }\n            launchProtectedFetch(initialOrJumpTargetRange, true)\n          } else {\n            var rangeToFetchDeltaStart: LocalDate? = null\n            var rangeToFetchDeltaEnd: LocalDate? = null\n\n            if (centerDate >= currentlyLoaded.endInclusive.minusDays(TRIGGER_PREFETCH_THRESHOLD)) {\n              rangeToFetchDeltaStart = currentlyLoaded.endInclusive.plusDays(1)\n              rangeToFetchDeltaEnd = rangeToFetchDeltaStart.plusDays(EXPAND_CHUNK_DAYS - 1)\n              Log.i(\n                  TAG,\n                  \"Forward prefetch triggered at $centerDate. Need to fetch DELTA: [$rangeToFetchDeltaStart .. $rangeToFetchDeltaEnd]\")\n            } else if (centerDate <= currentlyLoaded.start.plusDays(TRIGGER_PREFETCH_THRESHOLD)) {\n              rangeToFetchDeltaEnd = currentlyLoaded.start.minusDays(1)\n              rangeToFetchDeltaStart = rangeToFetchDeltaEnd.minusDays(EXPAND_CHUNK_DAYS - 1)\n              Log.i(\n                  TAG,\n                  \"Backward prefetch triggered at $centerDate. Need to fetch DELTA: [$rangeToFetchDeltaStart .. $rangeToFetchDeltaEnd]\")\n            }\n\n            if (rangeToFetchDeltaStart != null && rangeToFetchDeltaEnd != null) {\n              launchProtectedFetch(rangeToFetchDeltaStart..rangeToFetchDeltaEnd, false)\n            } else {\n              Log.d(\n                  TAG,\n                  \"No delta load needed for $centerDate. It is comfortably within $currentlyLoaded.\")\n            }\n          }\n        }\n      }\n\n  // --- Секция CRUD\n  suspend fun createEvent(request: EventRequest): Result<Unit> {\n    val result = remotreDataSource.createEvent(request)\n    if (result.isSuccess) {\n      refreshDate(lastKnownVisibleDate)\n    }\n    return result\n  }\n\n  suspend fun deleteEvent(\n      eventId: String,\n      mode: EventDeleteMode = EventDeleteMode.DEFAULT\n  ): Result<Unit> {\n    val result = remotreDataSource.deleteEvent(eventId, mode)\n    if (result.isSuccess) {\n      refreshDate(lastKnownVisibleDate)\n    }\n    return result\n  }\n\n  suspend fun updateEvent(\n      eventId: String,\n      updateData: EventRequest,\n      mode: EventUpdateMode\n  ): Result<Unit> {\n    val result = remotreDataSource.updateEvent(eventId, mode, updateData)\n    if (result.isSuccess) {\n      refreshDate(lastKnownVisibleDate)\n    }\n    return result\n  }\n\n  fun setCurrentVisibleDate(newDate: LocalDate, forceRefresh: Boolean = false) {\n    Log.d(TAG, \"setCurrentVisibleDate: CALLED with $newDate. Last known: $lastKnownVisibleDate\")\n    val needsDateUpdate = newDate != lastKnownVisibleDate\n\n    if (!needsDateUpdate && !forceRefresh && _loadedDateRange.value != null) {\n      Log.d(TAG, \"setCurrentVisibleDate: Date is the same, skipping.\")\n      return\n    }\n    activeFetchJob?.cancel(\n        CancellationException(\"New date set: $newDate, forceRefresh=$forceRefresh\"))\n    Log.d(TAG, \"setCurrentVisibleDate: Previous activeFetchJob cancelled (if existed).\")\n\n    if (needsDateUpdate) {\n      lastKnownVisibleDate = newDate\n    }\n    if (authManager.authState.value.isSignedIn) {\n      activeFetchJob = managerScope.launch { ensureDateRangeLoadedAround(newDate, forceRefresh) }\n    }\n  }\n\n  /**\n   * Очищает все локальные данные о событиях в БД. Вызывается при выходе пользователя из системы.\n   */\n  suspend fun clearLocalDataOnSignOut() {\n    Log.i(TAG, \"Starting local database clear on sign out...\")\n    try {\n      withContext(ioDispatcher) {\n        localDataSource.deleteAllEvents()\n        Log.i(TAG, \"Local database cleared successfully.\")\n      }\n      _loadedDateRange.value = null\n      Log.d(TAG, \"Reset _loadedDateRange state.\")\n    } catch (e: Exception) {\n      Log.e(TAG, \"Failed to clear local database on sign out\", e)\n    }\n  }\n}\n",
      "info": {
        "size": 18417,
        "last_modified": "2025-08-06T08:35:04.073174",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/repository/SettingsRepository.kt",
      "content": "package com.lpavs.caliinda.core.data.repository\n\nimport android.util.Log\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.core.edit\nimport androidx.datastore.preferences.core.emptyPreferences\nimport androidx.datastore.preferences.core.stringPreferencesKey\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.map\nimport java.io.IOException\nimport java.time.ZoneId\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass SettingsRepository @Inject constructor(private val dataStore: DataStore<Preferences>) {\n  private object PreferencesKeys {\n    val BOT_TEMPER = stringPreferencesKey(\"bot_temper\")\n    val TIME_ZONE = stringPreferencesKey(\"time_zone\")\n  }\n\n  val botTemperFlow: Flow<String> =\n      dataStore.data\n          .catch { exception ->\n            if (exception is IOException) {\n              Log.e(TAG, \"Error reading preferences.\", exception)\n              emit(emptyPreferences())\n            } else {\n              throw exception\n            }\n          }\n          .map { preferences -> preferences[PreferencesKeys.BOT_TEMPER] ?: \"\" }\n\n  suspend fun saveBotTemper(temper: String) {\n    try {\n      dataStore.edit { preferences -> preferences[PreferencesKeys.BOT_TEMPER] = temper }\n      Log.i(TAG, \"Saved bot temper setting.\")\n    } catch (exception: IOException) {\n      Log.e(TAG, \"Error writing preferences.\", exception)\n    } catch (exception: Exception) {\n      Log.e(TAG, \"Unexpected error writing preferences.\", exception)\n    }\n  }\n\n  val timeZoneFlow: Flow<String> =\n      dataStore.data\n          .catch { exception ->\n            if (exception is IOException) {\n              Log.e(TAG, \"Error reading preferences.\", exception)\n              emit(emptyPreferences())\n            } else throw exception\n          }\n          .map { preferences ->\n            preferences[PreferencesKeys.TIME_ZONE] ?: ZoneId.systemDefault().id\n          }\n\n  suspend fun saveTimeZone(timeZone: String) {\n    try {\n      dataStore.edit { preferences -> preferences[PreferencesKeys.TIME_ZONE] = timeZone }\n      Log.i(TAG, \"Saved time zone setting.\")\n    } catch (e: IOException) {\n      Log.e(TAG, \"Error saving time zone.\", e)\n    }\n  }\n\n  companion object {\n    private const val TAG = \"SettingsRepository\"\n  }\n}\n",
      "info": {
        "size": 2380,
        "last_modified": "2025-08-06T08:35:04.075012",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/repository/CalendarEventEntity.kt",
      "content": "package com.lpavs.caliinda.core.data.repository\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"calendar_events\")\ndata class CalendarEventEntity(\n    @PrimaryKey val id: String,\n    val summary: String,\n    val startTimeMillis: Long,\n    val endTimeMillis: Long,\n    val description: String?,\n    val location: String?,\n    val isAllDay: Boolean = false,\n    val recurringEventId: String? = null,\n    val originalStartTimeString: String? = null,\n    val lastFetchedMillis: Long = System.currentTimeMillis(),\n    val recurrenceRuleString: String? = null,\n)\n",
      "info": {
        "size": 591,
        "last_modified": "2025-08-06T08:35:04.076909",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/di/DataStore.kt",
      "content": "package com.lpavs.caliinda.core.data.di\n\nimport android.content.Context\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.preferencesDataStore\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Qualifier\nimport javax.inject.Singleton\n\nval Context.settingsDataStore: DataStore<Preferences> by preferencesDataStore(name = \"app_settings\")\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DataStoreModule {\n\n  @Provides\n  @Singleton\n  fun provideSettingsDataStore(@ApplicationContext appContext: Context): DataStore<Preferences> {\n    return appContext.settingsDataStore\n  }\n}\n\n@Qualifier @Retention(AnnotationRetention.BINARY) annotation class BackendUrl\n\n@Qualifier @Retention(AnnotationRetention.BINARY) annotation class WebClientId\n",
      "info": {
        "size": 969,
        "last_modified": "2025-08-06T08:35:04.079911",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/di/NetworkModule.kt",
      "content": "package com.lpavs.caliinda.core.data.di\n\nimport android.content.Context\nimport androidx.room.Room\nimport com.jakewharton.retrofit2.converter.kotlinx.serialization.asConverterFactory\nimport com.lpavs.caliinda.core.data.local.AppDatabase\nimport com.lpavs.caliinda.core.data.local.CalendarLocalDataSource\nimport com.lpavs.caliinda.core.data.remote.CalendarApiService\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport kotlinx.serialization.json.Json\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.logging.HttpLoggingInterceptor\nimport retrofit2.Retrofit\nimport java.util.concurrent.TimeUnit\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n\n  @Provides\n  @Singleton\n  fun provideOkHttpClient(): OkHttpClient {\n    return OkHttpClient.Builder()\n        .connectTimeout(60, TimeUnit.SECONDS)\n        .readTimeout(60, TimeUnit.SECONDS)\n        .writeTimeout(60, TimeUnit.SECONDS)\n        .addInterceptor(\n            HttpLoggingInterceptor().apply { level = HttpLoggingInterceptor.Level.BODY })\n        .build()\n  }\n\n  @Provides\n  @Singleton\n  fun provideRetrofit(okHttpClient: OkHttpClient, @BackendUrl baseUrl: String): Retrofit {\n    val json = Json { ignoreUnknownKeys = true }\n    return Retrofit.Builder()\n        .baseUrl(baseUrl)\n        .client(okHttpClient)\n        .addConverterFactory(json.asConverterFactory(\"application/json\".toMediaType()))\n        .build()\n  }\n\n  @Provides\n  @Singleton\n  fun provideCalendarApiService(retrofit: Retrofit): CalendarApiService {\n    return retrofit.create(CalendarApiService::class.java)\n  }\n}\n\n@Module\n@InstallIn(SingletonComponent::class) // Живет пока живет приложение\nobject DatabaseModule {\n\n  @Provides\n  @Singleton // Гарантирует один экземпляр базы данных\n  fun provideAppDatabase(@ApplicationContext appContext: Context): AppDatabase {\n    return Room.databaseBuilder(appContext, AppDatabase::class.java, \"caliindar_database\")\n        // ВНИМАНИЕ: Для разработки можно использовать .fallbackToDestructiveMigration()\n        // Но для production нужно реализовать правильные миграции!\n        .fallbackToDestructiveMigration(false)\n        .build()\n  }\n\n  @Provides\n  @Singleton // DAO тоже должен быть синглтоном, т.к. зависит от синглтона БД\n  fun provideEventDao(appDatabase: AppDatabase): CalendarLocalDataSource {\n    return appDatabase.eventDao()\n  }\n}\n",
      "info": {
        "size": 2719,
        "last_modified": "2025-08-06T08:35:04.081662",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/di/StorageModule.kt",
      "content": "package com.lpavs.caliinda.core.data.di\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.security.crypto.EncryptedSharedPreferences\nimport androidx.security.crypto.MasterKey\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject StorageModule {\n\n  @Provides\n  @Singleton\n  fun provideEncryptedSharedPreferences(@ApplicationContext context: Context): SharedPreferences {\n    val masterKey = MasterKey.Builder(context).setKeyScheme(MasterKey.KeyScheme.AES256_GCM).build()\n\n    return EncryptedSharedPreferences.create(\n        context,\n        \"secret_shared_prefs\",\n        masterKey,\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM)\n  }\n}\n",
      "info": {
        "size": 982,
        "last_modified": "2025-08-06T08:35:04.083542",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/di/TimeTicker.kt",
      "content": "package com.lpavs.caliinda.core.data.di\n\nimport dagger.Binds\nimport dagger.Module\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.flow\nimport kotlinx.coroutines.flow.stateIn\nimport java.time.Instant\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\ninterface ITimeTicker {\n  val currentTime: StateFlow<Instant>\n}\n\n@Singleton\nclass TimeTicker @Inject constructor() : ITimeTicker {\n\n  private val tickerScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)\n\n  override val currentTime: StateFlow<Instant> =\n      flow {\n            while (true) {\n              emit(Instant.now())\n              delay(60000L)\n            }\n          }\n          .stateIn(\n              scope = tickerScope,\n              started = SharingStarted.WhileSubscribed(5000),\n              initialValue = Instant.now())\n}\n\n@Module\n@InstallIn(SingletonComponent::class)\nabstract class TimeTickerModule {\n  // НЕ УДАЛЯТЬ МОДУЛЬ\n  @Binds @Singleton abstract fun bindTimeTicker(timeTicker: TimeTicker): ITimeTicker\n}\n",
      "info": {
        "size": 1317,
        "last_modified": "2025-08-06T08:35:04.086685",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/auth/AuthManager.kt",
      "content": "package com.lpavs.caliinda.core.data.auth\n\nimport android.app.Activity\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.util.Log\nimport androidx.annotation.WorkerThread\nimport androidx.core.net.toUri\nimport androidx.credentials.ClearCredentialStateRequest\nimport androidx.credentials.CredentialManager\nimport androidx.credentials.CustomCredential\nimport androidx.credentials.GetCredentialRequest\nimport androidx.credentials.GetCredentialResponse\nimport androidx.credentials.exceptions.GetCredentialException\nimport com.google.android.gms.auth.api.identity.AuthorizationClient\nimport com.google.android.gms.auth.api.identity.AuthorizationRequest\nimport com.google.android.gms.auth.api.identity.Identity\nimport com.google.android.gms.common.api.Scope\nimport com.google.android.libraries.identity.googleid.GetGoogleIdOption\nimport com.google.android.libraries.identity.googleid.GoogleIdTokenCredential\nimport com.google.android.libraries.identity.googleid.GoogleIdTokenParsingException\nimport com.google.api.services.calendar.CalendarScopes\nimport com.lpavs.caliinda.core.data.auth.AuthEvent\nimport com.lpavs.caliinda.core.data.di.BackendUrl\nimport com.lpavs.caliinda.core.data.di.WebClientId\nimport com.lpavs.caliinda.core.data.repository.CalendarRepository\nimport dagger.Lazy\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.tasks.await\nimport kotlinx.coroutines.withContext\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.OkHttpClient\nimport okhttp3.Request\nimport okhttp3.RequestBody.Companion.toRequestBody\nimport org.json.JSONException\nimport org.json.JSONObject\nimport java.util.UUID\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass AuthManager\n@Inject\nconstructor(\n    @ApplicationContext private val context: Context,\n    private val okHttpClient: OkHttpClient,\n    @BackendUrl private val backendBaseUrl: String,\n    @WebClientId private val webClientId: String,\n    private val sharedPreferences: SharedPreferences\n) {\n  private val TAG = \"AuthManager\"\n\n  private companion object {\n    const val BACKEND_TOKEN_KEY = \"backend_auth_token\"\n    const val USER_EMAIL_KEY = \"user_email\"\n    const val USER_DISPLAY_NAME_KEY = \"user_displayName\"\n    const val USER_PHOTO_URL_KEY = \"user_photoUrl\"\n  }\n\n  private val managerScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)\n\n  private val _authState = MutableStateFlow(AuthState())\n  val authState: StateFlow<AuthState> = _authState.asStateFlow()\n\n  private val _authEvents = MutableSharedFlow<AuthEvent>()\n  val authEvents: SharedFlow<AuthEvent> = _authEvents.asSharedFlow()\n\n  // --- Google Sign-In Клиент ---\n  private val credentialManager: CredentialManager = CredentialManager.create(context)\n  private val authorizationClient: AuthorizationClient = Identity.getAuthorizationClient(context)\n\n  private var pendingIdToken: String? = null\n\n  init {\n    Log.d(TAG, \"Initializing AuthManager with Credential Manager...\")\n    restoreStateFromStorage()\n  }\n\n  private fun restoreStateFromStorage() {\n    try {\n      Log.d(TAG, \"Starting state restoration from EncryptedSharedPreferences...\")\n      Log.d(TAG, \"Process ID: ${android.os.Process.myPid()}\")\n\n      val token = getBackendAuthToken()\n      Log.d(\n          TAG,\n          \"Token restoration result: ${if (token != null) \"FOUND token\" else \"NO token found\"}\")\n\n      if (token != null) {\n        val email = sharedPreferences.getString(USER_EMAIL_KEY, null)\n        val displayName = sharedPreferences.getString(USER_DISPLAY_NAME_KEY, null)\n        val photoUrlString = sharedPreferences.getString(USER_PHOTO_URL_KEY, null)\n\n        Log.d(TAG, \"Restoring user data: email=$email, displayName=$displayName\")\n\n        val photoUri =\n            if (!photoUrlString.isNullOrEmpty()) {\n              photoUrlString.toUri()\n            } else {\n              null\n            }\n\n        _authState.value =\n            AuthState(\n                isSignedIn = true,\n                userEmail = email,\n                displayName = displayName,\n                photoUrl = photoUri,\n                isLoading = false,\n                authError = null)\n        Log.i(TAG, \"✅ Successfully restored session for $email from EncryptedSharedPreferences\")\n      } else {\n        Log.d(TAG, \"❌ No token found, setting signed out state\")\n        _authState.value = AuthState(isLoading = false)\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception during state restoration from EncryptedSharedPreferences\", e)\n      _authState.value = AuthState(isLoading = false, authError = \"Failed to restore session\")\n    }\n  }\n\n  fun signIn(activity: Activity) {\n    managerScope.launch {\n      _authState.update { it.copy(isLoading = true, authError = null) }\n      try {\n        val googleIdOption = buildGoogleIdOption(filterByAuthorizedAccounts = false)\n        val request = GetCredentialRequest.Builder().addCredentialOption(googleIdOption).build()\n        val result = credentialManager.getCredential(activity, request)\n        handleAuthenticationSuccess(result)\n      } catch (e: GetCredentialException) {\n        Log.w(TAG, \"GetCredentialException: ${e.message}\", e)\n        _authState.update { it.copy(isLoading = false, authError = \"Вход был отменен.\") }\n      } catch (e: Exception) {\n        Log.e(TAG, \"Unknown error during sign-in\", e)\n        _authState.update {\n          it.copy(isLoading = false, authError = \"Произошла неизвестная ошибка.\")\n        }\n      }\n    }\n  }\n\n  private suspend fun handleAuthenticationSuccess(result: GetCredentialResponse) {\n    val credential = result.credential\n    if (credential is CustomCredential &&\n        credential.type == GoogleIdTokenCredential.TYPE_GOOGLE_ID_TOKEN_CREDENTIAL) {\n      try {\n        val googleIdTokenCredential = GoogleIdTokenCredential.createFrom(credential.data)\n        val idToken = googleIdTokenCredential.idToken\n        val userEmail = googleIdTokenCredential.id\n        val displayName = googleIdTokenCredential.displayName\n        val photoUrl = googleIdTokenCredential.profilePictureUri?.toString()\n        saveUserInfo(userEmail, displayName, photoUrl)\n        Log.i(TAG, \"Authentication Success! Email: ${googleIdTokenCredential.id}\")\n\n        this.pendingIdToken = idToken\n        _authState.update {\n          it.copy(\n              isLoading = true,\n              userEmail = googleIdTokenCredential.id,\n              displayName = googleIdTokenCredential.displayName,\n              photoUrl = googleIdTokenCredential.profilePictureUri,\n          )\n        }\n        requestCalendarAuthorization()\n      } catch (e: GoogleIdTokenParsingException) {\n        Log.e(TAG, \"Error parsing Google ID token\", e)\n        signOutInternally(\"Failed to process Google token\")\n      }\n    } else {\n      Log.w(TAG, \"Received an unexpected credential type: ${credential.type}\")\n      signOutInternally(\"Unsupported credential type.\")\n    }\n  }\n\n  private suspend fun requestCalendarAuthorization() {\n    val requiredScopes = Scope(CalendarScopes.CALENDAR)\n    val authRequest =\n        AuthorizationRequest.builder()\n            .setRequestedScopes(listOf(requiredScopes))\n            .requestOfflineAccess(webClientId)\n            .build()\n    try {\n      val result = authorizationClient.authorize(authRequest).await()\n      if (result.hasResolution()) {\n        Log.d(TAG, \"Authorization requires user consent.\")\n        _authState.update { it.copy(authorizationIntent = result.pendingIntent) }\n      } else {\n        Log.d(TAG, \"Authorization succeeded without user consent.\")\n        val authCode = result.serverAuthCode\n        if (authCode != null) {\n          handleAuthorizationSuccess(authCode)\n        } else {\n          Log.e(TAG, \"Authorization failed with no serverAuthCode.\")\n          signOutInternally(\"Authorization failed with no serverAuthCode.\")\n        }\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"Error during authorization\", e)\n      signOutInternally(\"Error during authorization\")\n    }\n  }\n\n  fun handleAuthorizationResult(intent: Intent) {\n    managerScope.launch {\n      val authorizationResult = authorizationClient.getAuthorizationResultFromIntent(intent)\n      val authCode = authorizationResult.serverAuthCode\n      if (authCode != null) {\n        Log.i(TAG, \"User granted permissions successfully.\")\n        handleAuthorizationSuccess(authCode)\n      } else {\n        Log.w(TAG, \"User denied permissions or an error occurred.\")\n        signOutInternally(\"Calendar permission is required to continue.\")\n      }\n      _authState.update { it.copy(authorizationIntent = null) }\n    }\n  }\n\n  private suspend fun handleAuthorizationSuccess(authCode: String) {\n    val idToken = pendingIdToken\n    if (idToken == null) {\n      Log.e(TAG, \"No pending ID token found for authorization.\")\n      signOutInternally(\"No pending ID token found for authorization.\")\n      return\n    }\n    Log.d(TAG, \"Sending authorization code to backend...\")\n    val exchangeSuccess = sendAuthInfoToBackend(idToken, authCode)\n\n    if (exchangeSuccess) {\n      Log.i(TAG, \"Successfully exchanged tokens with backend.\")\n      _authState.update {\n        it.copy(\n            isSignedIn = true,\n            isLoading = false,\n            authError = null,\n        )\n      }\n      pendingIdToken = null\n    } else {\n      Log.e(TAG, \"Failed to exchange tokens with backend.\")\n      signOutInternally(\"Server could not verify your session.\")\n    }\n  }\n\n  fun signOut() {\n    managerScope.launch {\n      _authState.update { it.copy(isLoading = true) }\n      try {\n        credentialManager.clearCredentialState(ClearCredentialStateRequest())\n        Log.i(TAG, \"Successfully cleared credentials.\")\n      } catch (e: Exception) {\n        Log.e(TAG, \"Error clearing credentials\", e)\n      } finally {\n        _authEvents.emit(AuthEvent.SignedOut)\n        signOutInternally(\"You have been signed out.\")\n      }\n    }\n  }\n\n  private fun signOutInternally(error: String?) {\n    clearBackendToken()\n    clearUserInfo()\n    pendingIdToken = null\n    _authState.value = AuthState(isSignedIn = false, isLoading = false, authError = error)\n    Log.i(TAG, \"Internal sign out completed. Error: $error\")\n  }\n\n  private fun buildGoogleIdOption(\n      filterByAuthorizedAccounts: Boolean,\n      autoSelect: Boolean = false,\n  ): GetGoogleIdOption {\n    return GetGoogleIdOption.Builder()\n        .setFilterByAuthorizedAccounts(filterByAuthorizedAccounts)\n        .setServerClientId(webClientId)\n        .setAutoSelectEnabled(autoSelect)\n        .setNonce(generateNonce())\n        .build()\n  }\n\n  private fun generateNonce(): String {\n    return UUID.randomUUID().toString() // В проде можно другой\n  }\n\n  fun clearAuthError() {\n    _authState.update { it.copy(authError = null) }\n  }\n\n  fun clearAuthorizationIntent() {\n    _authState.update { it.copy(authorizationIntent = null) }\n  }\n\n  @WorkerThread\n  private suspend fun sendAuthInfoToBackend(idToken: String, authCode: String): Boolean =\n      withContext(Dispatchers.IO) {\n        Log.i(TAG, \"Sending Auth Info (JSON) to /auth/google/exchange\")\n        val jsonObject =\n            JSONObject().apply {\n              put(\"id_token\", idToken)\n              put(\"auth_code\", authCode)\n            }\n        val requestBody =\n            jsonObject.toString().toRequestBody(\"application/json; charset=utf-8\".toMediaType())\n        val request =\n            Request.Builder().url(\"$backendBaseUrl/auth/google/exchange\").post(requestBody).build()\n\n        try {\n          okHttpClient.newCall(request).execute().use { response ->\n            val responseBodyString = response.body?.string()\n            if (!response.isSuccessful) {\n              Log.e(TAG, \"Backend error exchanging code: ${response.code} - $responseBodyString\")\n              false\n            } else {\n              Log.i(TAG, \"Backend successfully exchanged tokens. Response: $responseBodyString\")\n              // ----- НОВАЯ ЛОГИКА: ИЗВЛЕКАЕМ И СОХРАНЯЕМ ТОКЕН -----\n              try {\n                val jsonResponse = responseBodyString?.let { JSONObject(it) }\n                val backendToken = jsonResponse?.optString(\"token\", null.toString())\n                if (backendToken != null) { // Доп. проверка на строку \"null\" на всякий случай\n                  saveBackendToken(backendToken)\n                  true // Успех\n                } else {\n                  Log.e(\n                      TAG, \"Backend response is successful, but 'token' field is missing or null.\")\n                  false\n                }\n              } catch (e: JSONException) {\n                Log.e(TAG, \"Failed to parse backend token response.\", e)\n                false\n              }\n            }\n          }\n        } catch (e: Exception) {\n          Log.e(TAG, \"Error processing backend response for auth exchange\", e)\n          false\n        }\n      }\n\n  fun getBackendAuthToken(): String? {\n    return try {\n      Log.d(TAG, \"Attempting to retrieve backend token with key: '$BACKEND_TOKEN_KEY'\")\n\n      val token = sharedPreferences.getString(BACKEND_TOKEN_KEY, null)\n\n      if (token != null) {\n        Log.d(TAG, \"✅ Backend token FOUND in EncryptedSharedPreferences (length: ${token.length})\")\n        Log.d(TAG, \"Token preview: ${token.take(20)}...\")\n      } else {\n        Log.w(TAG, \"❌ Backend token NOT FOUND in EncryptedSharedPreferences\")\n\n        // Дополнительная диагностика\n        val hasKey = sharedPreferences.contains(BACKEND_TOKEN_KEY)\n        Log.d(TAG, \"Key '$BACKEND_TOKEN_KEY' exists in preferences: $hasKey\")\n\n        // Проверим все ключи\n        val allKeys = sharedPreferences.all.keys\n        Log.d(TAG, \"All keys in EncryptedSharedPreferences: $allKeys\")\n      }\n\n      token\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while retrieving backend token from EncryptedSharedPreferences\", e)\n      null\n    }\n  }\n\n  private fun saveBackendToken(token: String) {\n    try {\n      Log.d(TAG, \"Attempting to save backend token with key: '$BACKEND_TOKEN_KEY'\")\n\n      val success = sharedPreferences.edit().putString(BACKEND_TOKEN_KEY, token).commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ Backend token saved successfully to EncryptedSharedPreferences\")\n\n        // Проверяем, что токен действительно сохранился\n        val savedToken = sharedPreferences.getString(BACKEND_TOKEN_KEY, null)\n        if (savedToken == token) {\n          Log.d(TAG, \"✅ Token verification successful - token matches\")\n        } else {\n          Log.e(\n              TAG,\n              \"❌ Token verification FAILED! Expected: ${token.take(20)}..., Got: ${savedToken?.take(20) ?: \"null\"}\")\n        }\n      } else {\n        Log.e(TAG, \"❌ Failed to save backend token - commit() returned false\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while saving backend token to EncryptedSharedPreferences\", e)\n    }\n  }\n\n  private fun clearBackendToken() {\n    try {\n      Log.d(TAG, \"Clearing backend token with key: '$BACKEND_TOKEN_KEY'\")\n      val success = sharedPreferences.edit().remove(BACKEND_TOKEN_KEY).commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ Backend token cleared successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to clear backend token\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while clearing backend token\", e)\n    }\n  }\n\n  private fun saveUserInfo(email: String?, displayName: String?, photoUrl: String?) {\n    try {\n      Log.d(TAG, \"Saving user info to EncryptedSharedPreferences...\")\n\n      val success =\n          sharedPreferences\n              .edit()\n              .putString(USER_EMAIL_KEY, email)\n              .putString(USER_DISPLAY_NAME_KEY, displayName)\n              .putString(USER_PHOTO_URL_KEY, photoUrl)\n              .commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ User info saved successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to save user info\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while saving user info to EncryptedSharedPreferences\", e)\n    }\n  }\n\n  private fun clearUserInfo() {\n    try {\n      val success =\n          sharedPreferences\n              .edit()\n              .remove(USER_EMAIL_KEY)\n              .remove(USER_DISPLAY_NAME_KEY)\n              .remove(USER_PHOTO_URL_KEY)\n              .commit()\n\n      if (success) {\n        Log.d(TAG, \"✅ User info cleared successfully\")\n      } else {\n        Log.e(TAG, \"❌ Failed to clear user info\")\n      }\n    } catch (e: Exception) {\n      Log.e(TAG, \"❌ Exception while clearing user info\", e)\n    }\n  }\n}\n\n\nsealed class AuthEvent {\n  object SignedOut : AuthEvent()\n}",
      "info": {
        "size": 17332,
        "last_modified": "2025-08-06T08:35:04.090435",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/auth/AuthState.kt",
      "content": "package com.lpavs.caliinda.core.data.auth\n\nimport android.app.PendingIntent\nimport android.net.Uri\n\ndata class AuthState(\n    val isSignedIn: Boolean = false,\n    val userEmail: String? = null,\n    val authError: String? = null,\n    val isLoading: Boolean = false,\n    val displayName: String? = null,\n    val photoUrl: Uri? = null,\n    val authorizationIntent: PendingIntent? = null\n)\n",
      "info": {
        "size": 386,
        "last_modified": "2025-08-06T08:35:04.093918",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/utils/Resources.kt",
      "content": "package com.lpavs.caliinda.core.data.utils\n\nimport android.content.Context\nimport androidx.annotation.PluralsRes\nimport androidx.annotation.StringRes\n\nsealed class UiText {\n  data class DynamicString(val value: String) : UiText()\n\n  data class StringResource(@StringRes val resId: Int, val formatArgs: List<Any> = emptyList()) :\n      UiText()\n\n  data class PluralsResource(\n      @PluralsRes val resId: Int,\n      val quantity: Int,\n      val formatArgs: List<Any> = emptyList()\n  ) : UiText()\n\n  object Empty : UiText()\n\n  fun asString(context: Context): String {\n    return when (this) {\n      is DynamicString -> value\n      is StringResource -> {\n        if (formatArgs.isEmpty()) {\n          context.getString(resId)\n        } else {\n          context.getString(resId, *formatArgs.toTypedArray())\n        }\n      }\n      is PluralsResource -> {\n        if (formatArgs.isEmpty()) {\n          context.resources.getQuantityString(resId, quantity)\n        } else {\n          context.resources.getQuantityString(resId, quantity, *formatArgs.toTypedArray())\n        }\n      }\n      is Empty -> \"\"\n    }\n  }\n\n  companion object {\n    fun from(text: String): UiText = DynamicString(text)\n\n    fun from(@StringRes resId: Int, vararg args: Any): UiText = StringResource(resId, args.toList())\n\n    fun fromPlurals(@PluralsRes resId: Int, quantity: Int, vararg args: Any): UiText =\n        PluralsResource(resId, quantity, args.toList())\n\n    fun empty(): UiText = Empty\n  }\n}\n",
      "info": {
        "size": 1471,
        "last_modified": "2025-08-06T08:35:04.096711",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/local/CalendarLocalDataSource.kt",
      "content": "package com.lpavs.caliinda.core.data.local\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport com.lpavs.caliinda.core.data.repository.CalendarEventEntity\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface CalendarLocalDataSource {\n\n  /**\n   * Получает поток списка событий, время начала которых попадает в указанный диапазон миллисекунд\n   * UTC. Возвращает Flow для автоматического обновления UI.\n   *\n   * @param startRangeMillis Начало диапазона (включительно)\n   * @param endRangeMillis Конец диапазона (не включительно)\n   */\n  @Query(\n      \"SELECT * FROM calendar_events WHERE startTimeMillis >= :startRangeMillis AND startTimeMillis < :endRangeMillis ORDER BY startTimeMillis ASC\")\n  fun getEventsForDateRangeFlow(\n      startRangeMillis: Long,\n      endRangeMillis: Long\n  ): Flow<List<CalendarEventEntity>>\n\n  /** Вставляет список событий. Если событие с таким же ID уже существует, оно будет заменено. */\n  @Insert(onConflict = OnConflictStrategy.REPLACE)\n  suspend fun insertOrReplaceEvents(events: List<CalendarEventEntity>)\n\n  /**\n   * Удаляет все события, время начала которых попадает в указанный диапазон. Используется перед\n   * вставкой свежих данных для этого диапазона, чтобы удалить события, которых больше нет на\n   * сервере.\n   *\n   * @param startRangeMillis Начало диапазона (включительно)\n   * @param endRangeMillis Конец диапазона (не включительно)\n   */\n  @Query(\n      \"DELETE FROM calendar_events WHERE startTimeMillis >= :startRangeMillis AND startTimeMillis < :endRangeMillis\")\n  suspend fun deleteEventsForDateRange(startRangeMillis: Long, endRangeMillis: Long)\n\n  /**\n   * Атомарно удаляет события в диапазоне и вставляет новые. Гарантирует, что операции выполнятся\n   * вместе.\n   */\n  @Transaction\n  suspend fun clearAndInsertEventsForRange(\n      startRangeMillis: Long,\n      endRangeMillis: Long,\n      newEvents: List<CalendarEventEntity>\n  ) {\n    deleteEventsForDateRange(startRangeMillis, endRangeMillis)\n    insertOrReplaceEvents(newEvents)\n  }\n\n  /**\n   * Удаляет событие из локальной базы данных по его уникальному ID.\n   *\n   * @param eventId Уникальный идентификатор события (обычно строка, совпадающая с Google Calendar\n   *   event ID).\n   */\n  @Query(\"DELETE FROM calendar_events WHERE id = :eventId\")\n  suspend fun deleteEventById(eventId: String)\n\n  /** Удаляет все данные календаря из локальной базы данных. */\n  @Query(\"DELETE FROM calendar_events\") suspend fun deleteAllEvents()\n}\n",
      "info": {
        "size": 3243,
        "last_modified": "2025-08-06T08:35:04.099266",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/local/AppDatabase.kt",
      "content": "package com.lpavs.caliinda.core.data.local\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\nimport com.lpavs.caliinda.core.data.repository.CalendarEventEntity\n\n@Database(\n    entities = [CalendarEventEntity::class],\n    version = 4, // Увеличивай версию при изменении схемы\n    exportSchema = false // Установи true и укажи путь для схем в production\n    )\nabstract class AppDatabase : RoomDatabase() {\n  abstract fun eventDao(): CalendarLocalDataSource\n}\n",
      "info": {
        "size": 531,
        "last_modified": "2025-08-06T08:35:04.10126",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/dto/EventDto.kt",
      "content": "package com.lpavs.caliinda.core.data.remote.dto\n\nimport kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class EventDto(\n    val id: String,\n    val summary: String,\n    @SerialName(\"startTime\") val startTime: String?,\n    @SerialName(\"endTime\") val endTime: String?,\n    val description: String? = null,\n    val location: String? = null,\n    @SerialName(\"isAllDay\") val isAllDay: Boolean = false,\n    @SerialName(\"recurringEventId\") val recurringEventId: String? = null,\n    @SerialName(\"originalStartTime\") val originalStartTime: String? = null,\n    @SerialName(\"recurrenceRule\") val recurrenceRule: String? = null\n)\n",
      "info": {
        "size": 665,
        "last_modified": "2025-08-06T08:35:04.104219",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/dto/EventRequest.kt",
      "content": "package com.lpavs.caliinda.core.data.remote.dto\n\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class EventRequest(\n    val summary: String? = null,\n    val startTime: String? = null,\n    val endTime: String? = null,\n    val isAllDay: Boolean? = null,\n    val timeZoneId: String? = null,\n    val description: String? = null,\n    val location: String? = null,\n    val recurrence: List<String>? = null\n)\n",
      "info": {
        "size": 417,
        "last_modified": "2025-08-06T08:35:04.10644",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/CalendarApiService.kt",
      "content": "package com.lpavs.caliinda.core.data.remote\n\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport retrofit2.Response\nimport retrofit2.http.Body\nimport retrofit2.http.DELETE\nimport retrofit2.http.GET\nimport retrofit2.http.Header\nimport retrofit2.http.PATCH\nimport retrofit2.http.POST\nimport retrofit2.http.Path\nimport retrofit2.http.Query\n\ninterface CalendarApiService {\n  @GET(\"calendar/events/range\")\n  suspend fun getEventsForRange(\n      @Header(\"Authorization\") token: String,\n      @Query(\"startDate\") startDate: String,\n      @Query(\"endDate\") endDate: String\n  ): List<EventDto>\n\n  @POST(\"calendar/events\")\n  suspend fun createEvent(\n      @Header(\"Authorization\") token: String,\n      @Body event: EventRequest\n  ): Response<Unit>\n\n  @PATCH(\"calendar/events/{eventId}\")\n  suspend fun updateEvent(\n      @Header(\"Authorization\") token: String,\n      @Path(\"eventId\") eventId: String,\n      @Query(\"update_mode\") mode: String,\n      @Body updateData: EventRequest\n  ): Response<Unit>\n\n  @DELETE(\"calendar/events/{eventId}\")\n  suspend fun deleteEvent(\n      @Header(\"Authorization\") token: String,\n      @Path(\"eventId\") eventId: String,\n      @Query(\"mode\") mode: String\n  ): Response<Unit>\n}\n",
      "info": {
        "size": 1269,
        "last_modified": "2025-08-06T08:35:04.109102",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/EventUpdateMode.kt",
      "content": "package com.lpavs.caliinda.core.data.remote\n\nenum class EventUpdateMode(val value: String) {\n  SINGLE_INSTANCE(\"single_instance\"),\n  ALL_IN_SERIES(\"all_in_series\")\n}\n",
      "info": {
        "size": 166,
        "last_modified": "2025-08-06T08:35:04.110828",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/EventDeleteMode.kt",
      "content": "package com.lpavs.caliinda.core.data.remote\n\nenum class EventDeleteMode(val value: String) {\n  DEFAULT(\"default\"),\n  INSTANCE_ONLY(\"instance_only\")\n}\n",
      "info": {
        "size": 150,
        "last_modified": "2025-08-06T08:35:04.112782",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "core/data/remote/CalendarRemoteDataSource.kt",
      "content": "package com.lpavs.caliinda.core.data.remote\n\nimport android.util.Log\nimport com.lpavs.caliinda.app.di.IoDispatcher\nimport com.lpavs.caliinda.core.common.ApiException\nimport com.lpavs.caliinda.core.common.NetworkException\nimport com.lpavs.caliinda.core.common.UnknownException\nimport com.lpavs.caliinda.core.data.auth.AuthManager\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.withContext\nimport retrofit2.HttpException\nimport java.io.IOException\nimport java.time.LocalDate\nimport java.time.format.DateTimeFormatter\nimport javax.inject.Inject\n\nprivate const val TAG = \"CalendarRemoteDataSource\"\n\nclass CalendarRemoteDataSource\n@Inject\nconstructor(\n    private val apiService: CalendarApiService,\n    private val authManager: AuthManager,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher\n) {\n  private suspend inline fun <T> authenticatedApiCall(\n      crossinline apiCall: suspend (String) -> T\n  ): Result<T> {\n    val token = authManager.getBackendAuthToken()\n    return if (token != null) {\n      safeApiCall { apiCall(\"Bearer $token\") }\n    } else {\n      Log.e(TAG, \"Could not get fresh token\")\n      Result.failure(Exception(\"Could not get fresh token\"))\n    }\n  }\n\n  suspend fun getEvents(startDate: LocalDate, endDate: LocalDate): Result<List<EventDto>> {\n    Log.d(TAG, \"getEvents called with startDate: $startDate, endDate: $endDate\")\n    return authenticatedApiCall { token ->\n      Log.d(TAG, \"Fetching events from API for range: $startDate - $endDate\")\n      val events =\n          apiService.getEventsForRange(\n              token = token,\n              startDate.format(DateTimeFormatter.ISO_LOCAL_DATE),\n              endDate.format(DateTimeFormatter.ISO_LOCAL_DATE))\n      Log.d(TAG, \"getEvents successful, events count: ${events.size}\")\n      events\n    }\n  }\n\n  suspend fun createEvent(event: EventRequest): Result<Unit> {\n    Log.d(TAG, \"createEvent called with event: $event\")\n    return authenticatedApiCall { token ->\n      Log.d(TAG, \"Creating event via API: $event\")\n      apiService.createEvent(token, event)\n      Log.d(TAG, \"createEvent successful\")\n    }\n  }\n\n  suspend fun updateEvent(\n      eventId: String,\n      mode: EventUpdateMode,\n      updateData: EventRequest\n  ): Result<Unit> {\n    Log.d(TAG, \"updateEvent called with eventId: $eventId, mode: $mode, updateData: $updateData\")\n    return authenticatedApiCall { token ->\n      Log.d(TAG, \"Updating event via API: eventId=$eventId, mode=$mode, data=$updateData\")\n      val response =\n          apiService.updateEvent(\n              token,\n              eventId,\n              mode.value,\n              updateData,\n          )\n      if (response.isSuccessful) {\n        Log.d(TAG, \"updateEvent successful\")\n        Unit\n      } else {\n        Log.e(\n            TAG,\n            \"updateEvent failed: ${response.code()}, errorBody: ${response.errorBody()?.string()}\")\n        throw ApiException(response.code(), response.errorBody()?.string())\n      }\n    }\n  }\n\n  suspend fun deleteEvent(eventId: String, mode: EventDeleteMode): Result<Unit> {\n    Log.d(TAG, \"deleteEvent called with eventId: $eventId, mode: $mode\")\n    return authenticatedApiCall { token ->\n      Log.d(TAG, \"Deleting event via API: eventId=$eventId, mode=$mode\")\n      val response = apiService.deleteEvent(token, eventId, mode.value)\n      Log.d(TAG, \"deleteEvent response: $response\")\n      if (response.isSuccessful) {\n        Log.d(TAG, \"deleteEvent successful\")\n        Unit\n      } else {\n        Log.e(\n            TAG,\n            \"deleteEvent failed: ${response.code()}, errorBody: ${response.errorBody()?.string()}\")\n        throw ApiException(response.code(), response.errorBody()?.string())\n      }\n    }\n  }\n\n  private suspend fun <T> safeApiCall(apiCall: suspend () -> T): Result<T> {\n    Log.d(TAG, \"safeApiCall started\")\n    return withContext(ioDispatcher) {\n      try {\n        Log.d(TAG, \"safeApiCall executing apiCall\")\n        val result = apiCall()\n        Log.d(TAG, \"safeApiCall apiCall successful, result: $result\")\n        Result.success(result)\n      } catch (e: Throwable) {\n        Log.e(TAG, \"safeApiCall caught exception: ${e.javaClass.simpleName}\", e)\n        when (e) {\n          is IOException -> {\n            Log.e(TAG, \"safeApiCall: IOException - Network issue\", e)\n            Result.failure(NetworkException(\"Network issue: ${e.message}\"))\n          }\n          is HttpException -> {\n            val errorBody = e.response()?.errorBody()?.string()\n            Log.e(TAG, \"safeApiCall: HttpException - code: ${e.code()}, errorBody: $errorBody\", e)\n            Result.failure(ApiException(e.code(), \"Server error: ${e.code()}. $errorBody\"))\n          }\n          is ApiException -> {\n            Log.e(TAG, \"safeApiCall: ApiException - code: ${e}, message: ${e}\", e)\n            Result.failure(e)\n          }\n          else -> {\n            Log.e(TAG, \"safeApiCall: UnknownException - message: ${e.message}\", e)\n            Result.failure(UnknownException(\"Unknown error: ${e.message}\"))\n          }\n        }\n      }\n    }\n  }\n}\n",
      "info": {
        "size": 5179,
        "last_modified": "2025-08-06T08:35:04.114561",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "app/CaliindaApplication.kt",
      "content": "package com.lpavs.caliinda.app\n\nimport android.app.Application\nimport com.lpavs.caliinda.feature.calendar.ui.components.FunMessages\nimport dagger.hilt.android.HiltAndroidApp\n\n@HiltAndroidApp\nclass CaliindaApplication : Application() {\n  override fun onCreate() {\n    super.onCreate()\n    FunMessages.resetSession()\n  }\n}\n",
      "info": {
        "size": 321,
        "last_modified": "2025-08-06T08:35:04.118804",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "app/MainActivity.kt",
      "content": "package com.lpavs.caliinda.app\n\n// Android Framework Imports\n\n// Android Resources\n\n// AndroidX Imports\n// AndroidX Compose\n\n// Accompanist\n\n// Google APIs and Services\n\n// Kotlin Coroutines\n\n// Other Libraries\n\n// Project-Specific Imports\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.background\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.ui.Modifier\nimport com.lpavs.caliinda.core.ui.theme.CaliindaTheme\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.navigation.AppNavHost\nimport dagger.hilt.android.AndroidEntryPoint\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n  private val calendarViewModel: CalendarViewModel by viewModels()\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    enableEdgeToEdge()\n    super.onCreate(savedInstanceState)\n\n    setContent {\n      CaliindaTheme {\n        AppNavHost(\n            viewModel = calendarViewModel,\n            modifier = Modifier.background(colorScheme.background),\n        )\n      }\n    }\n  }\n\n  override fun onResume() {\n    super.onResume()\n    calendarViewModel.refreshCurrentVisibleDate()\n  }\n}\n",
      "info": {
        "size": 1337,
        "last_modified": "2025-08-06T08:35:04.120786",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "app/di/DispatchersModule.kt",
      "content": "package com.lpavs.caliinda.app.di\n\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.Dispatchers\nimport javax.inject.Qualifier\nimport javax.inject.Singleton\n\n// Квалификатор для IO Dispatcher\n@Retention(AnnotationRetention.BINARY) @Qualifier annotation class IoDispatcher\n\n@Retention(AnnotationRetention.BINARY) @Qualifier annotation class MainDispatcher\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject DispatchersModule {\n\n  @Provides @Singleton @IoDispatcher fun provideIoDispatcher(): CoroutineDispatcher = Dispatchers.IO\n\n  @Provides\n  @Singleton\n  @MainDispatcher\n  fun provideMainDispatcher(): CoroutineDispatcher = Dispatchers.Main\n}\n",
      "info": {
        "size": 806,
        "last_modified": "2025-08-06T08:35:04.122466",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "app/di/AppConfigModule.kt",
      "content": "package com.lpavs.caliinda.app.di\n\nimport com.lpavs.caliinda.BuildConfig\nimport com.lpavs.caliinda.core.data.di.BackendUrl\nimport com.lpavs.caliinda.core.data.di.WebClientId\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class) // Предоставляем как синглтоны на уровне приложения\nobject AppConfigModule {\n\n  @Provides\n  @Singleton // Эти значения не меняются во время работы приложения\n  @BackendUrl // Используем квалификатор\n  fun provideBackendBaseUrl(): String {\n    return BuildConfig.BACKEND_BASE_URL\n  }\n\n  @Provides\n  @Singleton\n  @WebClientId // Используем квалификатор\n  fun provideWebClientId(): String {\n    // Убедитесь, что вы запросили serverAuthCode и idToken с правильным ID\n    return BuildConfig.BACKEND_WEB_CLIENT_ID\n  }\n}\n",
      "info": {
        "size": 1054,
        "last_modified": "2025-08-06T08:35:04.124153",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "navigation/AppNavHost.kt",
      "content": "package com.lpavs.caliinda.navigation\n\nimport android.app.Activity\nimport android.util.Log\nimport androidx.compose.animation.core.EaseIn\nimport androidx.compose.animation.core.EaseOut\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.slideInHorizontally\nimport androidx.compose.animation.slideOutHorizontally\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.compose.rememberNavController\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarScreen\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport com.lpavs.caliinda.feature.settings.ui.AISettingsScreen\nimport com.lpavs.caliinda.feature.settings.ui.SettingsScreen\nimport com.lpavs.caliinda.feature.settings.ui.TermsOfUseScreen\nimport com.lpavs.caliinda.feature.settings.ui.TimeSettingsScreen\nimport com.lpavs.caliinda.feature.settings.vm.SettingsViewModel\n\n@Composable\nfun AppNavHost(\n    modifier: Modifier = Modifier,\n    navController: NavHostController = rememberNavController(),\n    viewModel: CalendarViewModel,\n) {\n  val context = LocalContext.current\n  val activity = context as? Activity\n\n  val onSignInClick: () -> Unit = {\n    if (activity != null) {\n      viewModel.signIn(activity)\n    } else {\n      Log.e(\"AppNavHost\", \"Activity is null, cannot perform sign-in.\")\n    }\n  }\n  NavHost(\n      navController = navController,\n      startDestination = NavRoutes.Main.route,\n      popEnterTransition = {\n        slideInHorizontally(\n            initialOffsetX = { fullWidth -> fullWidth },\n            animationSpec = tween(durationMillis = 150, easing = EaseOut))\n      },\n      popExitTransition = {\n        slideOutHorizontally(\n            targetOffsetX = { fullWidth -> fullWidth },\n            animationSpec = tween(durationMillis = 150, easing = EaseIn))\n      },\n      enterTransition = {\n        slideInHorizontally(initialOffsetX = { it }, animationSpec = tween(200))\n      },\n      modifier = modifier,\n  ) {\n    composable(\n        NavRoutes.Main.route,\n    ) {\n      val eventManagementViewModel: EventManagementViewModel = hiltViewModel()\n      CalendarScreen(\n          calendarViewModel = viewModel,\n          onNavigateToSettings = { navController.navigate(NavRoutes.Settings.route) },\n          eventManagementViewModel = eventManagementViewModel)\n    }\n    composable(\n        NavRoutes.Settings.route,\n    ) {\n      val eventManagementViewModel: EventManagementViewModel = hiltViewModel()\n      SettingsScreen(\n          calendarViewModel = viewModel,\n          eventManagementViewModel = eventManagementViewModel,\n          onSignInClick = onSignInClick,\n          onNavigateBack = { navController.popBackStack() },\n          onNavigateToAISettings = { navController.navigate(NavRoutes.AISettings.route) },\n          onNavigateToTimeSettings = { navController.navigate(NavRoutes.TimeSettings.route) },\n          onNavigateToTermsOfuse = { navController.navigate(NavRoutes.Terms.route) })\n    }\n    composable(\n        NavRoutes.AISettings.route,\n    ) {\n      val settingsViewModel: SettingsViewModel = hiltViewModel()\n      AISettingsScreen(\n          viewModel = settingsViewModel, onNavigateBack = { navController.popBackStack() })\n    }\n    composable(\n        NavRoutes.TimeSettings.route,\n    ) {\n      val settingsViewModel: SettingsViewModel = hiltViewModel()\n      TimeSettingsScreen(\n          viewModel = settingsViewModel,\n          onNavigateBack = { navController.popBackStack() },\n          title = \"Time & Format\")\n    }\n    composable(\n        NavRoutes.Terms.route,\n    ) {\n      TermsOfUseScreen(onNavigateBack = { navController.popBackStack() }, title = \"Terms of Use\")\n    }\n  }\n}\n",
      "info": {
        "size": 4007,
        "last_modified": "2025-08-06T08:35:04.129581",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "navigation/NavRoutes.kt",
      "content": "package com.lpavs.caliinda.navigation\n\nsealed class NavRoutes(val route: String) {\n  object Main : NavRoutes(\"main\")\n\n  object Settings : NavRoutes(\"settings\")\n\n  object AISettings : NavRoutes(\"aiSettings\")\n\n  object TimeSettings : NavRoutes(\"timeSettings\")\n\n  object Terms : NavRoutes(\"termsOfUse\")\n}\n",
      "info": {
        "size": 302,
        "last_modified": "2025-08-06T08:35:04.132426",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/ui/AgentSettingsScreen.kt",
      "content": "package com.lpavs.caliinda.feature.settings.ui\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardActions\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.rounded.Check\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.platform.LocalSoftwareKeyboardController\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.input.ImeAction\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.settings.vm.SettingsViewModel\nimport kotlinx.coroutines.launch\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun AISettingsScreen(\n    viewModel: SettingsViewModel,\n    onNavigateBack: () -> Unit,\n) {\n  val snackbarHostState = remember { SnackbarHostState() }\n  val currentTemper by viewModel.botTemperState.collectAsStateWithLifecycle()\n  var temperInputState by remember(currentTemper) { mutableStateOf(currentTemper) }\n  val keyboardController = LocalSoftwareKeyboardController.current\n  val scope = rememberCoroutineScope()\n\n  Scaffold(\n      snackbarHost = { SnackbarHost(snackbarHostState) },\n      topBar = {\n        TopAppBar(\n            title = { Text(stringResource(R.string.aisettings)) },\n            navigationIcon = {\n              IconButton(onClick = onNavigateBack) {\n                Icon(\n                    Icons.AutoMirrored.Filled.ArrowBack,\n                    contentDescription = stringResource(R.string.back))\n              }\n            })\n      }) { paddingValues ->\n        Column(\n            modifier =\n                Modifier.padding(paddingValues)\n                    .padding(16.dp) // Дополнительные отступы для контента\n                    .fillMaxWidth() // Занимаем всю ширину\n            ) {\n              Box(\n                  modifier =\n                      Modifier.fillMaxWidth()\n                          .clip(RoundedCornerShape(cuid.SettingsItemCornerRadius))\n                          .background(color = colorScheme.surfaceContainer)\n                          .padding(16.dp)) {\n                    Column {\n                      Text(stringResource(R.string.temper_ai), style = typography.titleMedium)\n                      Spacer(modifier = Modifier.height(8.dp))\n                      Row(verticalAlignment = Alignment.CenterVertically) {\n                        OutlinedTextField(\n                            value = temperInputState,\n                            onValueChange = { temperInputState = it },\n                            placeholder = { Text(stringResource(R.string.temper_example)) },\n                            modifier = Modifier.weight(1f).padding(end = 8.dp),\n                            maxLines = 5,\n                            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),\n                            keyboardActions =\n                                KeyboardActions(onDone = { keyboardController?.hide() }),\n                            shape = RoundedCornerShape(cuid.SettingsItemCornerRadius))\n                        Button(\n                            onClick = {\n                              if (temperInputState != currentTemper) {\n                                viewModel.updateBotTemperSetting(temperInputState)\n                                scope.launch {\n                                  snackbarHostState.showSnackbar(R.string.temper_saved.toString())\n                                }\n                              }\n                            },\n                            enabled = temperInputState != currentTemper,\n                            shape = CircleShape,\n                            modifier = Modifier.size(48.dp),\n                            contentPadding = PaddingValues(0.dp)) {\n                              Icon(\n                                  imageVector = Icons.Rounded.Check,\n                                  contentDescription = stringResource(R.string.save),\n                                  modifier = Modifier.size(24.dp) // размер иконки внутри\n                                  )\n                            }\n                      }\n                    }\n                  }\n            }\n      }\n}\n",
      "info": {
        "size": 5979,
        "last_modified": "2025-08-06T08:35:04.136028",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/ui/LogInDialog.kt",
      "content": "package com.lpavs.caliinda.feature.settings.ui\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.wrapContentHeight\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonColors\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.MaterialShapes\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.toShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.rotate\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.window.Dialog\nimport androidx.compose.ui.window.DialogProperties\nimport com.lpavs.caliinda.R\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun LogInScreenDialog(\n    onDismissRequest: () -> Unit,\n    onSignInClick: () -> Unit,\n) {\n\n  Dialog(\n      onDismissRequest = { onDismissRequest() }, // ,\n      properties =\n          DialogProperties(\n              dismissOnBackPress = true,\n              dismissOnClickOutside = true,\n              usePlatformDefaultWidth = false)) {\n        Surface(\n            modifier = Modifier.fillMaxWidth(0.9f).wrapContentHeight(),\n            shape = RoundedCornerShape(25.dp),\n            color = colorScheme.primaryContainer,\n            tonalElevation = 8.dp) {\n              val onDialog = colorScheme.onPrimaryContainer\n              Box(modifier = Modifier.fillMaxWidth()) {\n                val shape1 = MaterialShapes.Flower.toShape()\n                val shape2 = MaterialShapes.Cookie12Sided.toShape()\n                Box(\n                    modifier =\n                        Modifier.align(Alignment.BottomEnd)\n                            .size(250.dp)\n                            .rotate(75f)\n                            .offset(y = (-50).dp, x = 50.dp)\n                            .clip(shape1)\n                            .border(\n                                width = 2.dp, color = onDialog.copy(alpha = 0.2f), shape = shape1)\n                            .background(onDialog.copy(alpha = 0f)))\n                Box(\n                    modifier =\n                        Modifier.align(Alignment.TopStart)\n                            .size(250.dp)\n                            .offset(y = (-100).dp, x = (-80).dp)\n                            .rotate(30f)\n                            .clip(shape2)\n                            .border(\n                                width = 2.dp, color = onDialog.copy(alpha = 0.2f), shape = shape2)\n                            .background(onDialog.copy(alpha = 0f)))\n                Column(\n                    modifier =\n                        Modifier.padding(top = 24.dp, start = 24.dp, end = 24.dp, bottom = 12.dp),\n                    horizontalAlignment = Alignment.Start) {\n                      Text(\n                          text = stringResource(R.string.app_name),\n                          style = typography.displaySmall.copy(fontWeight = FontWeight.SemiBold),\n                          color = onDialog)\n                      Spacer(modifier = Modifier.height(2.dp))\n                      Text(\n                          text = stringResource(R.string.log_to_continue),\n                          style = typography.labelMedium.copy(fontWeight = FontWeight.SemiBold),\n                          color = onDialog)\n                      Spacer(modifier = Modifier.height(50.dp))\n                      Row(\n                          modifier = Modifier.fillMaxWidth(),\n                          verticalAlignment = Alignment.Bottom,\n                          horizontalArrangement = Arrangement.Center) {\n                            val expandedSize = ButtonDefaults.MediumContainerHeight\n                            Button(\n                                onClick = { onSignInClick() },\n                                colors =\n                                    ButtonColors(\n                                        contentColor = colorScheme.onTertiary,\n                                        containerColor = colorScheme.tertiary,\n                                        disabledContentColor = colorScheme.inverseSurface,\n                                        disabledContainerColor = colorScheme.inverseSurface),\n                                modifier = Modifier.heightIn(expandedSize),\n                                contentPadding = ButtonDefaults.contentPaddingFor(expandedSize)) {\n                                  Text(\n                                      text = stringResource(R.string.google_login),\n                                      style = ButtonDefaults.textStyleFor(expandedSize))\n                                }\n                          }\n                    }\n              }\n            }\n      }\n}\n\n@Preview(showBackground = true) @Composable fun IconAndTextButtonGroupScreenPreview() {}\n",
      "info": {
        "size": 5935,
        "last_modified": "2025-08-06T08:35:04.138302",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/ui/SettingsScreen.kt",
      "content": "package com.lpavs.caliinda.feature.settings.ui\n\nimport android.net.Uri\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.automirrored.rounded.Logout\nimport androidx.compose.material.icons.rounded.AccessTimeFilled\nimport androidx.compose.material.icons.rounded.AccountCircle\nimport androidx.compose.material.icons.rounded.Error\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialShapes\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.material3.toShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.vector.rememberVectorPainter\nimport androidx.compose.ui.layout.ContentScale\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport coil3.compose.AsyncImage\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun SettingsScreen(\n    calendarViewModel: CalendarViewModel,\n    eventManagementViewModel: EventManagementViewModel,\n    onSignInClick: () -> Unit,\n    onNavigateBack: () -> Unit,\n    onNavigateToAISettings: () -> Unit,\n    onNavigateToTimeSettings: () -> Unit,\n    onNavigateToTermsOfuse: () -> Unit\n) {\n  val calendarState by calendarViewModel.state.collectAsStateWithLifecycle()\n  val snackbarHostState = remember { SnackbarHostState() }\n  val eventManagementState by eventManagementViewModel.uiState.collectAsState()\n\n  val isOverallLoading = calendarState.isLoading || eventManagementState.isLoading\n\n  Scaffold(\n      snackbarHost = { SnackbarHost(snackbarHostState) },\n      topBar = {\n        TopAppBar(\n            title = { Text(stringResource(R.string.settings)) },\n            navigationIcon = {\n              IconButton(onClick = onNavigateBack) {\n                Icon(\n                    Icons.AutoMirrored.Filled.ArrowBack,\n                    contentDescription = stringResource(R.string.back))\n              }\n            })\n      }) { paddingValues ->\n        Column(\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier.padding(paddingValues).padding(16.dp).fillMaxWidth()) {\n              if (isOverallLoading && !calendarState.isSignedIn) {\n                LoadingIndicator()\n                Spacer(modifier = Modifier.height(16.dp))\n              }\n              GoogleAccountSection(\n                  calendarViewModel = calendarViewModel,\n                  eventManagementViewModel = eventManagementViewModel,\n                  onSignInClick = onSignInClick,\n              )\n\n              Spacer(modifier = Modifier.height(10.dp))\n\n              SettingsItem(\n                  icon = {\n                    Icon(\n                        painter = painterResource(id = R.drawable.ar_sticker),\n                        tint = colorScheme.onPrimaryContainer,\n                        contentDescription = stringResource(R.string.ai))\n                  },\n                  title = stringResource(R.string.aisettings),\n                  onClick = onNavigateToAISettings,\n                  shape = MaterialShapes.Clover4Leaf.toShape())\n\n              Spacer(modifier = Modifier.height(10.dp))\n\n              SettingsItem(\n                  icon = {\n                    Icon(\n                        Icons.Rounded.AccessTimeFilled,\n                        tint = colorScheme.onPrimaryContainer,\n                        contentDescription = stringResource(R.string.time))\n                  },\n                  title = stringResource(R.string.time_format),\n                  onClick = onNavigateToTimeSettings,\n                  shape = MaterialShapes.Pill.toShape())\n\n              Spacer(modifier = Modifier.height(10.dp))\n\n              SettingsItem(\n                  icon = {\n                    Icon(\n                        painter = painterResource(id = R.drawable.doc),\n                        tint = colorScheme.onPrimaryContainer,\n                        contentDescription = stringResource(R.string.terms))\n                  },\n                  title = stringResource(R.string.terms_of_use),\n                  onClick = onNavigateToTermsOfuse,\n                  shape = MaterialShapes.Bun.toShape())\n            }\n      }\n}\n\n@Composable\nfun SettingsItem(icon: @Composable () -> Unit, title: String, onClick: () -> Unit, shape: Shape) {\n  val cornerRadius = cuid.SettingsItemCornerRadius\n  Box(\n      modifier =\n          Modifier.fillMaxWidth()\n              .clip(RoundedCornerShape(cornerRadius))\n              .background(color = colorScheme.surfaceContainer)\n              .height(60.dp)\n              .clickable(onClick = onClick)) {\n        Box(\n            modifier =\n                Modifier.align(Alignment.CenterStart)\n                    .padding(start = 16.dp)\n                    .clip(shape)\n                    .size(40.dp)\n                    .background(color = colorScheme.primaryContainer),\n            contentAlignment = Alignment.Center) {\n              icon()\n            }\n        Text(text = title, modifier = Modifier.padding(16.dp).align(Alignment.Center))\n      }\n}\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun GoogleAccountSection(\n    calendarViewModel: CalendarViewModel,\n    eventManagementViewModel: EventManagementViewModel,\n    onSignInClick: () -> Unit,\n) {\n  val calendarState by calendarViewModel.state.collectAsStateWithLifecycle()\n  val email = calendarState.userEmail ?: stringResource(R.string.loginplease)\n  val displayName = calendarState.displayName ?: email.substringBefore(\"@\")\n  val photo: Uri? = calendarState.photo\n  val cornerRadius = cuid.SettingsItemCornerRadius\n  val eventManagementState by eventManagementViewModel.uiState.collectAsState()\n  val isOverallLoading = calendarState.isLoading || eventManagementState.isLoading\n  Box(\n      modifier =\n          Modifier.fillMaxWidth()\n              .clip(RoundedCornerShape(cornerRadius))\n              .background(color = colorScheme.surfaceContainer)\n              .height(120.dp)) {\n        Row(\n            modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp),\n            verticalAlignment = Alignment.CenterVertically) {\n              Box(\n                  modifier =\n                      Modifier.size(80.dp)\n                          .clip(\n                              if (photo == null) MaterialShapes.Circle.toShape()\n                              else MaterialShapes.Cookie7Sided.toShape())\n                          .background(color = colorScheme.primaryContainer),\n                  contentAlignment = Alignment.Center) {\n                    if (photo == null) {\n                      Icon(\n                          Icons.Rounded.AccountCircle,\n                          tint = colorScheme.onPrimaryContainer,\n                          contentDescription = stringResource(R.string.account),\n                          modifier = Modifier.size(40.dp))\n                    } else {\n                      AsyncImage(\n                          modifier = Modifier.fillMaxSize(),\n                          model = photo,\n                          contentDescription = stringResource(R.string.account),\n                          contentScale = ContentScale.Fit,\n                          placeholder = rememberVectorPainter(image = Icons.Rounded.AccountCircle),\n                          error = rememberVectorPainter(image = Icons.Rounded.Error),\n                      )\n                    }\n                  }\n              Spacer(modifier = Modifier.width(16.dp))\n              Box(modifier = Modifier.width(130.dp)) {\n                Text(text = displayName, style = MaterialTheme.typography.bodyLarge, maxLines = 2)\n              }\n              Spacer(Modifier.weight(1f))\n              Box(modifier = Modifier.padding(6.dp)) {\n                Box {\n                  if (!calendarState.isSignedIn) {\n                    Button(\n                        onClick = onSignInClick, // Вызываем лямбду\n                    ) {\n                      Text(stringResource(R.string.login))\n                    }\n                  } else {\n                    Button(onClick = { calendarViewModel.signOut() }, enabled = !isOverallLoading) {\n                      Icon(\n                          Icons.AutoMirrored.Rounded.Logout,\n                          tint = colorScheme.onPrimaryContainer,\n                          contentDescription = stringResource(R.string.account),\n                          modifier = Modifier.size(20.dp))\n                    }\n                  }\n                }\n              }\n            }\n      }\n}\n",
      "info": {
        "size": 10437,
        "last_modified": "2025-08-06T08:35:04.140092",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/ui/TermsOfUseSettings.kt",
      "content": "package com.lpavs.caliinda.feature.settings.ui\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.R\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun TermsOfUseScreen(onNavigateBack: () -> Unit, title: String) {\n  // Используем переданный viewModel\n  val snackbarHostState = remember { SnackbarHostState() }\n\n  Scaffold(\n      snackbarHost = { SnackbarHost(snackbarHostState) },\n      topBar = {\n        TopAppBar(\n            title = { Text(title) },\n            navigationIcon = {\n              IconButton(onClick = onNavigateBack) {\n                Icon(\n                    Icons.AutoMirrored.Filled.ArrowBack,\n                    contentDescription = stringResource(R.string.back))\n              }\n            })\n      }) { paddingValues ->\n        Column(\n            modifier =\n                Modifier.padding(paddingValues)\n                    .padding(16.dp) // Дополнительные отступы для контента\n                    .fillMaxWidth() // Занимаем всю ширину\n            ) {\n              // TODO: когда будут готовы вставить как-то\n              //            Text(\"ЗДЕСЬ ЕЩЕ НИЧЕГО НЕТ)\")\n            }\n      }\n}\n",
      "info": {
        "size": 2058,
        "last_modified": "2025-08-06T08:35:04.141895",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/ui/TimeSettingsScreen.kt",
      "content": "package com.lpavs.caliinda.feature.settings.ui\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExposedDropdownMenuAnchorType.Companion.PrimaryEditable\nimport androidx.compose.material3.ExposedDropdownMenuBox\nimport androidx.compose.material3.ExposedDropdownMenuDefaults\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.settings.vm.SettingsViewModel\nimport kotlinx.coroutines.launch\nimport java.time.ZoneId\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun TimeSettingsScreen(viewModel: SettingsViewModel, onNavigateBack: () -> Unit, title: String) {\n  // Используем переданный viewModel\n\n  val scope = rememberCoroutineScope()\n  val snackbarHostState = remember { SnackbarHostState() }\n  val currentSavedTimeZone by viewModel.timeZone.collectAsStateWithLifecycle()\n  var selectedTimeZoneId by\n      remember(currentSavedTimeZone) {\n        mutableStateOf(currentSavedTimeZone.takeIf { it.isNotEmpty() } ?: ZoneId.systemDefault().id)\n      }\n  var expanded by remember { mutableStateOf(false) }\n  val allTimeZones = remember { ZoneId.getAvailableZoneIds().sorted() }\n\n  Scaffold(\n      snackbarHost = { SnackbarHost(snackbarHostState) },\n      topBar = {\n        TopAppBar(\n            title = { Text(title) },\n            navigationIcon = {\n              IconButton(onClick = onNavigateBack) {\n                Icon(\n                    Icons.AutoMirrored.Filled.ArrowBack,\n                    contentDescription = stringResource(R.string.back))\n              }\n            })\n      }) { paddingValues ->\n        Column(modifier = Modifier.padding(paddingValues).padding(16.dp).fillMaxWidth()) {\n          Box(\n              modifier =\n                  Modifier.fillMaxWidth()\n                      .clip(RoundedCornerShape(cuid.SettingsItemCornerRadius))\n                      .background(color = colorScheme.surfaceContainer)\n                      .padding(16.dp)) {\n                // TODO: Сделать настройку системного или нет таймзоны\n                ExposedDropdownMenuBox(\n                    expanded = expanded, onExpandedChange = { expanded = !expanded }) {\n                      OutlinedTextField(\n                          readOnly = true, // Меню только для чтения\n                          value = selectedTimeZoneId, // Показываем выбранный ID\n                          onValueChange = {}, // Пустой обработчик, т.к. readOnly\n                          label = {\n                            Text(stringResource(R.string.time_zone))\n                          }, // Используй Text() для label\n                          trailingIcon = {\n                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)\n                          },\n                          modifier =\n                              Modifier.menuAnchor(\n                                      type = PrimaryEditable, enabled = true) // Исправлено\n                                  .fillMaxWidth(),\n                          shape = RoundedCornerShape(cuid.SettingsItemCornerRadius))\n\n                      ExposedDropdownMenu(\n                          expanded = expanded, onDismissRequest = { expanded = false }) {\n                            allTimeZones.forEach { timeZoneId ->\n                              DropdownMenuItem(\n                                  text = { Text(timeZoneId) },\n                                  onClick = {\n                                    selectedTimeZoneId =\n                                        timeZoneId // Обновляем локальное состояние UI\n                                    expanded = false // Закрываем меню\n                                    scope.launch {\n                                      viewModel.updateTimeZoneSetting(timeZoneId) // Сохраняем выбор\n                                      snackbarHostState.showSnackbar(\"Time zone saved\")\n                                    }\n                                  })\n                            }\n                          }\n                    }\n              }\n          Spacer(modifier = Modifier.height(10.dp))\n        }\n      }\n}\n",
      "info": {
        "size": 5814,
        "last_modified": "2025-08-06T08:35:04.143733",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/settings/vm/SettingsViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.settings.vm\n\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.core.data.repository.SettingsRepository\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.launch\nimport java.time.ZoneId\nimport javax.inject.Inject\n\n@HiltViewModel\nclass SettingsViewModel\n@Inject\nconstructor(\n    private val settingsRepository: SettingsRepository,\n) : ViewModel() {\n\n  val timeZone: StateFlow<String> =\n      settingsRepository.timeZoneFlow.stateIn(\n          viewModelScope, SharingStarted.WhileSubscribed(5000), ZoneId.systemDefault().id)\n\n  fun updateTimeZoneSetting(zoneId: String) {\n    if (ZoneId.getAvailableZoneIds().contains(zoneId)) {\n      viewModelScope.launch { settingsRepository.saveTimeZone(zoneId) }\n    } else {\n      Log.e(TAG, \"Attempted to save invalid time zone ID: $zoneId\")\n    }\n  }\n\n  val botTemperState: StateFlow<String> =\n      settingsRepository.botTemperFlow.stateIn(\n          viewModelScope, SharingStarted.WhileSubscribed(5000), \"\")\n\n  fun updateBotTemperSetting(newTemper: String) {\n    viewModelScope.launch { settingsRepository.saveBotTemper(newTemper) }\n  }\n\n  companion object {\n    private const val TAG = \"SettingsViewModel\"\n  }\n}\n",
      "info": {
        "size": 1417,
        "last_modified": "2025-08-06T08:35:04.146417",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/CalendarScreen.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui\n\nimport android.Manifest\nimport android.app.Activity\nimport android.util.Log\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.IntentSenderRequest\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.WindowInsets\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.navigationBars\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.pager.PagerDefaults\nimport androidx.compose.foundation.pager.VerticalPager\nimport androidx.compose.foundation.pager.rememberPagerState\nimport androidx.compose.material3.DatePicker\nimport androidx.compose.material3.DatePickerDialog\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FloatingToolbarDefaults.ScreenOffset\nimport androidx.compose.material3.ModalBottomSheet\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.rememberDatePickerState\nimport androidx.compose.material3.rememberModalBottomSheetState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.core.content.ContextCompat\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.util.BackgroundShapeContext\nimport com.lpavs.caliinda.core.ui.util.BackgroundShapes\nimport com.lpavs.caliinda.feature.agent.ui.AiVisualizer\nimport com.lpavs.caliinda.feature.calendar.ui.components.BottomBar\nimport com.lpavs.caliinda.feature.calendar.ui.components.CalendarAppBar\nimport com.lpavs.caliinda.feature.calendar.ui.components.DayEventsPage\nimport com.lpavs.caliinda.feature.event_management.ui.create.CreateEventScreen\nimport com.lpavs.caliinda.feature.event_management.ui.details.CustomEventDetailsDialog\nimport com.lpavs.caliinda.feature.event_management.ui.edit.EditEventScreen\nimport com.lpavs.caliinda.feature.event_management.ui.shared.RecurringEventEditOptionsDialog\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementUiEvent\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport com.lpavs.caliinda.feature.settings.ui.LogInScreenDialog\nimport kotlinx.coroutines.launch\nimport java.time.Instant\nimport java.time.LocalDate\nimport java.time.ZoneId\nimport java.time.temporal.ChronoUnit\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun CalendarScreen(\n    calendarViewModel: CalendarViewModel,\n    onNavigateToSettings: () -> Unit,\n    eventManagementViewModel: EventManagementViewModel\n) {\n  val timeZone = eventManagementViewModel.timeZone.collectAsStateWithLifecycle()\n  val userTimeZoneId = remember { ZoneId.of(timeZone.value) }\n  val calendarState by calendarViewModel.state.collectAsStateWithLifecycle()\n  val aiState by calendarViewModel.aiState.collectAsState()\n  val eventManagementState by eventManagementViewModel.uiState.collectAsState()\n  var textFieldState by remember { mutableStateOf(TextFieldValue(\"\")) }\n  val snackbarHostState = remember { SnackbarHostState() }\n  val isTextInputVisible by remember { mutableStateOf(false) }\n  val aiMessage by calendarViewModel.aiMessage.collectAsState()\n  val context = LocalContext.current\n  val scope = rememberCoroutineScope()\n  val today = remember { LocalDate.now() }\n  val initialPageIndex = remember { Int.MAX_VALUE / 2 }\n  val pagerState = rememberPagerState(initialPage = initialPageIndex, pageCount = { Int.MAX_VALUE })\n  val currentVisibleDate by calendarViewModel.currentVisibleDate.collectAsStateWithLifecycle()\n  val activity = context as? Activity\n  val authorizationLauncher =\n      rememberLauncherForActivityResult(\n          contract = ActivityResultContracts.StartIntentSenderForResult()) { result ->\n            if (result.resultCode == Activity.RESULT_OK) {\n              result.data?.let { calendarViewModel.handleAuthorizationResult(it) }\n            } else {\n              Log.w(\"MainScreen\", \"Authorization flow was cancelled by user.\")\n              calendarViewModel.signOut()\n            }\n          }\n  val isOverallLoading = calendarState.isLoading || eventManagementState.isLoading\n\n  LaunchedEffect(calendarState.authorizationIntent) {\n    calendarState.authorizationIntent?.let { pendingIntent ->\n      try {\n        val intentSenderRequest = IntentSenderRequest.Builder(pendingIntent).build()\n        authorizationLauncher.launch(intentSenderRequest)\n        calendarViewModel.clearAuthorizationIntent()\n      } catch (e: Exception) {\n        Log.e(\"MainScreen\", \"Couldn't start authorization UI\", e)\n      }\n    }\n  }\n\n  var showDatePicker by remember { mutableStateOf(false) }\n  val datePickerState =\n      rememberDatePickerState(\n          initialSelectedDateMillis =\n              currentVisibleDate.atStartOfDay(userTimeZoneId).toInstant().toEpochMilli(),\n      )\n\n  // --- НОВОЕ: Настройка flingBehavior ---\n  val customFlingBehavior =\n      PagerDefaults.flingBehavior(\n          state = pagerState,\n          // ---\n          snapPositionalThreshold = 0.2f,\n          // ---\n          snapAnimationSpec =\n              spring(\n                  stiffness = Spring.StiffnessLow, // По умолчанию Spring.StiffnessMediumLow\n              ))\n\n  val sheetState =\n      rememberModalBottomSheetState(\n          skipPartiallyExpanded = false // Чтобы лист либо полностью открыт, либо закрыт\n          )\n  var showCreateEventSheet by remember { mutableStateOf(false) }\n  var selectedDateForSheet by remember { mutableStateOf<LocalDate>(today) }\n\n  var showEditEventSheet by remember { mutableStateOf(false) }\n  val editSheetState = rememberModalBottomSheetState(skipPartiallyExpanded = false)\n\n  // --- НОВОЕ: Эффект для синхронизации Pager -> ViewModel ---\n  LaunchedEffect(pagerState.targetPage) { // Реагируем, когда страница \"устаканилась\"\n    val settledDate = today.plusDays((pagerState.targetPage - initialPageIndex).toLong())\n    Log.d(\"CalendarScreen\", \"Pager settled on page ${pagerState.targetPage}, date: $settledDate\")\n    calendarViewModel.onVisibleDateChanged(settledDate)\n  }\n\n  LaunchedEffect(key1 = true) {\n    calendarViewModel.eventFlow.collect { event ->\n      when (event) {\n        is CalendarUiEvent.ShowMessage -> {\n          snackbarHostState.showSnackbar(event.message)\n        }\n      }\n    }\n  }\n\n  // события от EventManagementViewModel (успех/ошибка CRUD операций)\n  LaunchedEffect(key1 = true) {\n    eventManagementViewModel.eventFlow.collect { event ->\n      when (event) {\n        is EventManagementUiEvent.ShowMessage -> {\n          snackbarHostState.showSnackbar(event.message.asString(context))\n        }\n        is EventManagementUiEvent.OperationSuccess -> {}\n      }\n    }\n  }\n  // TODO: Добавь обработку rangeNetworkState.Error, если нужно показывать снекбар и для этого\n\n  LaunchedEffect(Unit) {\n    val hasPermission =\n        ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) ==\n            android.content.pm.PackageManager.PERMISSION_GRANTED\n    calendarViewModel.updatePermissionStatus(hasPermission)\n  }\n\n  if (eventManagementState.showRecurringEditOptionsDialog &&\n      eventManagementState.eventBeingEdited != null) {\n    RecurringEventEditOptionsDialog( // Вам нужно создать этот Composable\n        eventName = eventManagementState.eventBeingEdited!!.summary,\n        onDismiss = {\n          eventManagementViewModel.cancelEditEvent()\n        }, // Если пользователь закрыл диалог\n        onOptionSelected = { choice ->\n          eventManagementViewModel.onRecurringEditOptionSelected(choice)\n        })\n  }\n\n  LaunchedEffect(eventManagementState.showEditEventDialog, eventManagementState.eventBeingEdited) {\n    if (eventManagementState.showEditEventDialog && eventManagementState.eventBeingEdited != null) {\n      showEditEventSheet = true\n    } else {\n      if (showEditEventSheet) {\n        scope\n            .launch { editSheetState.hide() }\n            .invokeOnCompletion {\n              if (!editSheetState.isVisible) {\n                showEditEventSheet = false\n              }\n            }\n      }\n    }\n  }\n  LaunchedEffect(editSheetState.isVisible) {\n    if (!editSheetState.isVisible && showEditEventSheet) {\n      showEditEventSheet = false\n      eventManagementViewModel.cancelEditEvent()\n    }\n  }\n\n  Scaffold(\n      snackbarHost = { SnackbarHost(snackbarHostState) },\n      topBar = {\n        CalendarAppBar(\n            onNavigateToSettings = onNavigateToSettings,\n            onGoToTodayClick = {\n              scope.launch {\n                if (pagerState.currentPage != initialPageIndex) {\n                  calendarViewModel.onVisibleDateChanged(today)\n                  pagerState.animateScrollToPage(initialPageIndex)\n                } else {\n                  calendarViewModel.refreshCurrentVisibleDate()\n                }\n              }\n            },\n            onTitleClick = {\n              datePickerState.selectableDates\n\n              showDatePicker = true\n            },\n            date = currentVisibleDate)\n      },\n  ) { paddingValues ->\n    Box(modifier = Modifier.padding(paddingValues).fillMaxSize()) {\n      BackgroundShapes(BackgroundShapeContext.Main)\n\n      VerticalPager(\n          state = pagerState,\n          modifier = Modifier.fillMaxSize(),\n          key = { index -> today.plusDays((index - initialPageIndex).toLong()).toEpochDay() },\n          flingBehavior = customFlingBehavior) { pageIndex ->\n            val pageDate =\n                remember(pageIndex) { today.plusDays((pageIndex - initialPageIndex).toLong()) }\n\n            DayEventsPage(\n                isLoading = isOverallLoading,\n                date = pageDate,\n                viewModel = calendarViewModel,\n                eventManagementViewModel = eventManagementViewModel)\n          }\n      AiVisualizer(\n          aiState = aiState,\n          aiMessage = aiMessage,\n          modifier = Modifier.fillMaxSize(),\n          onResultShownTimeout = { calendarViewModel.resetAiStateAfterResult() },\n          onAskingShownTimeout = { calendarViewModel.resetAiStateAfterAsking() })\n      BottomBar(\n          uiState = calendarState, // Передаем весь uiState, т.к. Bar зависит от многих полей\n          textFieldValue = textFieldState,\n          onTextChanged = { textFieldState = it },\n          onSendClick = {\n            calendarViewModel.sendTextMessage(textFieldState.text)\n            textFieldState = TextFieldValue(\"\") // Очищаем поле после отправки\n          },\n          onRecordStart = { calendarViewModel.startListening() }, // Передаем лямбды для записи\n          onRecordStopAndSend = { calendarViewModel.stopListening() },\n          onUpdatePermissionResult = { granted ->\n            calendarViewModel.updatePermissionStatus(granted)\n          }, // Передаем лямбду для обновления разрешений\n          isTextInputVisible = isTextInputVisible,\n          modifier = Modifier.align(Alignment.BottomCenter).offset(y = -ScreenOffset),\n          onCreateEventClick = {\n            selectedDateForSheet = currentVisibleDate\n            showCreateEventSheet = true\n          })\n    } // End основной Box\n  } // End Scaffold\n\n  if (showDatePicker) {\n    DatePickerDialog(\n        onDismissRequest = { showDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                showDatePicker = false\n                val selectedMillis = datePickerState.selectedDateMillis\n                if (selectedMillis != null) {\n                  val selectedDate =\n                      Instant.ofEpochMilli(selectedMillis).atZone(userTimeZoneId).toLocalDate()\n\n                  // Проверяем, изменилась ли дата\n                  if (selectedDate != currentVisibleDate) {\n                    // 1. Сообщаем ViewModel о новой дате *до* скролла\n                    Log.d(\"DatePicker\", \"Date selected: $selectedDate. Updating ViewModel.\")\n                    calendarViewModel.onVisibleDateChanged(selectedDate)\n\n                    // 2. Рассчитываем целевую страницу\n                    val daysDifference = ChronoUnit.DAYS.between(today, selectedDate)\n                    val targetPageIndex =\n                        (initialPageIndex + daysDifference)\n                            // Ограничиваем индекс на всякий случай\n                            .coerceIn(0L, Int.MAX_VALUE.toLong() - 1L)\n                            .toInt()\n\n                    // 3. Запускаем скролл к странице (используем scrollToPage для мгновенного\n                    // перехода)\n                    scope.launch {\n                      Log.d(\"DatePicker\", \"Scrolling Pager to page index: $targetPageIndex\")\n                      pagerState.scrollToPage(targetPageIndex)\n                    }\n                  } else {\n                    Log.d(\n                        \"DatePicker\",\n                        \"Selected date $selectedDate is the same as current $currentVisibleDate. No action.\")\n                  }\n                } else {\n                  Log.w(\"DatePicker\", \"Confirm clicked but selectedDateMillis is null.\")\n                }\n              },\n              // Кнопка активна, только если дата выбрана\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\") // Используем Text из M3\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showDatePicker = false }) {\n            Text(stringResource(R.string.cancel)) // Используем Text из M3\n          }\n        }) {\n          // Сам DatePicker\n          DatePicker(state = datePickerState)\n        }\n  }\n  if (showCreateEventSheet) {\n    ModalBottomSheet(\n        onDismissRequest = { showCreateEventSheet = false },\n        sheetState = sheetState,\n        contentWindowInsets = { WindowInsets.navigationBars }) {\n          CreateEventScreen(\n              userTimeZone = timeZone.value,\n              initialDate = selectedDateForSheet,\n              onDismiss = {\n                scope\n                    .launch { sheetState.hide() }\n                    .invokeOnCompletion {\n                      if (!sheetState.isVisible) {\n                        showCreateEventSheet = false\n                      }\n                    }\n              },\n              currentSheetValue = sheetState.currentValue)\n        }\n  }\n  if (showEditEventSheet) {\n    val eventToEdit = eventManagementState.eventBeingEdited\n    val mode = eventManagementState.selectedUpdateMode\n\n    if (eventToEdit != null && mode != null) {\n      ModalBottomSheet(\n          onDismissRequest = {\n            scope\n                .launch { editSheetState.hide() }\n                .invokeOnCompletion {\n                  if (!editSheetState.isVisible) {\n                    showEditEventSheet = false\n                    eventManagementViewModel.cancelEditEvent()\n                  }\n                }\n          },\n          sheetState = editSheetState,\n          contentWindowInsets = { WindowInsets.navigationBars }) {\n            EditEventScreen(\n                viewModel = eventManagementViewModel,\n                userTimeZone = timeZone.value,\n                eventToEdit = eventToEdit,\n                selectedUpdateMode = mode,\n                onDismiss = {\n                  scope\n                      .launch { editSheetState.hide() }\n                      .invokeOnCompletion {\n                        if (!editSheetState.isVisible) {\n                          showEditEventSheet = false\n                          eventManagementViewModel.cancelEditEvent()\n                        }\n                      }\n                },\n                currentSheetValue = editSheetState.currentValue)\n          }\n    }\n  }\n  if (eventManagementState.showEventDetailedView &&\n      eventManagementState.eventForDetailedView != null) {\n    CustomEventDetailsDialog(\n        event = eventManagementState.eventForDetailedView!!, // Передаем событие\n        onDismissRequest = { eventManagementViewModel.cancelEventDetails() },\n        viewModel = calendarViewModel,\n        userTimeZone = timeZone.value,\n        eventManagementViewModel = eventManagementViewModel)\n  }\n  if (calendarState.showSignInRequiredDialog) {\n    LogInScreenDialog(\n        onDismissRequest = { calendarViewModel.onSignInRequiredDialogDismissed() },\n        onSignInClick = {\n          if (activity != null) {\n            calendarViewModel.signIn(activity)\n          } else {\n            Log.e(\"MainScreen\", \"Activity is null, cannot start sign-in flow.\")\n          }\n        })\n  }\n\n  LaunchedEffect(sheetState.isVisible) {\n    if (!sheetState.isVisible && showCreateEventSheet) {\n      showCreateEventSheet = false\n    }\n  }\n}\n",
      "info": {
        "size": 18279,
        "last_modified": "2025-08-06T08:35:04.150036",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/CalendarState.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui\n\nimport android.app.PendingIntent\nimport android.net.Uri\n\ndata class CalendarState(\n    val isSignedIn: Boolean = false,\n    val userEmail: String? = null,\n    val displayName: String? = null,\n    val photo: Uri? = null,\n    val isLoading: Boolean = false,\n    val isListening: Boolean = false,\n    val isPermissionGranted: Boolean = false,\n    val message: String? = \"Требуется вход.\",\n    val showSignInRequiredDialog: Boolean = false,\n    val authorizationIntent: PendingIntent? = null,\n)\n",
      "info": {
        "size": 552,
        "last_modified": "2025-08-06T08:35:04.152323",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/DayEventsPage.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport android.util.Log\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.shadow\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.common.EventNetworkState\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.ui.theme.CalendarUiDefaults\nimport com.lpavs.caliinda.core.ui.util.DateTimeFormatterUtil\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.feature.event_management.ui.shared.DeleteConfirmationDialog\nimport com.lpavs.caliinda.feature.event_management.ui.shared.RecurringEventDeleteOptionsDialog\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport kotlinx.coroutines.launch\nimport java.time.Instant\nimport java.time.LocalDate\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun DayEventsPage(\n    isLoading: Boolean,\n    date: LocalDate,\n    viewModel: CalendarViewModel,\n    eventManagementViewModel: EventManagementViewModel\n) {\n  val eventsFlow = remember(date) { viewModel.getEventsFlowForDate(date) }\n  val eventsState = eventsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n  val events = eventsState.value\n  Log.d(\n      \"DayEventsPage\",\n      \"Events received from flow: ${events.joinToString { it.summary + \" (allDay=\" + it.isAllDay + \")\" }}\")\n  val calendarState by viewModel.state.collectAsStateWithLifecycle()\n  val eventManagementState by eventManagementViewModel.uiState.collectAsStateWithLifecycle()\n  val currentTimeZoneId by eventManagementViewModel.timeZone.collectAsStateWithLifecycle()\n\n  val currentTime by viewModel.currentTime.collectAsStateWithLifecycle()\n\n  val isToday = date == LocalDate.now()\n\n  val (allDayEvents, timedEvents) =\n      remember(events, currentTimeZoneId) { // Добавим зависимость от пояса\n        val (allDay, timed) = events.partition { it.isAllDay } // Используем флаг isAllDay\n        val sortedTimed =\n            timed.sortedBy { event ->\n              DateTimeUtils.parseToInstant(event.startTime, currentTimeZoneId) ?: Instant.MAX\n            }\n        allDay to sortedTimed\n      }\n  Log.d(\"DayEventsPage\", \"Partitioned: AllDay=${allDayEvents.size}, Timed=${timedEvents.size}\")\n\n  val nextStartTime: Instant? =\n      remember(timedEvents, currentTime, isToday, currentTimeZoneId) {\n        if (!isToday) null\n        else {\n          timedEvents.firstNotNullOfOrNull { event ->\n            val start = DateTimeUtils.parseToInstant(event.startTime, currentTimeZoneId)\n            if (start != null && start.isAfter(currentTime)) start else null\n          }\n        }\n      }\n  val context = LocalContext.current\n\n  // --- ОПРЕДЕЛЯЕМ ЦЕЛЕВОЙ ИНДЕКС ДЛЯ ПРОКРУТКИ ---\n  val targetScrollIndex =\n      remember(timedEvents, currentTime, nextStartTime, isToday, currentTimeZoneId) {\n        if (!isToday || timedEvents.isEmpty()) -1\n        else {\n          val currentEventIndex =\n              timedEvents.indexOfFirst { event ->\n                val start = DateTimeUtils.parseToInstant(event.startTime, currentTimeZoneId)\n                val end = DateTimeUtils.parseToInstant(event.endTime, currentTimeZoneId)\n                start != null &&\n                    end != null &&\n                    !currentTime.isBefore(start) &&\n                    currentTime.isBefore(end)\n              }\n          if (currentEventIndex != -1) currentEventIndex\n          else if (nextStartTime != null) {\n            timedEvents.indexOfFirst { event ->\n              val start = DateTimeUtils.parseToInstant(event.startTime, currentTimeZoneId)\n              start != null && start == nextStartTime\n            }\n          } else -1\n        }\n      }\n\n  // --- СОЗДАЕМ И ЗАПОМИНАЕМ СОСТОЯНИЕ СПИСКА ---\n  val listState = rememberLazyListState()\n  val rangeNetworkState by viewModel.rangeNetworkState.collectAsStateWithLifecycle()\n  val isBusy = isLoading || rangeNetworkState is EventNetworkState.Loading\n  val isListening = calendarState.isListening\n\n  LaunchedEffect(targetScrollIndex, isToday) {\n    if (isToday && targetScrollIndex != -1) {\n      launch {\n        try {\n          listState.animateScrollToItem(index = targetScrollIndex)\n        } catch (e: Exception) {\n          Log.e(\"DayEventsPageScroll\", \"Error scrolling to index $targetScrollIndex\", e)\n        }\n      }\n    }\n  }\n  var expandedAllDayEventId by remember { mutableStateOf<String?>(null) }\n\n  Box(modifier = Modifier.fillMaxSize()) {\n    Column(modifier = Modifier.fillMaxSize()) {\n      Spacer(modifier = Modifier.height(3.dp))\n      if (allDayEvents.isNotEmpty()) {\n        Spacer(modifier = Modifier.height(3.dp)) // Отступ после заголовка даты\n        Column(\n            modifier =\n                Modifier.fillMaxWidth().padding(horizontal = 16.dp) // Общий горизонтальный отступ\n            ) {\n              allDayEvents.forEach { event ->\n                val isExpanded = event.id == expandedAllDayEventId\n                AllDayEventItem(\n                    event = event,\n                    isExpanded = isExpanded,\n                    onToggleExpand = {\n                      expandedAllDayEventId =\n                          if (expandedAllDayEventId == event.id) {\n                            null\n                          } else {\n                            event.id\n                          }\n                    },\n                    onDeleteClick = { eventManagementViewModel.requestDeleteConfirmation(event) },\n                    onDetailsClick = { eventManagementViewModel.requestEventDetails(event) },\n                    onEditClick = { eventManagementViewModel.requestEditEvent(event) },\n                )\n                Spacer(modifier = Modifier.height(6.dp))\n              }\n            }\n      }\n      Spacer(modifier = Modifier.height(8.dp))\n\n      if (timedEvents.isNotEmpty()) {\n        val timeFormatterLambda: (EventDto) -> String =\n            remember(viewModel, currentTimeZoneId) {\n              { event ->\n                DateTimeFormatterUtil.formatEventListTime(context, event, currentTimeZoneId)\n              }\n            }\n        CardsList(\n            events = timedEvents,\n            timeFormatter = timeFormatterLambda,\n            isToday = isToday,\n            nextStartTime = nextStartTime,\n            currentTime = currentTime,\n            listState = listState,\n            onDeleteRequest = eventManagementViewModel::requestDeleteConfirmation,\n            onEditRequest = eventManagementViewModel::requestEditEvent,\n            onDetailsRequest = eventManagementViewModel::requestEventDetails,\n            currentTimeZoneId = currentTimeZoneId)\n      } else if (allDayEvents.isEmpty()) {\n        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n          if (isBusy && !isListening) {\n            LoadingIndicator(modifier = Modifier.size(80.dp))\n          } else {\n            Box(\n                modifier =\n                    Modifier.shadow(\n                            elevation = 5.dp,\n                            shape = RoundedCornerShape(CalendarUiDefaults.EventItemCornerRadius),\n                            clip = false,\n                        )\n                        .clip(RoundedCornerShape(CalendarUiDefaults.EventItemCornerRadius))\n                        .background(color = MaterialTheme.colorScheme.secondaryContainer)\n                        .padding(16.dp),\n                contentAlignment = Alignment.Center // Центрируем сообщение\n                ) {\n                  Text(\n                      stringResource(R.string.no_events),\n                      style = MaterialTheme.typography.bodyLarge,\n                      color = MaterialTheme.colorScheme.onSecondaryContainer)\n                }\n          }\n        }\n      } else {\n        Spacer(modifier = Modifier.weight(1f))\n      }\n      if (eventManagementState.showDeleteConfirmationDialog &&\n          eventManagementState.eventPendingDeletion != null) {\n        DeleteConfirmationDialog(\n            onConfirm = { eventManagementViewModel.confirmDeleteEvent() },\n            onDismiss = { eventManagementViewModel.cancelDelete() })\n      } else if (eventManagementState.showRecurringDeleteOptionsDialog &&\n          eventManagementState.eventPendingDeletion != null) {\n        RecurringEventDeleteOptionsDialog(\n            eventName = eventManagementState.eventPendingDeletion!!.summary,\n            onDismiss = { eventManagementViewModel.cancelDelete() },\n            onOptionSelected = { choice ->\n              eventManagementViewModel.confirmRecurringDelete(choice)\n            })\n      }\n    }\n  }\n}\n",
      "info": {
        "size": 10153,
        "last_modified": "2025-08-06T08:35:04.154915",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/CardsList.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateDpAsState\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.slideOutVertically\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.ui.theme.CalendarUiDefaults\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils.parseToInstant\nimport java.time.Duration\nimport java.time.Instant\n\ndata class GeneratedShapeParams(\n    val numVertices: Int,\n    val radiusSeed: Float,\n    val rotationAngle: Float,\n    val shadowOffsetYSeed: Dp,\n    val shadowOffsetXSeed: Dp,\n    val offestParam: Float,\n)\n\n@Composable\nfun CardsList(\n    events: List<EventDto>,\n    timeFormatter: (EventDto) -> String,\n    currentTime: Instant,\n    isToday: Boolean,\n    currentTimeZoneId: String,\n    listState: LazyListState,\n    nextStartTime: Instant?,\n    onDeleteRequest: (EventDto) -> Unit,\n    onEditRequest: (EventDto) -> Unit,\n    onDetailsRequest: (EventDto) -> Unit,\n) {\n  val transitionWindowDurationMillis = remember {\n    Duration.ofMinutes(cuid.EVENT_TRANSITION_WINDOW_MINUTES).toMillis()\n  }\n  var expandedEventId by remember { mutableStateOf<String?>(null) }\n\n  LazyColumn(\n      modifier = Modifier.fillMaxSize(),\n      state = listState,\n      contentPadding = PaddingValues(bottom = 100.dp)) {\n        items(items = events, key = { event -> event.id }) { event ->\n          val fadeSpringSpec =\n              spring<Float>(\n                  dampingRatio = Spring.DampingRatioLowBouncy, stiffness = Spring.StiffnessMedium)\n          val sliderSpringSpec =\n              spring<IntOffset>(\n                  dampingRatio = Spring.DampingRatioHighBouncy,\n                  stiffness = Spring.StiffnessMediumLow)\n          val popUndUpSpec =\n              spring<IntOffset>(\n                  dampingRatio = Spring.DampingRatioMediumBouncy,\n                  stiffness = Spring.StiffnessMediumLow)\n          AnimatedVisibility(\n              visible = true,\n              enter =\n                  slideInVertically(initialOffsetY = { it / 2 }, animationSpec = sliderSpringSpec),\n              exit =\n                  fadeOut(animationSpec = fadeSpringSpec) +\n                      slideOutVertically(\n                          targetOffsetY = { it / 2 }, animationSpec = sliderSpringSpec),\n              modifier =\n                  Modifier.animateItem(\n                      placementSpec = popUndUpSpec,\n                      fadeInSpec = spring(stiffness = Spring.StiffnessMediumLow),\n                      fadeOutSpec = spring(stiffness = Spring.StiffnessHigh))) {\n                val isExpanded = event.id == expandedEventId\n\n                val eventDurationMinutes =\n                    remember(event.startTime, event.endTime, currentTimeZoneId) {\n                      val start = parseToInstant(event.startTime, currentTimeZoneId)\n                      val end = parseToInstant(event.endTime, currentTimeZoneId)\n                      if (start != null && end != null && end.isAfter(start)) {\n                        Duration.between(start, end).toMinutes()\n                      } else {\n                        0L\n                      }\n                    }\n\n                val isMicroEvent =\n                    remember(eventDurationMinutes) {\n                      eventDurationMinutes > 0 &&\n                          eventDurationMinutes <= cuid.MicroEventMaxDurationMinutes\n                    }\n\n                val baseHeight =\n                    remember(isMicroEvent, eventDurationMinutes) {\n                      calculateEventHeight(eventDurationMinutes, isMicroEvent)\n                    }\n\n                val buttonsRowHeight = 56.dp\n                val expandedAdditionalHeight =\n                    remember(isMicroEvent) {\n                      if (isMicroEvent && baseHeight < buttonsRowHeight * 1.5f) {\n                        buttonsRowHeight * 1.2f\n                      } else {\n                        buttonsRowHeight\n                      }\n                    }\n\n                val expandedCalculatedHeight =\n                    remember(baseHeight, expandedAdditionalHeight) {\n                      if (eventDurationMinutes > 120 && !isMicroEvent) {\n                        (baseHeight + expandedAdditionalHeight * 0.9f).coerceAtLeast(baseHeight)\n                      } else {\n                        baseHeight + expandedAdditionalHeight\n                      }\n                    }\n\n                val animatedHeight by\n                    animateDpAsState(\n                        targetValue = if (isExpanded) expandedCalculatedHeight else baseHeight,\n                        animationSpec = tween(durationMillis = 250),\n                        label = \"eventItemHeightAnimation\")\n\n                val isCurrent =\n                    remember(currentTime, event.startTime, event.endTime, currentTimeZoneId) {\n                      val start = parseToInstant(event.startTime, currentTimeZoneId)\n                      val end = parseToInstant(event.endTime, currentTimeZoneId)\n                      start != null &&\n                          end != null &&\n                          !currentTime.isBefore(start) &&\n                          currentTime.isBefore(end)\n                    }\n                val isNext =\n                    remember(event.startTime, nextStartTime, currentTimeZoneId) {\n                      if (nextStartTime == null) false\n                      else {\n                        val currentEventStart = parseToInstant(event.startTime, currentTimeZoneId)\n                        currentEventStart != null && currentEventStart == nextStartTime\n                      }\n                    }\n\n                val proximityRatio =\n                    remember(\n                        currentTime,\n                        event.startTime,\n                        isToday,\n                        currentTimeZoneId,\n                        transitionWindowDurationMillis) {\n                          if (!isToday) {\n                            0f\n                          } else {\n                            val start = parseToInstant(event.startTime, currentTimeZoneId)\n                            if (start == null || currentTime.isAfter(start)) {\n                              0f\n                            } else {\n                              val timeUntilStartMillis =\n                                  Duration.between(currentTime, start).toMillis()\n                              if (timeUntilStartMillis > transitionWindowDurationMillis ||\n                                  transitionWindowDurationMillis <= 0) {\n                                0f\n                              } else {\n                                (1.0f -\n                                        (timeUntilStartMillis.toFloat() /\n                                            transitionWindowDurationMillis.toFloat()))\n                                    .coerceIn(0f, 1f)\n                              }\n                            }\n                          }\n                        }\n\n                EventItem(\n                    event = event,\n                    timeFormatter = timeFormatter,\n                    isCurrentEvent = isCurrent,\n                    isNextEvent = isNext,\n                    proximityRatio = proximityRatio,\n                    isMicroEventFromList = isMicroEvent,\n                    targetHeightFromList = animatedHeight,\n                    isExpanded = isExpanded,\n                    onToggleExpand = {\n                      expandedEventId =\n                          if (expandedEventId == event.id) {\n                            null\n                          } else {\n                            event.id\n                          }\n                    },\n                    onDeleteClickFromList = { onDeleteRequest(event) },\n                    onEditClickFromList = { onEditRequest(event) },\n                    onDetailsClickFromList = { onDetailsRequest(event) },\n                    // --------------------------------\n                    modifier =\n                        Modifier.fillMaxWidth()\n                            .padding(\n                                horizontal = CalendarUiDefaults.ItemHorizontalPadding,\n                                vertical = CalendarUiDefaults.ItemVerticalPadding),\n                    currentTimeZoneId = currentTimeZoneId)\n              }\n        }\n      }\n  Box(modifier = Modifier.height(70.dp))\n}\n",
      "info": {
        "size": 9611,
        "last_modified": "2025-08-06T08:35:04.156645",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/BottomBar.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport android.util.Log\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.text.KeyboardActions\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.automirrored.filled.Send\nimport androidx.compose.material.icons.filled.AddCircle\nimport androidx.compose.material.icons.filled.Keyboard\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FloatingActionButton\nimport androidx.compose.material3.HorizontalFloatingToolbar\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.OutlinedTextFieldDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.saveable.rememberSaveable\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.focus.FocusRequester\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalSoftwareKeyboardController\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.input.ImeAction\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.unit.IntSize\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.agent.ui.RecordButton\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarState\n\n@ExperimentalMaterial3ExpressiveApi\n@Composable\nfun BottomBar(\n    uiState: CalendarState, // Принимаем весь стейт\n    textFieldValue: TextFieldValue,\n    onTextChanged: (TextFieldValue) -> Unit,\n    onSendClick: () -> Unit,\n    onRecordStart: () -> Unit, // Лямбда для начала записи\n    onRecordStopAndSend: () -> Unit, // Лямбда для остановки/отправки\n    onUpdatePermissionResult: (Boolean) -> Unit, // Лямбда для обновления разрешения\n    isTextInputVisible: Boolean,\n    modifier: Modifier = Modifier,\n    onCreateEventClick: () -> Unit,\n) {\n  val focusRequester = remember { FocusRequester() }\n  val keyboardController = LocalSoftwareKeyboardController.current\n  val isSendEnabled =\n      textFieldValue.text.isNotBlank() &&\n          uiState.isSignedIn &&\n          !uiState.isLoading &&\n          !uiState.isListening\n  var expanded by rememberSaveable { mutableStateOf(true) }\n  var onKeyboardToggle by remember { mutableStateOf(true) }\n\n  // Request focus when text input becomes visible\n  LaunchedEffect(isTextInputVisible) {\n    if (isTextInputVisible) {\n      // kotlinx.coroutines.delay(100) // Small delay might be needed if focus doesn't work\n      // immediately\n      try {\n        focusRequester.requestFocus()\n        keyboardController?.show()\n        Log.d(\"ChatInputBar\", \"Focus requested and keyboard show attempted.\")\n      } catch (e: Exception) {\n        Log.e(\"ChatInputBar\", \"Error requesting focus or showing keyboard\", e)\n      }\n    } else {\n      keyboardController?.hide()\n    }\n  }\n  AnimatedContent(\n      modifier = modifier,\n      targetState = onKeyboardToggle,\n      transitionSpec = {\n        // Общая спецификация spring для контента\n        val fadeSpringSpec =\n            spring<Float>(\n                dampingRatio = Spring.DampingRatioLowBouncy, stiffness = Spring.StiffnessMedium)\n        val sizeTransformSpringSpec =\n            spring<IntSize>(\n                dampingRatio =\n                    Spring\n                        .DampingRatioLowBouncy, // Можно немного \"резиновости\" для изменения размера\n                stiffness = Spring.StiffnessMediumLow)\n        if (targetState) {\n              (fadeIn(animationSpec = fadeSpringSpec)).togetherWith(\n                  fadeOut(animationSpec = fadeSpringSpec))\n            } else {\n              (fadeIn(animationSpec = fadeSpringSpec)).togetherWith(\n                  fadeOut(animationSpec = fadeSpringSpec))\n            }\n            .using(\n                SizeTransform(\n                    clip = false, sizeAnimationSpec = { _, _ -> sizeTransformSpringSpec }))\n      }) {\n        if (!it) {\n          HorizontalFloatingToolbar(\n              expanded = expanded,\n              //                colors = vibrantColors,\n              floatingActionButton = {\n                FloatingActionButton(\n                    onClick = onSendClick,\n                    contentColor = colorScheme.onPrimary,\n                    containerColor = colorScheme.primary) {\n                      Icon(\n                          imageVector = Icons.AutoMirrored.Filled.Send,\n                          contentDescription = \"Отправить\")\n                    }\n              },\n              content = {\n                IconButton(\n                    onClick = {\n                      onKeyboardToggle = !onKeyboardToggle\n                    }, // Эта функция теперь будет ПОКАЗЫВАТЬ текстовое поле\n                ) {\n                  Icon(\n                      imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                      contentDescription = \"Убрать ввод текста\")\n                }\n                OutlinedTextField(\n                    // Или TextField, или BasicTextField + кастомное оформление\n                    value = textFieldValue,\n                    onValueChange = onTextChanged,\n                    modifier = Modifier.width(200.dp),\n                    placeholder = { Text(stringResource(R.string.type_message)) },\n                    maxLines = 1,\n                    keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Send),\n                    keyboardActions =\n                        KeyboardActions(\n                            onSend = {\n                              if (isSendEnabled) {\n                                onSendClick()\n                              }\n                            }),\n                    colors =\n                        OutlinedTextFieldDefaults.colors(\n                            focusedBorderColor = Color.Transparent,\n                            unfocusedBorderColor = Color.Transparent,\n                            //                            focusedTextColor =\n                            // colorScheme.onSecondaryContainer,\n                        ),\n                    singleLine = true,\n                )\n              },\n          )\n        } else {\n          HorizontalFloatingToolbar(\n              expanded = expanded,\n              //                colors = vibrantColors,\n              floatingActionButton = {\n                RecordButton(\n                    uiState = uiState, // Передаем стейт\n                    onStartRecording = onRecordStart, // Передаем лямбды\n                    onStopRecordingAndSend = onRecordStopAndSend,\n                    onUpdatePermissionResult = onUpdatePermissionResult,\n                )\n              },\n              content = {\n                IconButton(\n                    onClick = onCreateEventClick,\n                    // enabled = isKeyboardToggleEnabled\n                ) {\n                  Icon(imageVector = Icons.Filled.AddCircle, contentDescription = \"Create event\")\n                }\n                IconButton(\n                    onClick = { onKeyboardToggle = !onKeyboardToggle },\n                ) {\n                  Icon(\n                      imageVector = Icons.Filled.Keyboard,\n                      contentDescription = \"Показать клавиатуру\")\n                }\n              },\n          )\n        }\n      }\n}\n",
      "info": {
        "size": 8489,
        "last_modified": "2025-08-06T08:35:04.159993",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/FunMessages.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.utils.UiText\nimport java.util.Calendar\n\nobject FunMessages {\n\n  // Флаг для отслеживания первого сообщения\n  private var isFirstMessageOfSession = true\n  private var lastSessionTimestamp = 0L\n  private const val SESSION_TIMEOUT_MS = 30 * 60 * 1000L // 30 минут\n\n  // Сброс сессии (вызывать при старте приложения или после долгой паузы)\n  fun resetSession() {\n    isFirstMessageOfSession = true\n    lastSessionTimestamp = System.currentTimeMillis()\n  }\n\n  // Проверка, прошло ли много времени с последнего сообщения\n  private fun checkSessionTimeout() {\n    val currentTime = System.currentTimeMillis()\n    if (currentTime - lastSessionTimestamp > SESSION_TIMEOUT_MS) {\n      isFirstMessageOfSession = true\n    }\n    lastSessionTimestamp = currentTime\n  }\n\n  // Базовые сообщения без параметров\n  private val eventCreatedMessages =\n      listOf(\n          R.string.event_created_spawned,\n          R.string.event_created_dropped,\n          R.string.event_created_deployed,\n          R.string.event_created_baked,\n          R.string.event_created_nailed)\n\n  private val eventUpdatedMessages =\n      listOf(\n          R.string.event_updated_glow_up,\n          R.string.event_updated_upgraded,\n          R.string.event_updated_makeover,\n          R.string.event_updated_leveled,\n          R.string.event_updated_live)\n\n  private val eventDeletedMessages =\n      listOf(\n          R.string.event_deleted_slayed,\n          R.string.event_deleted_shadow_realm,\n          R.string.event_deleted_left_chat,\n          R.string.event_deleted_yeeted,\n          R.string.event_deleted_vanished)\n\n  private val seriesDeletedMessages =\n      listOf(\n          R.string.series_deleted_ace,\n          R.string.series_deleted_bloodline,\n          R.string.series_deleted_dynasty,\n          R.string.series_deleted_nuked,\n          R.string.series_deleted_family_tree)\n\n  // Сообщения с параметрами (имя события)\n  private val eventCreatedWithNameMessages =\n      listOf(\n          R.string.event_created_with_name_spawned,\n          R.string.event_created_with_name_deployed,\n          R.string.event_created_with_name_live,\n          R.string.event_created_with_name_complete,\n          R.string.event_created_with_name_entered_chat)\n\n  private val eventUpdatedWithNameMessages =\n      listOf(\n          R.string.event_updated_with_name_glow_up,\n          R.string.event_updated_with_name_upgraded,\n          R.string.event_updated_with_name_makeover,\n          R.string.event_updated_with_name_leveled,\n          R.string.event_updated_with_name_live)\n\n  private val eventDeletedWithNameMessages =\n      listOf(\n          R.string.event_deleted_with_name_slayed,\n          R.string.event_deleted_with_name_shadow_realm,\n          R.string.event_deleted_with_name_left_chat,\n          R.string.event_deleted_with_name_yeeted,\n          R.string.event_deleted_with_name_vanished)\n\n  // Ошибки\n  private val genericErrorMessages =\n      listOf(\n          R.string.error_generic_idk,\n          R.string.error_generic_oopsie,\n          R.string.error_generic_sus,\n          R.string.error_generic_mission_failed,\n          R.string.error_generic_motivation_404,\n          R.string.error_generic_spaghetti,\n          R.string.error_generic_calendar_gods,\n          R.string.error_generic_houston,\n          R.string.error_generic_task_failed,\n          R.string.error_generic_computer_says_no)\n\n  private val createErrorMessages =\n      listOf(\n          R.string.error_create_spectacular,\n          R.string.error_create_rejected,\n          R.string.error_create_spawning,\n          R.string.error_create_cook_failed)\n\n  private val updateErrorMessages =\n      listOf(\n          R.string.error_update_makeover_wrong,\n          R.string.error_update_mission_aborted,\n          R.string.error_update_refused,\n          R.string.error_update_glow_up_failed)\n\n  private val deleteErrorMessages =\n      listOf(\n          R.string.error_delete_refused_slayed,\n          R.string.error_delete_blocked,\n          R.string.error_delete_immortal,\n          R.string.error_delete_rights_revoked)\n\n  // Временные сообщения для первой операции\n  private fun getEventCreatedMessageWithTime(eventName: String? = null): UiText {\n    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)\n\n    return when {\n      eventName != null -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_created, eventName)\n          in 12..17 -> UiText.from(R.string.afternoon_event_created, eventName)\n          in 18..22 -> UiText.from(R.string.evening_event_created, eventName)\n          else -> UiText.from(R.string.night_event_created, eventName)\n        }\n      }\n      else -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_created_simple)\n          in 12..17 -> UiText.from(R.string.afternoon_event_created_simple)\n          in 18..22 -> UiText.from(R.string.evening_event_created_simple)\n          else -> UiText.from(R.string.night_event_created_simple)\n        }\n      }\n    }\n  }\n\n  private fun getEventUpdatedMessageWithTime(eventName: String? = null): UiText {\n    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)\n\n    return when {\n      eventName != null -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_updated, eventName)\n          in 12..17 -> UiText.from(R.string.afternoon_event_updated, eventName)\n          in 18..22 -> UiText.from(R.string.evening_event_updated, eventName)\n          else -> UiText.from(R.string.night_event_updated, eventName)\n        }\n      }\n      else -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_updated_simple)\n          in 12..17 -> UiText.from(R.string.afternoon_event_updated_simple)\n          in 18..22 -> UiText.from(R.string.evening_event_updated_simple)\n          else -> UiText.from(R.string.night_event_updated_simple)\n        }\n      }\n    }\n  }\n\n  private fun getEventDeletedMessageWithTime(eventName: String? = null): UiText {\n    val hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY)\n\n    return when {\n      eventName != null -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_deleted, eventName)\n          in 12..17 -> UiText.from(R.string.afternoon_event_deleted, eventName)\n          in 18..22 -> UiText.from(R.string.evening_event_deleted, eventName)\n          else -> UiText.from(R.string.night_event_deleted, eventName)\n        }\n      }\n      else -> {\n        when (hour) {\n          in 6..11 -> UiText.from(R.string.morning_event_deleted_simple)\n          in 12..17 -> UiText.from(R.string.afternoon_event_deleted_simple)\n          in 18..22 -> UiText.from(R.string.evening_event_deleted_simple)\n          else -> UiText.from(R.string.night_event_deleted_simple)\n        }\n      }\n    }\n  }\n\n  // ГЛАВНЫЕ МЕТОДЫ с логикой сессии\n\n  // Главный метод для создания события с логикой первого сообщения\n  fun getEventCreatedMessage(eventName: String? = null): UiText {\n    checkSessionTimeout()\n\n    return if (isFirstMessageOfSession) {\n      isFirstMessageOfSession = false\n      // Первое сообщение с временем суток\n      getEventCreatedMessageWithTime(eventName)\n    } else {\n      // Обычные случайные сообщения\n      if (eventName != null) {\n        val safeEventName = eventName.takeIf { it.isNotBlank() } ?: \"Untitled Event\"\n        UiText.from(eventCreatedWithNameMessages.random(), safeEventName)\n      } else {\n        UiText.from(eventCreatedMessages.random())\n      }\n    }\n  }\n\n  // Главный метод для обновления события с логикой сессии\n  fun getEventUpdatedMessage(eventName: String? = null): UiText {\n    checkSessionTimeout()\n\n    // Для обновления тоже можем сделать первое сообщение особенным\n    return if (isFirstMessageOfSession) {\n      isFirstMessageOfSession = false\n      // Первое сообщение с временем суток\n      getEventUpdatedMessageWithTime(eventName)\n    } else {\n      // Обычные случайные сообщения\n      if (eventName != null) {\n        val safeEventName = eventName.takeIf { it.isNotBlank() } ?: \"Event\"\n        UiText.from(eventUpdatedWithNameMessages.random(), safeEventName)\n      } else {\n        UiText.from(eventUpdatedMessages.random())\n      }\n    }\n  }\n\n  // Главный метод для удаления события с логикой сессии\n  fun getEventDeletedMessage(eventName: String? = null): UiText {\n    checkSessionTimeout()\n\n    // Для удаления тоже можем сделать первое сообщение особенным\n    return if (isFirstMessageOfSession) {\n      isFirstMessageOfSession = false\n      // Первое сообщение с временем суток\n      getEventDeletedMessageWithTime(eventName)\n    } else {\n      // Обычные случайные сообщения\n      if (eventName != null) {\n        val safeEventName = eventName.takeIf { it.isNotBlank() } ?: \"Event\"\n        UiText.from(eventDeletedWithNameMessages.random(), safeEventName)\n      } else {\n        UiText.from(eventDeletedMessages.random())\n      }\n    }\n  }\n\n  // Остальные методы без логики сессии\n  fun getSeriesDeletedMessage(): UiText = UiText.from(seriesDeletedMessages.random())\n\n  fun getGenericErrorMessage(): UiText = UiText.from(genericErrorMessages.random())\n\n  fun getCreateErrorMessage(): UiText = UiText.from(createErrorMessages.random())\n\n  fun getUpdateErrorMessage(): UiText = UiText.from(updateErrorMessages.random())\n\n  fun getDeleteErrorMessage(): UiText = UiText.from(deleteErrorMessages.random())\n\n  // Сезонные сообщения\n  fun getSeasonalMessage(): UiText {\n    val month = Calendar.getInstance().get(Calendar.MONTH)\n    return when (month) {\n      11,\n      0,\n      1 ->\n          UiText.from(\n              listOf(\n                      R.string.seasonal_winter_magic,\n                      R.string.seasonal_ho_ho_ho,\n                      R.string.seasonal_frosty_success)\n                  .random())\n      2,\n      3,\n      4 ->\n          UiText.from(\n              listOf(\n                      R.string.seasonal_spring_vibes,\n                      R.string.seasonal_fresh_start,\n                      R.string.seasonal_blooming_success)\n                  .random())\n      5,\n      6,\n      7 ->\n          UiText.from(\n              listOf(\n                      R.string.seasonal_summer_heat,\n                      R.string.seasonal_beach_mode,\n                      R.string.seasonal_sweet_success)\n                  .random())\n      else ->\n          UiText.from(\n              listOf(\n                      R.string.seasonal_autumn_magic,\n                      R.string.seasonal_spooky_success,\n                      R.string.seasonal_fall_vibes)\n                  .random())\n    }\n  }\n}\n",
      "info": {
        "size": 11423,
        "last_modified": "2025-08-06T08:35:04.163205",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/CalendarAppBar.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Settings\nimport androidx.compose.material.icons.filled.Today\nimport androidx.compose.material3.CenterAlignedTopAppBar\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FilledIconButton\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBarDefaults.topAppBarColors\nimport androidx.compose.material3.minimumInteractiveComponentSize\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.text.ExperimentalTextApi\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontVariation\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.Typography\nimport java.time.LocalDate\nimport java.time.format.DateTimeFormatter\n\n@OptIn(\n    ExperimentalMaterial3Api::class,\n    ExperimentalMaterial3ExpressiveApi::class,\n    ExperimentalTextApi::class)\n@Composable\nfun CalendarAppBar(\n    onNavigateToSettings: () -> Unit,\n    onGoToTodayClick: () -> Unit,\n    onTitleClick: () -> Unit,\n    date: LocalDate\n) {\n  val isToday = date == LocalDate.now()\n  val headerBackgroundColor =\n      if (isToday) {\n        colorScheme.tertiary\n      } else {\n        colorScheme.secondary\n      }\n  val headerTextColor =\n      if (isToday) {\n        colorScheme.onTertiary\n      } else {\n        colorScheme.onSecondary\n      }\n  val headerTextStyle =\n      when {\n        isToday -> Typography.titleLargeEmphasized\n        else -> Typography.titleLarge\n      }\n  val headerFontFamily =\n      when {\n        isToday ->\n            FontFamily(\n                Font(\n                    R.font.robotoflex_variable,\n                    variationSettings =\n                        FontVariation.Settings(\n                            FontVariation.weight(750),\n                        )))\n        else ->\n            FontFamily(\n                Font(\n                    R.font.robotoflex_variable,\n                    variationSettings =\n                        FontVariation.Settings(\n                            FontVariation.weight(600),\n                        )))\n      }\n  val currentLocale = LocalConfiguration.current.getLocales().get(0)\n  val formatterWithShortDay = DateTimeFormatter.ofPattern(\"E, d MMMM yyyy\", currentLocale)\n  CenterAlignedTopAppBar(\n      title = {\n        Box(\n            modifier =\n                Modifier.fillMaxWidth()\n                    .padding(horizontal = 16.dp)\n                    .clip(RoundedCornerShape(25.dp))\n                    .background(color = headerBackgroundColor)\n                    .clickable(onClick = onTitleClick),\n        ) {\n          Text(\n              text = date.format(formatterWithShortDay),\n              style = headerTextStyle,\n              fontFamily = headerFontFamily,\n              color = headerTextColor,\n              modifier =\n                  Modifier.padding(horizontal = 16.dp, vertical = 4.dp)\n                      .fillMaxWidth(), // Больше отступы\n              textAlign = TextAlign.Center,\n              fontSize = 16.sp,\n          )\n        }\n      },\n      navigationIcon = {\n        FilledIconButton(\n            onClick = onGoToTodayClick,\n            modifier =\n                Modifier.minimumInteractiveComponentSize()\n                    .size(\n                        IconButtonDefaults.smallContainerSize(\n                            IconButtonDefaults.IconButtonWidthOption.Wide)),\n            shape = IconButtonDefaults.smallRoundShape) {\n              Icon(\n                  Icons.Filled.Today,\n                  contentDescription = \"Перейти к сегодня\",\n              )\n            }\n      },\n      actions = {\n        Row(verticalAlignment = Alignment.CenterVertically) {\n          FilledIconButton(\n              onClick = onNavigateToSettings,\n              modifier =\n                  Modifier.minimumInteractiveComponentSize()\n                      .size(\n                          IconButtonDefaults.smallContainerSize(\n                              IconButtonDefaults.IconButtonWidthOption.Wide)),\n              shape = IconButtonDefaults.smallRoundShape) {\n                Icon(\n                    imageVector = Icons.Filled.Settings,\n                    contentDescription = \"Настройки\",\n                )\n              }\n        }\n      },\n      colors = topAppBarColors(containerColor = Color.Transparent))\n}\n",
      "info": {
        "size": 5497,
        "last_modified": "2025-08-06T08:35:04.166959",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/components/EventCard.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui.components\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.gestures.detectTapGestures\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.requiredSize\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material.icons.filled.Info\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FilledIconButton\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.minimumInteractiveComponentSize\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.shadow\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.colorspace.ColorSpaces\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.hapticfeedback.HapticFeedbackType\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.platform.LocalHapticFeedback\nimport androidx.compose.ui.text.ExperimentalTextApi\nimport androidx.compose.ui.text.font.Font\nimport androidx.compose.ui.text.font.FontFamily\nimport androidx.compose.ui.text.font.FontVariation\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.text.style.TextOverflow\nimport androidx.compose.ui.unit.Dp\nimport androidx.compose.ui.unit.dp\nimport androidx.graphics.shapes.CornerRounding\nimport androidx.graphics.shapes.RoundedPolygon\nimport androidx.graphics.shapes.star\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.ui.theme.CalendarUiDefaults\nimport com.lpavs.caliinda.core.ui.theme.Typography\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils.parseToInstant\nimport com.lpavs.caliinda.core.ui.util.RoundedPolygonShape\nimport java.time.Duration\nimport kotlin.math.abs\nimport kotlin.math.exp\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class, ExperimentalTextApi::class)\n@Composable\nfun EventItem(\n    event: EventDto,\n    timeFormatter: (EventDto) -> String,\n    isCurrentEvent: Boolean,\n    isNextEvent: Boolean,\n    proximityRatio: Float,\n    isMicroEventFromList: Boolean,\n    targetHeightFromList: Dp,\n    isExpanded: Boolean,\n    onToggleExpand: () -> Unit,\n    onDetailsClickFromList: () -> Unit,\n    onDeleteClickFromList: () -> Unit,\n    onEditClickFromList: () -> Unit,\n    modifier: Modifier = Modifier,\n    currentTimeZoneId: String\n) {\n  val eventDurationMinutes =\n      remember(event.startTime, event.endTime, currentTimeZoneId) {\n        val start = parseToInstant(event.startTime, currentTimeZoneId)\n        val end = parseToInstant(event.endTime, currentTimeZoneId)\n        if (start != null && end != null && end.isAfter(start)) {\n          Duration.between(start, end).toMinutes()\n        } else {\n          0L\n        }\n      }\n  val haptic = LocalHapticFeedback.current\n\n  val shapeParams =\n      remember(event.id) {\n        generateShapeParams(event.id) // Use helper\n      }\n\n  val starShape =\n      remember(shapeParams.numVertices, shapeParams.radiusSeed) {\n        RoundedPolygon.star(\n            numVerticesPerRadius = shapeParams.numVertices,\n            radius = shapeParams.radiusSeed,\n            innerRadius = cuid.SHAPEINNERRADIUS,\n            rounding = CornerRounding(cuid.ShapeCornerRounding))\n      }\n  val clipStar = remember(starShape) { RoundedPolygonShape(polygon = starShape) }\n  val clip2Star = remember(starShape) { RoundedPolygonShape(polygon = starShape) }\n\n  val starContainerSize =\n      remember(eventDurationMinutes, isMicroEventFromList) {\n        if (isMicroEventFromList || eventDurationMinutes <= 0L) 0.dp\n        else calculateShapeContainerSize(eventDurationMinutes)\n      }\n\n  // Compute the transitionColor\n  val transitionColorCard =\n      lerpOkLab(\n          start = colorScheme.primaryContainer,\n          stop = colorScheme.tertiaryContainer,\n          fraction = proximityRatio)\n  val darkerShadowColor = Color.Black\n\n  // --- Параметры текущего события (получаем isCurrentEvent) ---\n  //   val fixedColors = LocalFixedAccentColors.current\n\n  val cardElevation = if (isCurrentEvent) cuid.CurrentEventElevation else 0.dp\n  val starBackground =\n      when {\n        isCurrentEvent -> colorScheme.tertiaryContainer // Выделяем текущее\n        isNextEvent -> transitionColorCard // Слегка выделяем следующее (пример)\n        else -> colorScheme.primaryContainer // Обычный фон\n      }\n  val cardBackground by\n      animateColorAsState(\n          if (isCurrentEvent) colorScheme.tertiaryContainer else colorScheme.primaryContainer,\n          label = \"card color\")\n\n  val cardTextColor =\n      when {\n        isCurrentEvent -> colorScheme.onTertiaryContainer // Выделяем текущее\n        else -> colorScheme.onPrimaryContainer // Обычный фон\n      }\n  val textStyle =\n      when {\n        !isMicroEventFromList ->\n            if (isCurrentEvent) Typography.headlineSmallEmphasized else Typography.headlineSmall\n        else -> if (isCurrentEvent) Typography.bodyLargeEmphasized else Typography.bodyLarge\n      }\n  val cardFontFamily =\n      when {\n        isCurrentEvent ->\n            FontFamily(\n                Font(\n                    R.font.robotoflex_variable,\n                    variationSettings =\n                        FontVariation.Settings(\n                            FontVariation.weight(700),\n                            FontVariation.grade(70),\n                            FontVariation.width(65f),\n                            FontVariation.slant(-5f),\n                        )))\n        else ->\n            FontFamily(\n                Font(\n                    R.font.robotoflex_variable,\n                    variationSettings =\n                        FontVariation.Settings(\n                            FontVariation.weight(600),\n                            FontVariation.width(100f),\n                        )))\n      }\n  // --- Композиция UI ---\n  Box( // Корневой Box для тени, фона, высоты и кликабельности\n      modifier =\n          modifier\n              .shadow(\n                  elevation = cardElevation,\n                  shape = RoundedCornerShape(cuid.EventItemCornerRadius),\n                  clip = false,\n                  ambientColor = if (cardElevation > 0.dp) darkerShadowColor else Color.Transparent,\n                  spotColor = if (cardElevation > 0.dp) darkerShadowColor else Color.Transparent)\n              .clip(RoundedCornerShape(cuid.EventItemCornerRadius))\n              .background(cardBackground)\n              .height(targetHeightFromList)\n              .pointerInput(event.id) {\n                detectTapGestures(\n                    onTap = { onToggleExpand() },\n                    onLongPress = {\n                      haptic.performHapticFeedback(HapticFeedbackType.LongPress)\n                      onDetailsClickFromList()\n                    })\n              }) {\n        Column(modifier = Modifier.fillMaxSize()) {\n          Box(\n              modifier =\n                  Modifier.weight(1f) // Занимает все место, ОСТАВЛЯЯ место для кнопок снизу\n                      .fillMaxWidth()\n                      // Внутренние отступы для текста и звезды\n                      .padding(\n                          horizontal = cuid.ItemHorizontalPadding,\n                          vertical =\n                              if (isMicroEventFromList) cuid.MicroItemContentVerticalPadding\n                              else cuid.StandardItemContentVerticalPadding),\n              // Выравнивание контента можно оставить TopStart или изменить на Center, если нужно\n              contentAlignment = Alignment.TopStart) {\n                if (!isMicroEventFromList && starContainerSize > 0.dp) {\n                  val density = LocalDensity.current\n                  val starOffsetY = starContainerSize * shapeParams.offestParam\n                  val starOffsetX = starContainerSize * -shapeParams.offestParam\n                  val rotationAngle = shapeParams.rotationAngle\n                  val shadowColor = Color.Black.copy(alpha = 0.3f) // Переместил\n\n                  Box( // Тень\n                      modifier =\n                          Modifier.align(Alignment.CenterEnd) // Позиционирование звезды\n                              .graphicsLayer(\n                                  translationX =\n                                      with(density) {\n                                        (starOffsetX + shapeParams.shadowOffsetXSeed).toPx()\n                                      },\n                                  translationY =\n                                      with(density) {\n                                        (starOffsetY - shapeParams.shadowOffsetYSeed).toPx()\n                                      },\n                                  rotationZ = rotationAngle)\n                              .requiredSize(starContainerSize)\n                              .clip(clip2Star)\n                              .background(shadowColor))\n                  Box( // Основная фигура\n                      modifier =\n                          Modifier.align(Alignment.CenterEnd) // Позиционирование звезды\n                              .graphicsLayer(\n                                  translationX = with(density) { starOffsetX.toPx() },\n                                  translationY = with(density) { starOffsetY.toPx() },\n                                  rotationZ = rotationAngle)\n                              .requiredSize(starContainerSize)\n                              .clip(clipStar)\n                              .background(starBackground.copy(alpha = cuid.ShapeMainAlpha)))\n                }\n                if (isMicroEventFromList) {\n                  Row(\n                      modifier = Modifier.fillMaxSize(),\n                      verticalAlignment = Alignment.CenterVertically) {\n                        Text(\n                            text = event.summary,\n                            color = cardTextColor,\n                            style = textStyle,\n                            fontFamily = cardFontFamily,\n                            maxLines = 1,\n                            overflow = TextOverflow.Ellipsis,\n                            modifier = Modifier.weight(1f, fill = false))\n                        Spacer(modifier = Modifier.width(cuid.padding))\n                        Text(\n                            text = timeFormatter(event),\n                            color = cardTextColor,\n                            style = typography.labelMedium,\n                            maxLines = 1)\n                      }\n                } else {\n                  Column(verticalArrangement = Arrangement.Top) {\n                    Text(\n                        text = event.summary,\n                        color = cardTextColor,\n                        style = textStyle,\n                        fontFamily = cardFontFamily,\n                        maxLines = 1,\n                        overflow = TextOverflow.Ellipsis)\n                    Spacer(modifier = Modifier.height(2.dp))\n                    Row {\n                      Text(\n                          text = timeFormatter(event),\n                          color = cardTextColor,\n                          style = typography.labelSmall.copy(fontWeight = FontWeight.Normal),\n                          maxLines = 1)\n                      Spacer(modifier = Modifier.width(8.dp))\n                      event.location?.let {\n                        Text(\n                            text = it,\n                            color = cardTextColor,\n                            style = typography.labelSmall.copy(fontWeight = FontWeight.Normal),\n                            maxLines = 1)\n                      }\n                    }\n                  }\n                }\n              }\n          AnimatedVisibility(\n              visible = isExpanded,\n              enter =\n                  fadeIn(animationSpec = tween(durationMillis = 150, delayMillis = 100)) +\n                      expandVertically(\n                          animationSpec = tween(durationMillis = 250, delayMillis = 50),\n                          expandFrom = Alignment.Top),\n              exit =\n                  shrinkVertically(\n                      animationSpec = tween(durationMillis = 250), shrinkTowards = Alignment.Top) +\n                      fadeOut(animationSpec = tween(durationMillis = 150))) {\n                Row(\n                    modifier =\n                        Modifier.fillMaxWidth()\n                            .padding(horizontal = cuid.ItemHorizontalPadding, vertical = 4.dp),\n                    horizontalArrangement = Arrangement.End,\n                    verticalAlignment = Alignment.CenterVertically) {\n                      FilledIconButton(\n                          onClick = {\n                            onDetailsClickFromList()\n                            onToggleExpand()\n                          },\n                          modifier =\n                              Modifier.minimumInteractiveComponentSize()\n                                  .size(\n                                      IconButtonDefaults.smallContainerSize(\n                                          IconButtonDefaults.IconButtonWidthOption.Uniform)),\n                          shape = IconButtonDefaults.smallRoundShape) {\n                            Icon(\n                                imageVector = Icons.Filled.Info,\n                                contentDescription = \"info\",\n                            )\n                          }\n                      Spacer(modifier = Modifier.width(4.dp))\n                      Button(\n                          onClick = { onEditClickFromList() },\n                          contentPadding = PaddingValues(horizontal = 12.dp)) {\n                            Icon(Icons.Filled.Edit, contentDescription = \"Edit\")\n                            Spacer(Modifier.size(ButtonDefaults.IconSpacing))\n                            Text(\"Edit\")\n                          }\n                      FilledIconButton(\n                          onClick = { onDeleteClickFromList() },\n                          modifier =\n                              Modifier.minimumInteractiveComponentSize()\n                                  .size(\n                                      IconButtonDefaults.smallContainerSize(\n                                          IconButtonDefaults.IconButtonWidthOption.Narrow)),\n                          shape = IconButtonDefaults.smallRoundShape) {\n                            Icon(\n                                imageVector = Icons.Filled.Delete,\n                                contentDescription = \"Delete\",\n                            )\n                          }\n                    }\n              } // Конец AnimatedVisibility\n        }\n      } // Конец Column (контент + кнопки)\n} // Конец корневого Box\n\n@Composable\nfun AllDayEventItem(\n    event: EventDto,\n    isExpanded: Boolean,\n    onToggleExpand: () -> Unit,\n    onDeleteClick: () -> Unit,\n    onEditClick: () -> Unit,\n    onDetailsClick: () -> Unit,\n    modifier: Modifier = Modifier\n) {\n  val cardBackground = colorScheme.tertiaryContainer\n  val cardTextColor = colorScheme.onTertiaryContainer\n  val haptic = LocalHapticFeedback.current\n\n  Box(\n      modifier =\n          modifier\n              .fillMaxWidth()\n              .clip(RoundedCornerShape(cuid.EventItemCornerRadius))\n              .background(cardBackground)\n              .pointerInput(event.id) {\n                detectTapGestures(\n                    onTap = { onToggleExpand() },\n                    onLongPress = {\n                      haptic.performHapticFeedback(HapticFeedbackType.LongPress)\n                      onDetailsClick()\n                    })\n              }) {\n        Column(\n            modifier =\n                Modifier.fillMaxWidth()\n                    .padding(\n                        horizontal = CalendarUiDefaults.AllDayItemPadding,\n                        vertical = CalendarUiDefaults.AllDayItemVerticalContentPadding)) {\n              Text(\n                  text = event.summary,\n                  style = typography.bodyLarge,\n                  fontWeight = FontWeight.Medium,\n                  color = cardTextColor,\n                  textAlign = TextAlign.Center,\n                  modifier = Modifier.fillMaxWidth().padding(vertical = 3.dp),\n              )\n\n              AnimatedVisibility(\n                  visible = isExpanded,\n                  enter =\n                      fadeIn(animationSpec = tween(durationMillis = 150, delayMillis = 100)) +\n                          expandVertically(\n                              animationSpec = tween(durationMillis = 250, delayMillis = 50),\n                              expandFrom = Alignment.Top),\n                  exit =\n                      shrinkVertically(\n                          animationSpec = tween(durationMillis = 250),\n                          shrinkTowards = Alignment.Top) +\n                          fadeOut(animationSpec = tween(durationMillis = 150))) {\n                    Spacer(modifier = Modifier.height(8.dp))\n                    Row(\n                        modifier = Modifier.fillMaxWidth().padding(vertical = 4.dp),\n                        horizontalArrangement = Arrangement.Center,\n                        verticalAlignment = Alignment.CenterVertically) {\n                          Button(\n                              onClick = {\n                                onDetailsClick()\n                                onToggleExpand()\n                              },\n                              contentPadding = PaddingValues(horizontal = 12.dp),\n                              colors =\n                                  ButtonDefaults.buttonColors(\n                                      containerColor = colorScheme.onTertiary,\n                                      contentColor = colorScheme.tertiary)) {\n                                Icon(\n                                    Icons.Filled.Info,\n                                    contentDescription = \"Information\",\n                                    modifier = Modifier.size(ButtonDefaults.IconSize))\n                              }\n                          Spacer(modifier = Modifier.width(8.dp))\n                          Button(\n                              onClick = { onEditClick() },\n                              contentPadding = PaddingValues(horizontal = 12.dp),\n                              colors =\n                                  ButtonDefaults.buttonColors(\n                                      containerColor = colorScheme.onTertiary,\n                                      contentColor = colorScheme.tertiary)) {\n                                Icon(\n                                    Icons.Filled.Edit,\n                                    contentDescription = \"Редактировать\",\n                                    modifier = Modifier.size(ButtonDefaults.IconSize))\n                              }\n                          Spacer(modifier = Modifier.width(8.dp))\n                          Button(\n                              onClick = { onDeleteClick() },\n                              contentPadding = PaddingValues(horizontal = 12.dp),\n                              colors =\n                                  ButtonDefaults.buttonColors(\n                                      containerColor = colorScheme.onTertiary,\n                                      contentColor = colorScheme.tertiary)) {\n                                Icon(\n                                    Icons.Filled.Delete,\n                                    contentDescription = \"Удалить\",\n                                    modifier = Modifier.size(ButtonDefaults.IconSize))\n                              }\n                        }\n                  }\n            }\n      }\n}\n\nfun calculateEventHeight(durationMinutes: Long, isMicroEvent: Boolean): Dp {\n  return if (isMicroEvent) {\n    cuid.MicroEventHeight\n  } else {\n    val minHeight = cuid.MinEventHeight\n    val maxHeight = cuid.MaxEventHeight\n    val durationDouble = durationMinutes.toDouble()\n    val heightRange = maxHeight - minHeight\n\n    val x = (durationDouble - cuid.HeightSigmoidMidpointMinutes) / cuid.HeightSigmoidScaleFactor\n    val k = cuid.HeightSigmoidSteepness\n    val sigmoidOutput = 1.0 / (1.0 + exp(-k * x))\n\n    val calculatedHeight = minHeight + (heightRange * sigmoidOutput.toFloat())\n    calculatedHeight.coerceIn(minHeight, maxHeight)\n  }\n}\n\nfun calculateShapeContainerSize(durationMinutes: Long): Dp {\n  val minStarContainerSize = cuid.MinStarContainerSize\n  val maxStarContainerSize = cuid.MaxStarContainerSize\n  val durationDouble = durationMinutes.toDouble()\n  val heightRange = maxStarContainerSize - minStarContainerSize\n\n  val x = (durationDouble - cuid.HeightSigmoidMidpointMinutes) / cuid.HeightSigmoidScaleFactor\n  val k = cuid.HeightSigmoidSteepness\n  val sigmoidOutput = 1.0 / (1.0 + exp(-k * x))\n\n  val calculatedHeight = minStarContainerSize + (heightRange * sigmoidOutput.toFloat())\n  return calculatedHeight.coerceIn(minStarContainerSize, maxStarContainerSize)\n}\n\nfun generateShapeParams(eventId: String): GeneratedShapeParams {\n  val hashCode = eventId.hashCode()\n  val absHashCode = abs(hashCode)\n\n  val numVertices = (absHashCode % cuid.ShapeMaxVerticesDelta) + cuid.ShapeMinVertices\n\n  val shadowOffsetXSeed = absHashCode % cuid.ShapeShadowOffsetXMaxModulo\n  val shadowOffsetYSeed =\n      absHashCode % cuid.ShapeShadowOffsetYMaxModulo + cuid.ShapeShadowOffsetYMin\n\n  val offsetParam = (absHashCode % 4 + 1) * cuid.ShapeOffsetParamMultiplier\n\n  val radiusBaseHash = absHashCode / 3 + 42\n  val radiusSeed =\n      ((radiusBaseHash % cuid.ShapeRadiusSeedRangeModulo) * cuid.ShapeRadiusSeedRange) +\n          cuid.ShapeRadiusSeedMin\n  val coercedRadiusSeed = radiusSeed.coerceIn(cuid.ShapeRadiusSeedMin, cuid.ShapeMaxRadius)\n\n  val angleSeed = (abs(hashCode) / 5 - 99).mod(cuid.ShapeRotationMaxDegrees)\n  val rotationAngle = (angleSeed + cuid.ShapeRotationOffsetDegrees)\n\n  return GeneratedShapeParams(\n      numVertices = numVertices,\n      radiusSeed = coercedRadiusSeed,\n      rotationAngle = rotationAngle,\n      shadowOffsetXSeed = shadowOffsetXSeed.dp,\n      shadowOffsetYSeed = shadowOffsetYSeed.dp,\n      offestParam = offsetParam)\n}\n\nfun lerpOkLab(start: Color, stop: Color, fraction: Float): Color {\n  val startOklab = start.convert(ColorSpaces.Oklab)\n  val stopOklab = stop.convert(ColorSpaces.Oklab)\n\n  val l = startOklab.component1() + (stopOklab.component1() - startOklab.component1()) * fraction\n  val a = startOklab.component2() + (stopOklab.component2() - startOklab.component2()) * fraction\n  val b = startOklab.component3() + (stopOklab.component3() - startOklab.component3()) * fraction\n  val alpha = startOklab.alpha + (stopOklab.alpha - startOklab.alpha) * fraction\n\n  return Color(l, a, b, alpha, ColorSpaces.Oklab).convert(ColorSpaces.Srgb)\n}\n",
      "info": {
        "size": 25024,
        "last_modified": "2025-08-06T08:35:04.171609",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/ui/CalendarViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.ui\n\nimport android.app.Activity\nimport android.content.Intent\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.core.common.EventNetworkState\nimport com.lpavs.caliinda.core.data.auth.AuthManager\nimport com.lpavs.caliinda.core.data.di.ITimeTicker\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.repository.CalendarRepository\nimport com.lpavs.caliinda.feature.agent.data.AiInteractionManager\nimport com.lpavs.caliinda.feature.agent.data.model.AiVisualizerState\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport java.time.Instant\nimport java.time.LocalDate\nimport javax.inject.Inject\n\n@HiltViewModel\nclass CalendarViewModel\n@Inject\nconstructor(\n    private val authManager: AuthManager,\n    private val calendarRepository: CalendarRepository,\n    private val aiInteractionManager: AiInteractionManager,\n    timeTicker: ITimeTicker,\n) : ViewModel() {\n\n  // --- ОСНОВНОЕ СОСТОЯНИЕ UI ---\n  private val _uiState = MutableStateFlow(CalendarState())\n  val state: StateFlow<CalendarState> = _uiState.asStateFlow()\n\n  private var initialAuthCheckCompletedAndProcessed = false\n\n  // --- ДЕЛЕГИРОВАННЫЕ И ПРОИЗВОДНЫЕ СОСТОЯНИЯ ДЛЯ UI ---\n  val currentTime: StateFlow<Instant> = timeTicker.currentTime\n\n  // Состояния Календаря\n  private val _currentVisibleDate = MutableStateFlow(LocalDate.now())\n  val currentVisibleDate: StateFlow<LocalDate> = _currentVisibleDate.asStateFlow()\n  val rangeNetworkState: StateFlow<EventNetworkState> = calendarRepository.rangeNetworkState\n\n  private val _eventFlow = MutableSharedFlow<CalendarUiEvent>()\n  val eventFlow: SharedFlow<CalendarUiEvent> = _eventFlow.asSharedFlow()\n\n  // Состояния AI\n  val aiState: StateFlow<AiVisualizerState> = aiInteractionManager.aiState\n  val aiMessage: StateFlow<String?> =\n      aiInteractionManager.aiMessage // Сообщение от AI (Asking/Result)\n\n  init {\n    observeAuthState()\n    observeAiState()\n    observeCalendarNetworkState()\n  }\n\n  private fun observeAuthState() {\n    viewModelScope.launch {\n      authManager.authState.collect { authState ->\n        val previousUiState = _uiState.value\n        _uiState.update { currentState ->\n          currentState.copy(\n              isSignedIn = authState.isSignedIn,\n              userEmail = authState.userEmail,\n              displayName = authState.displayName,\n              photo = authState.photoUrl,\n              isLoading = calculateIsLoading(authLoading = authState.isLoading),\n              authorizationIntent = authState.authorizationIntent)\n        }\n\n        authState.authError?.let { error ->\n          _eventFlow.emit(CalendarUiEvent.ShowMessage(error))\n          authManager.clearAuthError()\n        }\n        if (!initialAuthCheckCompletedAndProcessed && !authState.isLoading) {\n          initialAuthCheckCompletedAndProcessed = true\n          Log.d(TAG, \"Initial auth check completed and processed.\")\n          if (!authState.isSignedIn && authState.authError == null) {\n            Log.d(TAG, \"Initial auth check: Showing sign-in required dialog.\")\n            _uiState.update { it.copy(showSignInRequiredDialog = true) }\n          }\n        }\n        if (authState.isSignedIn && _uiState.value.showSignInRequiredDialog) {\n          _uiState.update { it.copy(showSignInRequiredDialog = false) }\n        }\n        if (authState.isSignedIn && !previousUiState.isSignedIn) {\n          _uiState.update { it.copy(showSignInRequiredDialog = false) }\n        }\n        if (authState.isSignedIn && !previousUiState.isSignedIn) {\n          Log.d(TAG, \"Auth observer: User signed in. Triggering calendar refresh\")\n          calendarRepository.setCurrentVisibleDate(currentVisibleDate.value, forceRefresh = true)\n        }\n      }\n    }\n  }\n\n  private fun observeAiState() {\n    viewModelScope.launch {\n      aiInteractionManager.aiState.collect { ai ->\n        _uiState.update { currentUiState ->\n          // Обновляем только состояние isLoading и isListening\n          currentUiState.copy(\n              isListening = ai == AiVisualizerState.LISTENING,\n              isLoading = calculateIsLoading(aiState = ai))\n        }\n        if (ai == AiVisualizerState.RESULT) {\n          Log.d(TAG, \"AI observer: Interaction finished with RESULT, triggering calendar refresh.\")\n          refreshCurrentVisibleDate()\n        }\n      }\n    }\n  }\n\n  private fun observeCalendarNetworkState() {\n    viewModelScope.launch {\n      calendarRepository.rangeNetworkState.collect { network ->\n        _uiState.update { it.copy(isLoading = calculateIsLoading(networkState = network)) }\n\n        if (network is EventNetworkState.Error) {\n          if (authManager.authState.value.authError == null) {\n            _eventFlow.emit(CalendarUiEvent.ShowMessage(network.message))\n          }\n        }\n      }\n    }\n  }\n\n  // --- ПРИВАТНЫЙ ХЕЛПЕР ДЛЯ РАСЧЕТА ОБЩЕГО isLoading ---\n  /** Рассчитывает общее состояние загрузки, комбинируя состояния менеджеров */\n  private fun calculateIsLoading(\n      authLoading: Boolean =\n          authManager.authState.value.isLoading, // Берем текущие значения по умолчанию\n      networkState: EventNetworkState = calendarRepository.rangeNetworkState.value,\n      aiState: AiVisualizerState = aiInteractionManager.aiState.value,\n  ): Boolean {\n    val calendarLoading = networkState is EventNetworkState.Loading\n    val aiThinking = aiState == AiVisualizerState.THINKING\n\n    return authLoading || calendarLoading || aiThinking\n  }\n\n  // --- ДЕЙСТВИЯ АУТЕНТИФИКАЦИИ ---\n  fun signIn(activity: Activity) {\n    if (_uiState.value.showSignInRequiredDialog) {\n      _uiState.update { it.copy(showSignInRequiredDialog = false) }\n    }\n    authManager.signIn(activity)\n  }\n\n  fun handleAuthorizationResult(intent: Intent) {\n    authManager.handleAuthorizationResult(intent)\n  }\n\n  fun signOut() {\n    if (_uiState.value.showSignInRequiredDialog) {\n      _uiState.update { it.copy(showSignInRequiredDialog = false) }\n    }\n    authManager.signOut()\n  }\n\n  fun clearAuthorizationIntent() {\n    authManager.clearAuthorizationIntent()\n  }\n\n  fun onSignInRequiredDialogDismissed() {\n    _uiState.update { it.copy(showSignInRequiredDialog = false) }\n    Log.d(TAG, \"Sign-in required dialog was dismissed by the user.\")\n  }\n\n  // --- ДЕЙСТВИЯ КАЛЕНДАРЯ ---\n  fun onVisibleDateChanged(newDate: LocalDate) {\n    if (newDate == _currentVisibleDate.value) return\n    _currentVisibleDate.value = newDate\n    viewModelScope.launch { calendarRepository.setCurrentVisibleDate(newDate) }\n  }\n\n  fun getEventsFlowForDate(date: LocalDate): Flow<List<EventDto>> =\n      calendarRepository.getEventsFlowForDate(date)\n\n  fun refreshCurrentVisibleDate() {\n    viewModelScope.launch { calendarRepository.refreshDate(currentVisibleDate.value) }\n  }\n\n  // --- ДЕЙСТВИЯ AI ---\n  fun startListening() {\n    if (!_uiState.value.isPermissionGranted) {\n      viewModelScope.launch {\n        _eventFlow.emit(CalendarUiEvent.ShowMessage(\"Нет разрешения на запись аудио\"))\n      }\n      return\n    }\n    aiInteractionManager.startListening()\n  }\n\n  fun stopListening() = aiInteractionManager.stopListening()\n\n  fun sendTextMessage(text: String) {\n    if (!_uiState.value.isSignedIn) {\n      Log.w(TAG, \"Cannot send message: Not signed in.\")\n      return\n    }\n    aiInteractionManager.sendTextMessage(text)\n  }\n\n  fun resetAiStateAfterResult() = aiInteractionManager.resetAiState()\n\n  fun resetAiStateAfterAsking() = aiInteractionManager.resetAiState()\n\n  // --- ОБРАБОТКА UI СОБЫТИЙ / РАЗРЕШЕНИЙ ---\n  fun updatePermissionStatus(isGranted: Boolean) {\n    if (_uiState.value.isPermissionGranted != isGranted) {\n      _uiState.update { it.copy(isPermissionGranted = isGranted) }\n      Log.d(TAG, \"Audio permission status updated to: $isGranted\")\n    }\n  }\n\n  // --- LIFECYCLE ---\n  override fun onCleared() {\n    super.onCleared()\n    aiInteractionManager.destroy() // Вызываем очистку менеджера AI\n  }\n\n  // --- COMPANION ---\n  companion object {\n    private const val TAG = \"CalendarViewModel\" // Используем один TAG\n  }\n}\n\nsealed class CalendarUiEvent {\n  data class ShowMessage(val message: String) : CalendarUiEvent()\n}\n",
      "info": {
        "size": 8945,
        "last_modified": "2025-08-06T08:35:04.175677",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/data/onEventResults/CreateEventResult.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.data.onEventResults\n\nsealed interface CreateEventResult {\n  object Idle : CreateEventResult\n\n  object Loading : CreateEventResult\n\n  object Success : CreateEventResult\n\n  data class Error(val message: String) : CreateEventResult\n}\n",
      "info": {
        "size": 275,
        "last_modified": "2025-08-06T08:35:04.180602",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/data/onEventResults/DeleteEventResult.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.data.onEventResults\n\nsealed interface DeleteEventResult {\n  object Idle : DeleteEventResult\n\n  object Loading : DeleteEventResult\n\n  object Success : DeleteEventResult\n\n  data class Error(val message: String) : DeleteEventResult\n}\n",
      "info": {
        "size": 275,
        "last_modified": "2025-08-06T08:35:04.182446",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/calendar/data/onEventResults/EditEventResult.kt",
      "content": "package com.lpavs.caliinda.feature.calendar.data.onEventResults\n\nsealed interface UpdateEventResult {\n  object Idle : UpdateEventResult\n\n  object Loading : UpdateEventResult\n\n  data class Success(val updatedEventId: String) :\n      UpdateEventResult // Возвращаем ID, т.к. он может измениться\n\n  data class Error(val message: String) : UpdateEventResult\n}\n",
      "info": {
        "size": 385,
        "last_modified": "2025-08-06T08:35:04.184099",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/details/EventDetailsDialog.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.details\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.wrapContentHeight\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material.icons.filled.LocationOn\nimport androidx.compose.material.icons.filled.Repeat\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FilledIconButton\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButtonDefaults\nimport androidx.compose.material3.MaterialShapes\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.minimumInteractiveComponentSize\nimport androidx.compose.material3.toShape\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.draw.rotate\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.window.Dialog\nimport androidx.compose.ui.window.DialogProperties\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.ui.util.DateTimeFormatterUtil\nimport com.lpavs.caliinda.core.ui.util.DateTimeFormatterUtil.formatRRule\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils.parseToInstant\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun CustomEventDetailsDialog(\n    event: EventDto,\n    userTimeZone: String,\n    onDismissRequest: () -> Unit,\n    viewModel: CalendarViewModel,\n    eventManagementViewModel: EventManagementViewModel\n) {\n  val context = LocalContext.current\n  val currentLocale = LocalConfiguration.current.getLocales().get(0)\n  val timeFormatterLambda: (EventDto) -> String =\n      remember(viewModel, userTimeZone, currentLocale) {\n        { event ->\n          DateTimeFormatterUtil.formatEventDetailsTime(context, event, userTimeZone, currentLocale)\n        }\n      }\n  val currentTime by viewModel.currentTime.collectAsStateWithLifecycle()\n  val isCurrent =\n      remember(currentTime, event.startTime, event.endTime) {\n        val start = parseToInstant(event.startTime, userTimeZone)\n        val end = parseToInstant(event.endTime, userTimeZone)\n        start != null && end != null && !currentTime.isBefore(start) && currentTime.isBefore(end)\n      }\n  Dialog(\n      onDismissRequest = onDismissRequest,\n      properties =\n          DialogProperties(\n              dismissOnBackPress = true,\n              dismissOnClickOutside = true,\n              usePlatformDefaultWidth = false)) {\n        Surface(\n            modifier = Modifier.fillMaxWidth(0.9f).wrapContentHeight(),\n            shape = RoundedCornerShape(25.dp),\n            color = if (!isCurrent) colorScheme.primaryContainer else colorScheme.tertiaryContainer,\n            tonalElevation = 8.dp) {\n              val onCardText =\n                  if (!isCurrent) colorScheme.onPrimaryContainer\n                  else colorScheme.onTertiaryContainer\n              Box(modifier = Modifier.fillMaxWidth()) {\n                Box(\n                    modifier =\n                        Modifier.align(Alignment.BottomEnd)\n                            .size(250.dp)\n                            .rotate(75f)\n                            .offset(y = (-50).dp, x = 50.dp)\n                            .clip(MaterialShapes.Cookie7Sided.toShape())\n                            .border(\n                                width = 2.dp,\n                                color = onCardText.copy(alpha = 0.2f),\n                                shape = MaterialShapes.Cookie7Sided.toShape())\n                            .background(onCardText.copy(alpha = 0f))) {}\n\n                Column(\n                    modifier =\n                        Modifier.padding(top = 24.dp, start = 24.dp, end = 24.dp, bottom = 12.dp),\n                    horizontalAlignment = Alignment.Start) {\n                      Text(\n                          text = event.summary,\n                          style = typography.displaySmall.copy(fontWeight = FontWeight.SemiBold),\n                          color = onCardText)\n                      Spacer(modifier = Modifier.height(2.dp))\n                      Row {\n                        Text(\n                            text = timeFormatterLambda(event),\n                            color = onCardText,\n                            style = typography.headlineSmall.copy(fontWeight = FontWeight.Normal),\n                            maxLines = 2)\n                      }\n                      Spacer(modifier = Modifier.height(16.dp))\n\n                      if (!event.description.isNullOrBlank()) {\n                        Text(\n                            text = event.description,\n                            style = typography.bodyMedium,\n                            color = onCardText)\n                        Spacer(modifier = Modifier.height(16.dp))\n                      }\n\n                      if (!event.location.isNullOrBlank()) {\n                        DetailRow(Icons.Filled.LocationOn, event.location, color = onCardText)\n                        Spacer(modifier = Modifier.height(16.dp))\n                      }\n\n                      if (!event.recurrenceRule.isNullOrEmpty()) {\n                        DetailRow(\n                            Icons.Filled.Repeat,\n                            formatRRule(event.recurrenceRule, zoneIdString = userTimeZone),\n                            color = onCardText)\n                      }\n                      Spacer(modifier = Modifier.height(20.dp))\n                      Row(\n                          modifier = Modifier.fillMaxWidth(),\n                          verticalAlignment = Alignment.CenterVertically,\n                          horizontalArrangement = Arrangement.End) {\n                            Button(\n                                onClick = { eventManagementViewModel.requestEditEvent(event) },\n                                contentPadding = PaddingValues(horizontal = 12.dp)) {\n                                  Icon(Icons.Filled.Edit, contentDescription = \"Edit\")\n                                  Spacer(Modifier.size(ButtonDefaults.IconSpacing))\n                                  Text(\"Edit\") // Или локализованная строка\n                                }\n                            //                    Spacer(modifier = Modifier.width(4.dp))\n                            FilledIconButton(\n                                onClick = {\n                                  eventManagementViewModel.requestDeleteConfirmation(event)\n                                },\n                                modifier =\n                                    Modifier.minimumInteractiveComponentSize()\n                                        .size(\n                                            IconButtonDefaults.smallContainerSize(\n                                                IconButtonDefaults.IconButtonWidthOption.Narrow)),\n                                shape = IconButtonDefaults.smallRoundShape) {\n                                  Icon(\n                                      imageVector = Icons.Filled.Delete,\n                                      contentDescription = \"Delete\",\n                                  )\n                                }\n                          }\n                    }\n              }\n            }\n      }\n}\n\n@Composable\nprivate fun DetailRow(icon: ImageVector, value: String, color: Color) {\n  Row(modifier = Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {\n    Icon(imageVector = icon, contentDescription = \"Описание иконки\")\n    Spacer(Modifier.size(ButtonDefaults.IconSpacing))\n    Text(text = value, style = typography.bodyLarge, color = color)\n    Spacer(modifier = Modifier.height(8.dp))\n  }\n}\n",
      "info": {
        "size": 9343,
        "last_modified": "2025-08-06T08:35:04.188476",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/sections/TimeSection.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections\n\nimport android.text.format.DateFormat\nimport android.util.Log\nimport androidx.annotation.StringRes\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.animateContentSize\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.slideOutVertically\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.horizontalScroll\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material3.FilterChip\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.input.ImeAction\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.event_management.ui.shared.DatePickerField\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerField\nimport java.time.DayOfWeek\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter\nimport java.time.format.FormatStyle\nimport java.time.format.TextStyle\nimport java.util.Locale\n\nenum class RecurrenceEndType {\n  NEVER,\n  DATE,\n  COUNT\n}\n\ndata class EventDateTimeState(\n    val startDate: LocalDate,\n    val startTime: LocalTime?,\n    val endDate: LocalDate,\n    val endTime: LocalTime?,\n    val isAllDay: Boolean,\n    val isRecurring: Boolean,\n    val recurrenceRule: String? = null,\n    val selectedWeekdays: Set<DayOfWeek> = emptySet(),\n    val recurrenceEndType: RecurrenceEndType = RecurrenceEndType.NEVER,\n    val recurrenceEndDate: LocalDate? = null,\n    val recurrenceCount: Int? = null\n)\n\n@Composable\nfun EventDateTimePicker(\n    modifier: Modifier = Modifier,\n    state: EventDateTimeState,\n    onStateChange: (EventDateTimeState) -> Unit,\n    isLoading: Boolean = false,\n    onRequestShowStartDatePicker: () -> Unit,\n    onRequestShowStartTimePicker: () -> Unit,\n    onRequestShowEndDatePicker: () -> Unit,\n    onRequestShowEndTimePicker: () -> Unit,\n    onRequestShowRecurrenceEndDatePicker: () -> Unit,\n) {\n  Log.d(\"EventDateTimePicker\", \"Received state: $state\")\n  var isAllDay by remember { mutableStateOf(state.isAllDay) }\n  var isOneDay by remember { mutableStateOf(state.startDate == state.endDate) }\n\n  var dateTimeError by remember { mutableStateOf<String?>(null) }\n  val context = LocalContext.current\n\n  val allDay = stringResource(R.string.all_day)\n  val oneDay = stringResource(R.string.one_day)\n  val recEvent = stringResource(R.string.recurrence_event)\n  val endsLabel = stringResource(R.string.recurrence_ends)\n  val endNeverLabel = stringResource(R.string.recurrence_end_never)\n  val endDateLabel = stringResource(R.string.recurrence_end_date)\n  val endCountLabel = stringResource(R.string.recurrence_end_count)\n  val recurrenceCountFieldLabel = stringResource(R.string.recurrence_count_field)\n\n  val weekdays = remember { DayOfWeek.entries.toTypedArray() }\n\n  // --- Форматтеры для отображения (без изменений) ---\n  val deviceDateFormatter = remember {\n    DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).withLocale(Locale.getDefault())\n  }\n  val deviceTimeFormatter =\n      remember(context) {\n        val pattern = if (DateFormat.is24HourFormat(context)) \"HH:mm\" else \"h:mm a\"\n        DateTimeFormatter.ofPattern(pattern, Locale.getDefault())\n      }\n  LaunchedEffect(state.isAllDay) {\n    if (isAllDay != state.isAllDay) {\n      isAllDay = state.isAllDay\n    }\n  }\n  LaunchedEffect(state.startDate, state.endDate) {\n    val actualIsOneDay = state.startDate == state.endDate\n    if (isOneDay != actualIsOneDay) {\n      isOneDay = actualIsOneDay\n    }\n  }\n\n  LaunchedEffect(state) {\n    dateTimeError = null\n    val actualIsOneDay = state.startDate == state.endDate\n\n    if (!actualIsOneDay && state.endDate.isBefore(state.startDate)) {\n      dateTimeError = context.getString(R.string.error_end_date_before_start)\n    } else if (!state.isAllDay) {\n      if (state.startTime == null) {\n        dateTimeError = context.getString(R.string.error_start_time_missing)\n      } else if (state.endTime == null) {\n        dateTimeError = context.getString(R.string.error_end_time_missing)\n      } else {\n        val startDateTime = state.startTime.atDate(state.startDate)\n        val endDateTime = state.endTime.atDate(state.endDate)\n        if (!startDateTime.isBefore(endDateTime)) {\n          dateTimeError = context.getString(R.string.error_end_time_not_after_start)\n        }\n      }\n    }\n  }\n\n  Column(modifier = modifier) {\n    // --- Filter Chips ---\n    Row(\n        modifier = Modifier.fillMaxWidth().padding(bottom = 8.dp),\n        horizontalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally),\n    ) {\n      // --- Чип \"All Day\" ---\n      FilterChip(\n          selected = isAllDay,\n          onClick = {\n            val newIsAllDay = !isAllDay\n\n            val newState: EventDateTimeState\n            if (newIsAllDay) {\n              newState = state.copy(isAllDay = true, startTime = null, endTime = null)\n            } else {\n              val defaultStartTime =\n                  state.startTime\n                      ?: LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0)\n\n              var newEndTime = state.endTime\n              var newEndDate = state.endDate\n\n              if (state.startDate == state.endDate) {\n                if (newEndTime == null || !defaultStartTime.isBefore(newEndTime)) {\n                  newEndTime = defaultStartTime.plusHours(1)\n                }\n                if (newEndTime != null) {\n                  newEndTime = newEndTime.withNano(0)\n                }\n\n                if (newEndTime != null) {\n                  if (newEndTime.isBefore(defaultStartTime)) {\n                    newEndDate = state.startDate.plusDays(1)\n                  }\n                }\n              } else {\n                if (newEndTime == null) {\n                  newEndTime = defaultStartTime.plusHours(1)\n                }\n                if (newEndTime != null) {\n                  newEndTime = newEndTime.withNano(0)\n                }\n              }\n\n              newState =\n                  state.copy(\n                      isAllDay = false,\n                      startTime = defaultStartTime,\n                      endTime = newEndTime,\n                      endDate = newEndDate)\n            }\n            onStateChange(newState)\n          },\n          label = { Text(allDay) },\n          enabled = !isLoading)\n\n      // --- Чип \"One Day\" ---\n      FilterChip(\n          selected = isOneDay,\n          onClick = {\n            val currentActualIsOneDay = state.startDate == state.endDate\n            val targetIsOneDay = !currentActualIsOneDay\n\n            val newEndDateCandidate: LocalDate\n            var newEndTimeCandidate = state.endTime\n\n            if (targetIsOneDay) {\n              newEndDateCandidate = state.startDate\n\n              if (!state.isAllDay && state.startTime != null) {\n                val currentStartTime = state.startTime\n                if (newEndTimeCandidate == null ||\n                    !currentStartTime.isBefore(newEndTimeCandidate)) {\n                  newEndTimeCandidate = currentStartTime.plusHours(1).withNano(0)\n                  if (newEndTimeCandidate.isBefore(currentStartTime)) {\n                    newEndTimeCandidate = LocalTime.of(23, 59, 0, 0)\n                  }\n                }\n              }\n            } else {\n              newEndDateCandidate = state.startDate.plusDays(1)\n            }\n            onStateChange(state.copy(endDate = newEndDateCandidate, endTime = newEndTimeCandidate))\n          },\n          label = { Text(oneDay) },\n          enabled = !isLoading)\n\n      // --- Чип \"Recurring\" ---\n      FilterChip(\n          selected = state.isRecurring,\n          onClick = {\n            val newIsRecurring = !state.isRecurring\n            val newRule =\n                if (!newIsRecurring) {\n                  null\n                } else {\n                  state.recurrenceRule ?: RecurrenceOption.Daily.rruleValue\n                }\n            onStateChange(state.copy(isRecurring = newIsRecurring, recurrenceRule = newRule))\n          },\n          label = { Text(recEvent) },\n          enabled = !isLoading)\n    }\n\n    AnimatedVisibility(\n        visible = dateTimeError != null,\n        enter = fadeIn() + expandVertically(),\n        exit = fadeOut() + shrinkVertically()) {\n          Column {\n            Text(\n                text = dateTimeError ?: \"\",\n                color = colorScheme.error,\n                style = typography.bodySmall,\n                modifier = Modifier.padding(horizontal = 8.dp))\n            Spacer(modifier = Modifier.height(4.dp))\n          }\n        }\n\n    // --- Поля ввода Даты/Времени ---\n    Column(\n        modifier = Modifier.animateContentSize(animationSpec = tween(300)),\n        verticalArrangement = Arrangement.spacedBy(8.dp)) {\n          AnimatedContent(\n              targetState = Pair(isAllDay, isOneDay),\n              transitionSpec = {\n                if (targetState.first != initialState.first ||\n                        targetState.second != initialState.second) {\n                      (fadeIn(animationSpec = tween(220, delayMillis = 90)) +\n                          slideInVertically(\n                              initialOffsetY = { it / 4 },\n                              animationSpec = tween(270, delayMillis = 90))) togetherWith\n                          (fadeOut(animationSpec = tween(90)) +\n                              slideOutVertically(\n                                  targetOffsetY = { -it / 4 }, animationSpec = tween(120)))\n                    } else {\n                      fadeIn(animationSpec = tween(0)) togetherWith\n                          fadeOut(animationSpec = tween(0))\n                    }\n                    .using(SizeTransform(clip = true, sizeAnimationSpec = { _, _ -> tween(250) }))\n              },\n              label = \"DateTimeFieldsAnimation\") { targetLayoutState ->\n                val (showAllDay, showOneDay) = targetLayoutState\n                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {\n                  when {\n                    showAllDay && showOneDay -> {\n                      DatePickerField(\n                          state.startDate,\n                          deviceDateFormatter,\n                          isLoading,\n                          onRequestShowStartDatePicker,\n                          Modifier.fillMaxWidth().padding(horizontal = 50.dp))\n                    }\n\n                    showAllDay -> {\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(8.dp),\n                          Alignment.Top) {\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.weight(1f))\n                            DatePickerField(\n                                state.endDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowEndDatePicker,\n                                Modifier.weight(1f))\n                          }\n                    }\n\n                    showOneDay -> {\n                      Column(\n                          horizontalAlignment = Alignment.CenterHorizontally,\n                          verticalArrangement = Arrangement.spacedBy(8.dp)) {\n                            Row(\n                                Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                                Arrangement.spacedBy(4.dp, Alignment.CenterHorizontally),\n                                Alignment.CenterVertically) {\n                                  TimePickerField(\n                                      state.startTime,\n                                      deviceTimeFormatter,\n                                      isLoading,\n                                      onRequestShowStartTimePicker,\n                                      Modifier.width(100.dp),\n                                      onLongClick = {\n                                        val selectedTime = LocalTime.now()\n                                        var newEndTime = state.endTime\n                                        if (state.startDate == state.endDate &&\n                                            state.endTime != null &&\n                                            !selectedTime.isBefore(state.endTime)) {\n                                          newEndTime = selectedTime.plusHours(1).withNano(0)\n                                        }\n                                        onStateChange(\n                                            state.copy(\n                                                startTime = selectedTime, endTime = newEndTime))\n                                      })\n                                  Box(\n                                      modifier =\n                                          Modifier.width(10.dp)\n                                              .height(1.dp)\n                                              .background(color = colorScheme.onBackground))\n                                  TimePickerField(\n                                      state.endTime,\n                                      deviceTimeFormatter,\n                                      isLoading,\n                                      onRequestShowEndTimePicker,\n                                      Modifier.width(100.dp),\n                                  )\n                                }\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.width(218.dp))\n                          }\n                    }\n\n                    else -> {\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(16.dp, Alignment.CenterHorizontally),\n                          Alignment.Top) {\n                            TimePickerField(\n                                state.startTime,\n                                deviceTimeFormatter,\n                                isLoading,\n                                onRequestShowStartTimePicker,\n                                Modifier.weight(1f),\n                                onLongClick = {\n                                  val selectedTime = LocalTime.now()\n                                  var newEndTime = state.endTime\n                                  if (state.startDate == state.endDate &&\n                                      state.endTime != null &&\n                                      !selectedTime.isBefore(state.endTime)) {\n                                    newEndTime = selectedTime.plusHours(1).withNano(0)\n                                  }\n                                  onStateChange(\n                                      state.copy(startTime = selectedTime, endTime = newEndTime))\n                                })\n                            TimePickerField(\n                                state.endTime,\n                                deviceTimeFormatter,\n                                isLoading,\n                                onRequestShowEndTimePicker,\n                                Modifier.weight(1f))\n                          }\n                      Row(\n                          Modifier.fillMaxWidth().padding(horizontal = 4.dp),\n                          Arrangement.spacedBy(8.dp),\n                          Alignment.Top) {\n                            DatePickerField(\n                                state.startDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowStartDatePicker,\n                                Modifier.weight(1f))\n                            DatePickerField(\n                                state.endDate,\n                                deviceDateFormatter,\n                                isLoading,\n                                onRequestShowEndDatePicker,\n                                Modifier.weight(1f))\n                          }\n                    }\n                  }\n                }\n              } // End AnimatedContent\n        } // End Column for Date/Time fields with animateContentSize\n\n    // --- Настройки повторения (АНИМИРОВАННЫЕ) ---\n    AnimatedVisibility(\n        visible = state.isRecurring,\n        enter =\n            fadeIn(animationSpec = tween(150, delayMillis = 50)) +\n                expandVertically(animationSpec = tween(300)),\n        exit = fadeOut(animationSpec = tween(150)) + shrinkVertically(animationSpec = tween(300)),\n        modifier = Modifier.padding(top = 8.dp)) {\n          Column {\n            // --- Чипы для выбора частоты RRULE ---\n            Row(\n                modifier =\n                    Modifier.fillMaxWidth()\n                        .padding(horizontal = 8.dp)\n                        .horizontalScroll(rememberScrollState()), // Горизонтальная прокрутка\n                horizontalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally),\n            ) {\n              // Вычисляем текущий выбор один раз\n              val currentSelection =\n                  remember(state.recurrenceRule) { RecurrenceOption.fromRule(state.recurrenceRule) }\n\n              // --- Явно создаем каждый чип ---\n              // Чип \"Ежедневно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Daily,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Еженедельно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Weekly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Ежемесячно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Monthly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n\n              // Чип \"Ежегодно\"\n              FilterChipForOption(\n                  option = RecurrenceOption.Yearly,\n                  currentSelection = currentSelection,\n                  isLoading = isLoading,\n                  onStateChange = onStateChange,\n                  state = state)\n            }\n            AnimatedVisibility(\n                visible =\n                    state.recurrenceRule ==\n                        RecurrenceOption.Weekly.rruleValue, // Показываем только для Weekly\n                enter =\n                    fadeIn(animationSpec = tween(150, delayMillis = 50)) +\n                        expandVertically(animationSpec = tween(300)),\n                exit =\n                    fadeOut(animationSpec = tween(150)) +\n                        shrinkVertically(animationSpec = tween(300)),\n            ) {\n              Column {\n                // --- Чипы для дней недели ---\n                Row(\n                    modifier =\n                        Modifier.fillMaxWidth()\n                            .padding(horizontal = 8.dp)\n                            .horizontalScroll(rememberScrollState()),\n                    // Центрируем дни недели, если их немного\n                    horizontalArrangement =\n                        Arrangement.spacedBy(4.dp, Alignment.CenterHorizontally)) {\n                      weekdays.forEach { day ->\n                        val isSelected = day in state.selectedWeekdays\n                        FilterChip(\n                            selected = isSelected,\n                            onClick = {\n                              val currentDays = state.selectedWeekdays\n                              val newDays =\n                                  if (isSelected) {\n                                    // Не даем убрать последний выбранный день, если он один\n                                    if (currentDays.size > 1) currentDays - day else currentDays\n                                  } else {\n                                    currentDays + day\n                                  }\n                              onStateChange(state.copy(selectedWeekdays = newDays))\n                            },\n                            label = {\n                              Text(day.getDisplayName(TextStyle.SHORT, Locale.getDefault()))\n                            },\n                            enabled = !isLoading)\n                      }\n                    }\n              }\n            }\n            Column(\n                modifier = Modifier.padding(top = 16.dp),\n                horizontalAlignment = Alignment.CenterHorizontally) {\n                  Text(\n                      text = endsLabel, // \"Ending\"\n                      style = typography.titleSmall,\n                      modifier = Modifier.padding(horizontal = 8.dp),\n                      textAlign = TextAlign.Center)\n                  // --- Чипы для выбора типа окончания (NEVER, DATE, COUNT) ---\n                  Row(\n                      modifier =\n                          Modifier.fillMaxWidth()\n                              .padding(horizontal = 8.dp)\n                              .horizontalScroll(rememberScrollState()),\n                      horizontalArrangement =\n                          Arrangement.spacedBy(8.dp, Alignment.CenterHorizontally)) {\n                        // Чип \"Never\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.NEVER,\n                            onClick = {\n                              // Устанавливаем тип, сбрасываем дату и количество\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.NEVER,\n                                      recurrenceEndDate = null,\n                                      recurrenceCount = null))\n                            },\n                            label = { Text(endNeverLabel) },\n                            enabled = !isLoading)\n                        // Чип \"On date\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.DATE,\n                            onClick = {\n                              val defaultEndDate =\n                                  state.recurrenceEndDate\n                                      ?: state.startDate.plusMonths(1) // Пример: через месяц\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.DATE,\n                                      recurrenceEndDate = defaultEndDate,\n                                      recurrenceCount = null))\n                              // Запрашиваем показ пикера, если дата была null\n                              if (state.recurrenceEndDate == null) {\n                                onRequestShowRecurrenceEndDatePicker()\n                              }\n                            },\n                            label = { Text(endDateLabel) },\n                            enabled = !isLoading)\n                        // Чип \"After...\"\n                        FilterChip(\n                            selected = state.recurrenceEndType == RecurrenceEndType.COUNT,\n                            onClick = {\n                              val defaultCount = state.recurrenceCount ?: 10\n                              onStateChange(\n                                  state.copy(\n                                      recurrenceEndType = RecurrenceEndType.COUNT,\n                                      recurrenceEndDate = null,\n                                      recurrenceCount = defaultCount))\n                            },\n                            label = { Text(endCountLabel) },\n                            enabled = !isLoading)\n                      }\n\n                  // --- Поле для выбора даты окончания (UNTIL) ---\n                  AnimatedVisibility(\n                      visible = state.recurrenceEndType == RecurrenceEndType.DATE,\n                      modifier = Modifier.padding(top = 8.dp)) {\n                        DatePickerField(\n                            // \"End Date\"\n                            date = state.recurrenceEndDate,\n                            dateFormatter = deviceDateFormatter,\n                            isLoading = isLoading,\n                            onClick = onRequestShowRecurrenceEndDatePicker, // Открываем пикер\n                            modifier = Modifier.fillMaxWidth().padding(horizontal = 50.dp))\n                      }\n\n                  // --- Поле для ввода количества (COUNT) ---\n                  AnimatedVisibility(\n                      visible = state.recurrenceEndType == RecurrenceEndType.COUNT,\n                      modifier = Modifier.padding(top = 8.dp)) {\n                        OutlinedTextField(\n                            value = state.recurrenceCount?.toString() ?: \"\",\n                            onValueChange = { text ->\n                              val count =\n                                  text.filter { it.isDigit() }.toIntOrNull()?.coerceAtLeast(1)\n                              onStateChange(state.copy(recurrenceCount = count))\n                            },\n                            label = { Text(recurrenceCountFieldLabel) }, // \"Number of times\"\n                            keyboardOptions =\n                                KeyboardOptions(\n                                    keyboardType = KeyboardType.Number, imeAction = ImeAction.Done),\n                            singleLine = true,\n                            modifier = Modifier.fillMaxWidth().padding(horizontal = 50.dp),\n                            shape = RoundedCornerShape(cuid.ContainerCornerRadius),\n                            enabled = !isLoading,\n                            isError = state.recurrenceCount == null // Ошибка, если пусто\n                            )\n                      }\n                } // --- КОНЕЦ СЕКЦИИ ОКОНЧАНИЯ ---\n          }\n        } // End AnimatedVisibility for Recurrence\n  } // End Outer Column\n}\n\n// --- Вспомогательные Composable для полей ---\n@Composable\nprivate fun FilterChipForOption(\n    option: RecurrenceOption,\n    currentSelection: RecurrenceOption,\n    isLoading: Boolean,\n    state: EventDateTimeState,\n    onStateChange: (EventDateTimeState) -> Unit\n) {\n  FilterChip(\n      selected = (option == currentSelection),\n      onClick = {\n        onStateChange(\n            state.copy(\n                recurrenceRule = option.rruleValue,\n                isRecurring = (option != RecurrenceOption.None)))\n      },\n      label = { Text(stringResource(option.labelResId)) },\n      enabled = !isLoading,\n      leadingIcon =\n          if (option == currentSelection) {\n            null\n          } else null)\n}\n\nsealed class RecurrenceOption(@StringRes val labelResId: Int, val rruleValue: String?) {\n  data object None : RecurrenceOption(R.string.recurrence_none, null)\n\n  data object Daily : RecurrenceOption(R.string.recurrence_daily, \"FREQ=DAILY\")\n\n  data object Weekly : RecurrenceOption(R.string.recurrence_weekly, \"FREQ=WEEKLY\")\n\n  data object Monthly : RecurrenceOption(R.string.recurrence_monthly, \"FREQ=MONTHLY\")\n\n  data object Yearly : RecurrenceOption(R.string.recurrence_yearly, \"FREQ=YEARLY\")\n\n  companion object {\n    val ALL_OPTIONS: List<RecurrenceOption> = listOf(None, Daily, Weekly, Monthly, Yearly)\n\n    fun fromRule(rule: String?): RecurrenceOption {\n      return when (rule) {\n        Daily.rruleValue -> Daily\n        Weekly.rruleValue -> Weekly\n        Monthly.rruleValue -> Monthly\n        Yearly.rruleValue -> Yearly\n        else -> None\n      }\n    }\n  }\n}\n",
      "info": {
        "size": 30731,
        "last_modified": "2025-08-06T08:35:04.191196",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/sections/NameSection.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections\n\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.event_management.ui.shared.ChipsRow\nimport com.lpavs.caliinda.feature.event_management.ui.shared.CustomOutlinedTextField\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\n\ndata class SugNameChips(val key: String, val name: String, val fullText: String)\n\n@Composable\nfun EventNameSection(\n    summary: String,\n    summaryError: String?,\n    onSummaryChange: (String) -> Unit,\n    onSummaryErrorChange: (String?) -> Unit,\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    isLoading: Boolean,\n    suggestedChips: List<SugNameChips>\n) {\n  CustomOutlinedTextField(\n      value = summary,\n      onValueChange = {\n        onSummaryChange(it)\n        onSummaryErrorChange(null)\n      },\n      label = stringResource(R.string.event_name),\n      modifier = Modifier.fillMaxWidth(),\n      isError = summaryError != null,\n      supportingText = { if (summaryError != null) Text(summaryError) },\n      enabled = !isLoading,\n  )\n\n  val lazyListState = rememberLazyListState()\n  LaunchedEffect(suggestedChips) { lazyListState.animateScrollToItem(index = 0) }\n  ChipsRow(\n      chips = suggestedChips,\n      onChipClick = { chip ->\n        onSummaryChange(chip.fullText)\n        suggestionsViewModel.onChipClicked(chip)\n      },\n      enabled = !isLoading,\n      lazyListState = lazyListState)\n}\n",
      "info": {
        "size": 1869,
        "last_modified": "2025-08-06T08:35:04.193979",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/sections/suggestions/SuggestionsViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport android.app.Application\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.core.data.repository.SuggestionsRepository\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\nimport java.time.LocalTime\nimport javax.inject.Inject\n\n@HiltViewModel\nclass SuggestionsViewModel\n@Inject\nconstructor(\n    private val suggestionsRepository: SuggestionsRepository,\n    private val application: Application\n) : ViewModel() {\n  private val _suggestionChips = MutableStateFlow<List<SugNameChips>>(emptyList())\n  val suggestionChips: StateFlow<List<SugNameChips>> = _suggestionChips.asStateFlow()\n\n  private val _timeContext = MutableStateFlow(LocalTime.now())\n\n  init {\n    viewModelScope.launch { _timeContext.collect { time -> loadAndSortSuggestions(time) } }\n  }\n\n  fun updateSortContext(startTime: LocalTime?, isAllDay: Boolean) {\n    if (!isAllDay) {\n      _timeContext.value = startTime\n    } else {\n      _timeContext.value = LocalTime.now()\n    }\n  }\n\n  fun onChipClicked(chip: SugNameChips) {\n    viewModelScope.launch {\n      suggestionsRepository.incrementWeight(chip.key)\n      loadAndSortSuggestions(_timeContext.value)\n    }\n  }\n\n  private fun loadAndSortSuggestions(currentTime: LocalTime) {\n    viewModelScope.launch {\n      val weights = suggestionsRepository.getWeights()\n      val baseChips = getSuggestedEventNames(application.applicationContext)\n      val sortedChips =\n          baseChips.sortedByDescending { chip ->\n            val clickWeight = weights[chip.key] ?: 0\n            val timeBonus = getTimeBasedBonus(chip.key, currentTime)\n            clickWeight + timeBonus\n          }\n      _suggestionChips.value = sortedChips\n    }\n  }\n}\n",
      "info": {
        "size": 2037,
        "last_modified": "2025-08-06T08:35:04.195607",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/sections/suggestions/getTimeBonus.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport java.time.LocalTime\n\nfun getTimeBasedBonus(chipKey: String, time: LocalTime): Int {\n  val priority1Bonus = 100\n  val priority2Bonus = 75\n  val hour = time.hour\n  val key = chipKey\n\n  // Приоритет 1 по времени\n  val morningP1 = setOf(\"breakfast\", \"gym\")\n  val dayP1 = setOf(\"work\", \"meeting\")\n  val eveningP1 = setOf(\"dinner\", \"relax\")\n  val nightP1 = setOf(\"sleep\", \"relax\")\n\n  // Приоритет 2 по времени\n  val morningP2 = setOf(\"walking\", \"doctor\", \"pet\", \"reading\", \"cooking\")\n  val dayP2 =\n      setOf(\n          \"lunch\", \"call\", \"errand\", \"appointment\", \"project\", \"presentation\", \"study\", \"shopping\")\n  val eveningP2 =\n      setOf(\n          \"relax\",\n          \"movie\",\n          \"date\",\n          \"party\",\n          \"cooking\",\n          \"walking\",\n          \"hobby\",\n          \"gym\",\n          \"reading\",\n          \"pet\",\n          \"call\")\n  val nightP2 = setOf(\"reading\", \"movie\", \"party\", \"date\", \"pet\", \"cleaning\", \"hobby\")\n\n  return when {\n    // Приоритет 1 – проверяется первым\n    key in morningP1 && hour in 5..10 -> priority1Bonus\n    key in dayP1 && hour in 9..17 -> priority1Bonus\n    key in eveningP1 && hour in 18..22 -> priority1Bonus\n    key in nightP1 && (hour in 22..23 || hour in 0..1) -> priority1Bonus\n\n    // Приоритет 2 – проверяется только если не сработал приоритет 1\n    key in morningP2 && hour in 6..11 -> priority2Bonus\n    key in dayP2 && hour in 11..17 -> priority2Bonus\n    key in eveningP2 && hour in 17..23 -> priority2Bonus\n    key in nightP2 && (hour in 22..23 || hour in 0..3) -> priority2Bonus\n\n    else -> 0\n  }\n}\n",
      "info": {
        "size": 1763,
        "last_modified": "2025-08-06T08:35:04.19923",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/sections/suggestions/getSuggestedEventNames.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions\n\nimport android.content.Context\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\n\nfun getSuggestedEventNames(context: Context): List<SugNameChips> {\n  return listOf(\n      SugNameChips(\n          key = \"project\",\n          context.getString(R.string.suggested_event_project),\n          context.getString(R.string.suggested_event_project_full)),\n      SugNameChips(\n          key = \"work\",\n          context.getString(R.string.suggested_event_work),\n          context.getString(R.string.suggested_event_work_full)),\n      SugNameChips(\n          key = \"dinner\",\n          context.getString(R.string.suggested_event_dinner),\n          context.getString(R.string.suggested_event_dinner_full)),\n      SugNameChips(\n          key = \"meeting\",\n          context.getString(R.string.suggested_event_meeting),\n          context.getString(R.string.suggested_event_meeting_full)),\n      SugNameChips(\n          key = \"coffee\",\n          context.getString(R.string.suggested_event_coffee),\n          context.getString(R.string.suggested_event_coffee_full)),\n      SugNameChips(\n          key = \"lunch\",\n          context.getString(R.string.suggested_event_lunch),\n          context.getString(R.string.suggested_event_lunch_full)),\n      SugNameChips(\n          key = \"shopping\",\n          context.getString(R.string.suggested_event_shopping),\n          context.getString(R.string.suggested_event_shopping_full)),\n      SugNameChips(\n          key = \"appointment\",\n          context.getString(R.string.suggested_event_appointment),\n          context.getString(R.string.suggested_event_appointment_full)),\n      SugNameChips(\n          key = \"travel\",\n          context.getString(R.string.suggested_event_travel),\n          context.getString(R.string.suggested_event_travel_full)),\n      SugNameChips(\n          key = \"party\",\n          context.getString(R.string.suggested_event_party),\n          context.getString(R.string.suggested_event_party_full)),\n      SugNameChips(\n          key = \"movie\",\n          context.getString(R.string.suggested_event_movie),\n          context.getString(R.string.suggested_event_movie_full)),\n      SugNameChips(\n          key = \"study\",\n          context.getString(R.string.suggested_event_study),\n          context.getString(R.string.suggested_event_study_full)),\n      SugNameChips(\n          key = \"gym\",\n          context.getString(R.string.suggested_event_gym),\n          context.getString(R.string.suggested_event_gym_full)),\n      SugNameChips(\n          key = \"relax\",\n          context.getString(R.string.suggested_event_relax),\n          context.getString(R.string.suggested_event_relax_full)),\n      SugNameChips(\n          key = \"reading\",\n          context.getString(R.string.suggested_event_reading),\n          context.getString(R.string.suggested_event_reading_full)),\n      SugNameChips(\n          key = \"cleaning\",\n          context.getString(R.string.suggested_event_cleaning),\n          context.getString(R.string.suggested_event_cleaning_full)),\n      SugNameChips(\n          key = \"cooking\",\n          context.getString(R.string.suggested_event_cooking),\n          context.getString(R.string.suggested_event_cooking_full)),\n      SugNameChips(\n          key = \"walking\",\n          context.getString(R.string.suggested_event_walking),\n          context.getString(R.string.suggested_event_walking_full)),\n      SugNameChips(\n          key = \"hobby\",\n          context.getString(R.string.suggested_event_hobby),\n          context.getString(R.string.suggested_event_hobby_full)),\n      SugNameChips(\n          key = \"date\",\n          context.getString(R.string.suggested_event_date),\n          context.getString(R.string.suggested_event_date_full)),\n      SugNameChips(\n          key = \"doctor\",\n          context.getString(R.string.suggested_event_doctor),\n          context.getString(R.string.suggested_event_doctor_full)),\n      SugNameChips(\n          key = \"birthday\",\n          context.getString(R.string.suggested_event_birthday),\n          context.getString(R.string.suggested_event_birthday_full)),\n      SugNameChips(\n          key = \"presentation\",\n          context.getString(R.string.suggested_event_presentation),\n          context.getString(R.string.suggested_event_presentation_full)),\n      SugNameChips(\n          key = \"call\",\n          context.getString(R.string.suggested_event_call),\n          context.getString(R.string.suggested_event_call_full)),\n      SugNameChips(\n          key = \"errand\",\n          context.getString(R.string.suggested_event_errand),\n          context.getString(R.string.suggested_event_errand_full)),\n      SugNameChips(\n          key = \"sleep\",\n          context.getString(R.string.suggested_event_sleep),\n          context.getString(R.string.suggested_event_sleep_full)),\n      SugNameChips(\n          key = \"breakfast\",\n          context.getString(R.string.suggested_event_breakfast),\n          context.getString(R.string.suggested_event_breakfast_full)),\n      SugNameChips(\n          key = \"pet\",\n          context.getString(R.string.suggested_event_pet),\n          context.getString(R.string.suggested_event_pet_full)))\n}\n",
      "info": {
        "size": 5259,
        "last_modified": "2025-08-06T08:35:04.20219",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/InteractiveFields.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.interaction.MutableInteractionSource\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.PaddingValues\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.OutlinedTextFieldDefaults\nimport androidx.compose.material3.SuggestionChip\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.hapticfeedback.HapticFeedbackType\nimport androidx.compose.ui.platform.LocalHapticFeedback\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.core.ui.theme.cuid\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.SugNameChips\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.format.DateTimeFormatter\n\n@Composable\nfun CustomOutlinedTextField(\n    value: String,\n    onValueChange: (String) -> Unit,\n    label: String,\n    modifier: Modifier = Modifier,\n    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,\n    enabled: Boolean = true,\n    isError: Boolean = false,\n    supportingText: (@Composable () -> Unit)? = null\n) {\n  OutlinedTextField(\n      value = value,\n      onValueChange = onValueChange,\n      label = { Text(text = label, textAlign = TextAlign.Center) },\n      modifier = modifier.fillMaxWidth().padding(horizontal = 8.dp),\n      shape = RoundedCornerShape(cuid.ContainerCornerRadius),\n      colors =\n          OutlinedTextFieldDefaults.colors(\n              focusedContainerColor = colorScheme.surfaceContainerLow,\n              unfocusedContainerColor = colorScheme.surfaceContainerLow,\n          ),\n      keyboardOptions = keyboardOptions,\n      textStyle = typography.headlineMedium.copy(textAlign = TextAlign.Center),\n      enabled = enabled,\n      singleLine = true,\n      isError = isError,\n      supportingText = supportingText)\n}\n\n@Composable\nfun ChipsRow(\n    chips: List<SugNameChips>,\n    onChipClick: (SugNameChips) -> Unit,\n    enabled: Boolean,\n    lazyListState: LazyListState\n) {\n  LazyRow(\n      state = lazyListState,\n      modifier = Modifier.fillMaxWidth().padding(horizontal = cuid.padding),\n      horizontalArrangement = Arrangement.spacedBy(cuid.padding),\n      contentPadding = PaddingValues(cuid.padding)) {\n        items(chips, key = { it.name }) { chip ->\n          SuggestionChip(\n              onClick = { onChipClick(chip) },\n              label = { Text(chip.name) },\n              modifier = Modifier.height(35.dp),\n              enabled = enabled)\n        }\n      }\n}\n\n@Composable\ninternal fun DatePickerField(\n    date: LocalDate?,\n    dateFormatter: DateTimeFormatter,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n) {\n  ModernClickableTextField(\n      value = date?.format(dateFormatter) ?: \"\",\n      isLoading = isLoading,\n      onClick = onClick,\n      modifier = modifier)\n}\n\n@Composable\ninternal fun TimePickerField(\n    time: LocalTime?,\n    timeFormatter: DateTimeFormatter,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n    onLongClick: (() -> Unit)? = null,\n) {\n  ModernClickableTextField(\n      value = time?.format(timeFormatter) ?: \"--:--\",\n      isLoading = isLoading,\n      onClick = onClick,\n      onLongClick = onLongClick,\n      modifier = modifier)\n}\n\n@Composable\nprivate fun ModernClickableTextField(\n    value: String,\n    isLoading: Boolean,\n    onClick: () -> Unit,\n    modifier: Modifier = Modifier,\n    onLongClick: (() -> Unit)? = null,\n) {\n  val haptics = LocalHapticFeedback.current\n  Box(\n      modifier =\n          modifier\n              .height(45.dp)\n              .clip(shape = RoundedCornerShape(cuid.ContainerCornerRadius))\n              .background(colorScheme.secondaryContainer)) {\n        Row(\n            modifier =\n                Modifier.fillMaxSize()\n                    .combinedClickable(\n                        enabled = !isLoading,\n                        onClick = onClick,\n                        onLongClick = {\n                          haptics.performHapticFeedback(HapticFeedbackType.LongPress)\n                          onLongClick?.invoke()\n                        },\n                        indication = null,\n                        interactionSource = remember { MutableInteractionSource() }),\n            horizontalArrangement = Arrangement.Center,\n            verticalAlignment = Alignment.CenterVertically) {\n              Text(text = value, color = colorScheme.onSecondaryContainer)\n            }\n      }\n}\n",
      "info": {
        "size": 5551,
        "last_modified": "2025-08-06T08:35:04.208201",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/shared/GeneralElements.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.shared\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.width\nimport androidx.compose.foundation.layout.widthIn\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.foundation.selection.selectable\nimport androidx.compose.foundation.selection.selectableGroup\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.AlertDialog\nimport androidx.compose.material3.BasicAlertDialog\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.LocalContentColor\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.shapes\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.NavigationBarDefaults.Elevation\nimport androidx.compose.material3.RadioButton\nimport androidx.compose.material3.RadioButtonDefaults\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.semantics.Role\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.window.DialogProperties\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.ui.theme.cuid\n\n/**\n * Content [AdaptiveContainer] - container for any content. [TimePickerDialog] - timepicker\n * [DeleteConfirmationDialog] - delete confirmation dialog\n */\n@Composable\nfun AdaptiveContainer(modifier: Modifier = Modifier, content: @Composable ColumnScope.() -> Unit) {\n  val cornerRadius = cuid.SettingsItemCornerRadius\n  Column(\n      modifier =\n          Modifier.fillMaxWidth()\n              .clip(RoundedCornerShape(cornerRadius))\n              .background(color = colorScheme.surfaceContainer)\n              .padding(cuid.ContainerPadding)\n              .then(modifier),\n      horizontalAlignment = Alignment.CenterHorizontally,\n      verticalArrangement = Arrangement.Center,\n      content = content)\n}\n\n@Composable\nfun TimePickerDialog(\n    title: String = stringResource(R.string.pick_time),\n    onDismissRequest: () -> Unit,\n    confirmButton: @Composable (() -> Unit),\n    dismissButton: @Composable (() -> Unit)? = null,\n    content: @Composable () -> Unit,\n) {\n  AlertDialog(\n      onDismissRequest = onDismissRequest,\n      title = { Text(title) },\n      text = {\n        Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) { content() }\n      },\n      confirmButton = confirmButton,\n      dismissButton = dismissButton)\n}\n\n@Composable\nfun DeleteConfirmationDialog(onConfirm: () -> Unit, onDismiss: () -> Unit) {\n  AlertDialog(\n      onDismissRequest = onDismiss,\n      title = { Text(text = stringResource(R.string.delete_conf)) },\n      text = { Text(text = stringResource(R.string.delete_confirmation_message)) },\n      confirmButton = {\n        Button(\n            onClick = { onConfirm() },\n            colors =\n                ButtonDefaults.buttonColors(\n                    containerColor = colorScheme.primary, contentColor = colorScheme.onPrimary)) {\n              Text(text = stringResource(R.string.delete))\n            }\n      },\n      dismissButton = {\n        TextButton(onClick = onDismiss) { Text(text = stringResource(R.string.cancel)) }\n      })\n}\n\nenum class RecurringDeleteChoice {\n  SINGLE_INSTANCE,\n  THIS_AND_FOLLOWING,\n  ALL_IN_SERIES\n}\n\n@Composable\nfun RecurringEventDeleteOptionsDialog(\n    eventName: String,\n    onDismiss: () -> Unit,\n    onOptionSelected: (RecurringDeleteChoice) -> Unit\n) {\n  var selectedOption by remember { mutableStateOf(RecurringDeleteChoice.SINGLE_INSTANCE) }\n  val radioOptions =\n      listOf(\n          RecurringDeleteChoice.SINGLE_INSTANCE to stringResource(R.string.delete_single_instance),\n          RecurringDeleteChoice.ALL_IN_SERIES to stringResource(R.string.delete_all_in_series),\n          RecurringDeleteChoice.THIS_AND_FOLLOWING to\n              stringResource(R.string.delete_this_and_following))\n\n  AlertDialog(\n      onDismissRequest = onDismiss,\n      title = { Text(text = stringResource(R.string.delete_recurring_event_title)) },\n      text = {\n        Column(modifier = Modifier.selectableGroup()) {\n          Text(\n              text = stringResource(R.string.delete_recurring_event_prompt, eventName),\n              style = typography.bodyMedium,\n              modifier = Modifier.padding(bottom = 16.dp))\n\n          radioOptions.forEach { (option, label) ->\n            Row(\n                Modifier.fillMaxWidth()\n                    .selectable(\n                        selected = (option == selectedOption),\n                        onClick = { selectedOption = option },\n                        role = Role.RadioButton)\n                    .padding(vertical = 8.dp),\n                verticalAlignment = Alignment.CenterVertically) {\n                  RadioButton(\n                      selected = (option == selectedOption),\n                      onClick = null,\n                      colors =\n                          RadioButtonDefaults.colors(\n                              selectedColor =\n                                  when (option) {\n                                    RecurringDeleteChoice.ALL_IN_SERIES -> {\n                                      if (selectedOption == option) colorScheme.error\n                                      else colorScheme.primary\n                                    }\n                                    RecurringDeleteChoice.THIS_AND_FOLLOWING -> {\n                                      if (selectedOption == option) colorScheme.tertiary\n                                      else colorScheme.primary\n                                    }\n                                    else -> colorScheme.primary\n                                  }))\n                  Spacer(Modifier.width(8.dp))\n                  Text(\n                      text = label,\n                      style = typography.bodyLarge,\n                      color =\n                          when (option) {\n                            RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.error\n                            else -> LocalContentColor.current\n                          })\n                }\n          }\n        }\n      },\n      confirmButton = {\n        Button(\n            onClick = {\n              onOptionSelected(selectedOption)\n              onDismiss()\n            },\n            colors =\n                ButtonDefaults.buttonColors(\n                    containerColor =\n                        when (selectedOption) {\n                          RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.error\n                          RecurringDeleteChoice.THIS_AND_FOLLOWING -> colorScheme.tertiary\n                          else -> colorScheme.primary\n                        },\n                    contentColor =\n                        when (selectedOption) {\n                          RecurringDeleteChoice.ALL_IN_SERIES -> colorScheme.onError\n                          RecurringDeleteChoice.THIS_AND_FOLLOWING -> colorScheme.onTertiary\n                          else -> colorScheme.onPrimary\n                        })) {\n              Text(\n                  text =\n                      when (selectedOption) {\n                        RecurringDeleteChoice.THIS_AND_FOLLOWING ->\n                            stringResource(R.string.stop_repeating)\n                        else -> stringResource(R.string.delete)\n                      })\n            }\n      },\n      dismissButton = { TextButton(onClick = onDismiss) { Text(stringResource(R.string.cancel)) } })\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RecurringEventEditOptionsDialog(\n    eventName: String,\n    onDismiss: () -> Unit,\n    onOptionSelected: (EventUpdateMode) -> Unit,\n    modifier: Modifier = Modifier,\n    properties: DialogProperties = DialogProperties()\n) {\n  BasicAlertDialog(\n      onDismissRequest = onDismiss,\n      modifier = modifier.widthIn(min = 280.dp, max = 560.dp),\n      properties = properties,\n  ) {\n    Surface(\n        shape = shapes.extraLarge,\n        color = colorScheme.surface,\n        tonalElevation = Elevation,\n        modifier = Modifier.wrapContentSize()) {\n          Column(\n              modifier =\n                  Modifier.padding(top = 24.dp, bottom = 24.dp, start = 24.dp, end = 24.dp)) {\n                Text(\n                    text = stringResource(R.string.edit_recurring_event_title),\n                    style = typography.headlineSmall,\n                    modifier = Modifier.padding(bottom = 16.dp))\n\n                Text(\n                    text = stringResource(R.string.edit_recurring_event_prompt, eventName),\n                    style = typography.bodyMedium,\n                    modifier = Modifier.padding(bottom = 24.dp))\n\n                TextButton(\n                    onClick = { onOptionSelected(EventUpdateMode.SINGLE_INSTANCE) },\n                    modifier = Modifier.fillMaxWidth()) {\n                      Text(stringResource(R.string.edit_single_instance))\n                    }\n\n                Spacer(modifier = Modifier.height(8.dp))\n\n                TextButton(\n                    onClick = { onOptionSelected(EventUpdateMode.ALL_IN_SERIES) },\n                    modifier = Modifier.fillMaxWidth()) {\n                      Text(stringResource(R.string.edit_all_in_series))\n                    }\n\n                Spacer(modifier = Modifier.height(24.dp))\n\n                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.End) {\n                  TextButton(onClick = onDismiss) { Text(stringResource(R.string.cancel)) }\n                }\n              }\n        }\n  }\n}\n",
      "info": {
        "size": 10681,
        "last_modified": "2025-08-06T08:35:04.211203",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/edit/EditEventScreen.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.edit\n\nimport android.text.format.DateFormat\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.ExitTransition\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.DatePicker\nimport androidx.compose.material3.DatePickerDialog\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.SelectableDates\nimport androidx.compose.material3.SheetValue\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TimePicker\nimport androidx.compose.material3.rememberDatePickerState\nimport androidx.compose.material3.rememberTimePickerState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils\nimport com.lpavs.caliinda.feature.event_management.ui.shared.AdaptiveContainer\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerDialog\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimePicker\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimeState\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventNameSection\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceEndType\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceOption\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementUiEvent\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport java.time.DayOfWeek\nimport java.time.Instant\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.ZonedDateTime\nimport java.time.format.DateTimeFormatter\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun EditEventScreen(\n    viewModel: EventManagementViewModel,\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    userTimeZone: String,\n    eventToEdit: EventDto,\n    selectedUpdateMode: EventUpdateMode,\n    onDismiss: () -> Unit,\n    currentSheetValue: SheetValue\n) {\n  var summary by remember(eventToEdit.id) { mutableStateOf(eventToEdit.summary) }\n  var description by remember(eventToEdit.id) { mutableStateOf(eventToEdit.description ?: \"\") }\n  var location by remember(eventToEdit.id) { mutableStateOf(eventToEdit.location ?: \"\") }\n\n  var summaryError by remember { mutableStateOf<String?>(null) }\n  var validationError by remember { mutableStateOf<String?>(null) }\n\n  val uiState by viewModel.uiState.collectAsState()\n\n  var generalError by remember { mutableStateOf<String?>(null) }\n  val userTimeZoneId = remember { ZoneId.of(userTimeZone) }\n\n  val context = LocalContext.current\n  val untilFormatter = remember { DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\") }\n\n  val initialEventDateTimeState =\n      remember(eventToEdit.id, userTimeZone) {\n        parseCalendarEventToDateTimeState(eventToEdit, userTimeZone)\n      }\n  var eventDateTimeState by remember(eventToEdit.id) { mutableStateOf(initialEventDateTimeState) }\n  LaunchedEffect(initialEventDateTimeState) {\n    Log.d(\"EditEventScreen\", \"Initial EventDateTimeState for UI: $initialEventDateTimeState\")\n  }\n\n  var showStartDatePicker by remember { mutableStateOf(false) }\n  var showStartTimePicker by remember { mutableStateOf(false) }\n  var showEndDatePicker by remember { mutableStateOf(false) }\n  var showEndTimePicker by remember { mutableStateOf(false) }\n  var showRecurrenceEndDatePicker by remember { mutableStateOf(false) }\n\n  fun formatEventTimesForSaving(\n      state: EventDateTimeState,\n      timeZoneId: String?\n  ): Pair<String?, String?> {\n    return if (state.isAllDay) {\n      val formatter = DateTimeFormatter.ISO_LOCAL_DATE\n      val startDateStr =\n          try {\n            state.startDate.format(formatter)\n          } catch (_: Exception) {\n            null\n          }\n      val effectiveEndDate = state.endDate.plusDays(1)\n      val endDateStr =\n          try {\n            effectiveEndDate.format(formatter)\n          } catch (_: Exception) {\n            null\n          }\n      Log.d(\"CreateEvent\", \"Formatting All-Day: Start Date=$startDateStr, End Date=$endDateStr\")\n      Pair(startDateStr, endDateStr)\n    } else {\n      if (timeZoneId == null) {\n        Log.e(\"CreateEvent\", \"Cannot format timed event without TimeZone ID!\")\n        return Pair(null, null)\n      }\n      val startTimeNaiveIso =\n          DateTimeUtils.formatLocalDateTimeToNaiveIsoString(state.startDate, state.startTime)\n      val endTimeNaiveIso =\n          DateTimeUtils.formatLocalDateTimeToNaiveIsoString(state.endDate, state.endTime)\n      Log.d(\n          \"CreateEvent\",\n          \"Formatting Timed: Start DateTime=$startTimeNaiveIso, End DateTime=$endTimeNaiveIso\")\n      Pair(startTimeNaiveIso, endTimeNaiveIso)\n    }\n  }\n\n  fun validateInput(): Boolean {\n    summaryError =\n        if (summary.isBlank()) R.string.error_summary_cannot_be_empty.toString() else null\n    validationError = null\n    val state = eventDateTimeState\n    if (!state.isAllDay && (state.startTime == null || state.endTime == null)) {\n      validationError = R.string.error_specify_start_and_end_time.toString()\n      return false\n    }\n    val (testStartTimeStr, testEndTimeStr) = formatEventTimesForSaving(state, userTimeZone)\n    if (testStartTimeStr == null || testEndTimeStr == null) {\n      validationError = R.string.error_failed_to_format_datetime.toString()\n      return false\n    }\n    return summaryError == null && validationError == null\n  }\n\n  LaunchedEffect(key1 = true) {\n    viewModel.eventFlow.collect { event ->\n      when (event) {\n        is EventManagementUiEvent.ShowMessage -> {}\n        is EventManagementUiEvent.OperationSuccess -> {\n          onDismiss()\n        }\n      }\n    }\n  }\n  LaunchedEffect(eventDateTimeState.startTime) {\n    suggestionsViewModel.updateSortContext(\n        eventDateTimeState.startTime, eventDateTimeState.isAllDay)\n  }\n  val suggestedChips by suggestionsViewModel.suggestionChips.collectAsStateWithLifecycle()\n\n  val onSaveClick: () -> Unit = saveLambda@{\n    generalError = null\n    if (validateInput()) {\n      val (startStr, endStr) = formatEventTimesForSaving(eventDateTimeState, userTimeZone)\n      if (startStr == null || endStr == null) {\n        return@saveLambda\n      }\n\n      val baseRule = eventDateTimeState.recurrenceRule?.takeIf { it.isNotBlank() }\n      var finalRecurrenceRule: String? = null\n\n      if (baseRule != null) {\n        val ruleParts = mutableListOf(baseRule)\n\n        if (baseRule == RecurrenceOption.Weekly.rruleValue &&\n            eventDateTimeState.selectedWeekdays.isNotEmpty()) {\n          val bydayString =\n              eventDateTimeState.selectedWeekdays.sorted().joinToString(\",\") { day ->\n                when (day) {\n                  DayOfWeek.MONDAY -> \"MO\"\n                  DayOfWeek.TUESDAY -> \"TU\"\n                  DayOfWeek.WEDNESDAY -> \"WE\"\n                  DayOfWeek.THURSDAY -> \"TH\"\n                  DayOfWeek.FRIDAY -> \"FR\"\n                  DayOfWeek.SATURDAY -> \"SA\"\n                  DayOfWeek.SUNDAY -> \"SU\"\n                }\n              }\n          ruleParts.add(\"BYDAY=$bydayString\")\n        }\n\n        when (eventDateTimeState.recurrenceEndType) {\n          RecurrenceEndType.DATE -> {\n            eventDateTimeState.recurrenceEndDate?.let { endDate ->\n              val userTimeZone = userTimeZoneId\n              endDate.atTime(LocalTime.MAX).atZone(userTimeZone)\n\n              val endDateTimeUtc =\n                  endDate\n                      .atTime(23, 59, 59)\n                      .atZone(userTimeZone)\n                      .withZoneSameInstant(ZoneOffset.UTC)\n\n              val untilString = untilFormatter.format(endDateTimeUtc)\n              ruleParts.add(\"UNTIL=$untilString\")\n            }\n          }\n\n          RecurrenceEndType.COUNT -> {\n            eventDateTimeState.recurrenceCount?.let { count -> ruleParts.add(\"COUNT=$count\") }\n          }\n\n          RecurrenceEndType.NEVER -> {}\n        }\n\n        finalRecurrenceRule = ruleParts.joinToString(\";\")\n      }\n\n      val updateRequest =\n          buildUpdateEventApiRequest(\n              originalEvent = eventToEdit,\n              currentSummary = summary.trim(),\n              currentDescription = description.trim(),\n              currentLocation = location.trim(),\n              currentDateTimeState = eventDateTimeState,\n              formattedStartStr = startStr,\n              formattedEndStr = endStr,\n              finalRRuleStringFromUi = finalRecurrenceRule,\n              userTimeZoneIdForTimed = userTimeZone,\n              selectedUpdateMode = selectedUpdateMode)\n\n      if (updateRequest == null) {\n        Toast.makeText(context, R.string.no_changes_to_save, Toast.LENGTH_SHORT).show()\n        onDismiss()\n        return@saveLambda\n      }\n\n      viewModel.confirmEventUpdate(\n          updatedEventData = updateRequest, modeFromUi = selectedUpdateMode)\n    } else {\n      Toast.makeText(context, R.string.error_check_input_data, Toast.LENGTH_SHORT).show()\n    }\n  }\n\n  Row(\n      modifier = Modifier.fillMaxWidth().padding(horizontal = 4.dp, vertical = 0.dp),\n      verticalAlignment = Alignment.CenterVertically,\n      horizontalArrangement = Arrangement.Center) {\n        AnimatedContent(\n            targetState = currentSheetValue,\n            transitionSpec = {\n              (EnterTransition.None)\n                  .togetherWith(ExitTransition.None)\n                  .using(\n                      SizeTransform(\n                          clip = false,\n                          sizeAnimationSpec = { _, _ ->\n                            spring(\n                                dampingRatio = Spring.DampingRatioLowBouncy,\n                                stiffness = Spring.StiffnessMediumLow)\n                          }))\n            },\n            label = \"SaveButtonAnimation\") { targetSheetValue\n              -> // TODO исправить чтобы выключалась на загрузке\n              val expandedSize = ButtonDefaults.LargeContainerHeight\n              val defaultSize = ButtonDefaults.MediumContainerHeight\n\n              val isNotCompactState = targetSheetValue == SheetValue.Expanded\n\n              val size = if (!isNotCompactState) defaultSize else expandedSize\n\n              Button(\n                  onClick = onSaveClick,\n                  enabled = !uiState.isLoading,\n                  modifier = Modifier.heightIn(size),\n                  contentPadding = ButtonDefaults.contentPaddingFor(size)) {\n                    if (uiState.isLoading) {\n                      LoadingIndicator(\n                          color = colorScheme.onPrimary,\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    } else {\n                      Icon(\n                          imageVector = Icons.Filled.Check,\n                          contentDescription = stringResource(R.string.save),\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    }\n                  }\n            }\n      }\n  Column(\n      modifier =\n          Modifier.verticalScroll(rememberScrollState()).padding(horizontal = 16.dp).fillMaxWidth(),\n  ) {\n    AdaptiveContainer {\n      EventNameSection(\n          summary = summary,\n          summaryError = summaryError,\n          onSummaryChange = { summary = it },\n          onSummaryErrorChange = { summaryError = it },\n          isLoading = uiState.isLoading,\n          suggestedChips = suggestedChips)\n    }\n    AdaptiveContainer {\n      EventDateTimePicker(\n          state = eventDateTimeState,\n          onStateChange = { newState ->\n            eventDateTimeState = newState\n            validationError = null\n          },\n          isLoading = uiState.isLoading,\n          onRequestShowStartDatePicker = { showStartDatePicker = true },\n          onRequestShowStartTimePicker = { showStartTimePicker = true },\n          onRequestShowEndDatePicker = { showEndDatePicker = true },\n          onRequestShowEndTimePicker = { showEndTimePicker = true },\n          onRequestShowRecurrenceEndDatePicker = { showRecurrenceEndDatePicker = true },\n          modifier = Modifier.fillMaxWidth())\n    }\n    validationError?.let { Text(it, color = colorScheme.error, style = typography.bodySmall) }\n\n    AdaptiveContainer {\n      OutlinedTextField(\n          value = description,\n          onValueChange = { description = it },\n          label = { Text(stringResource(R.string.description)) },\n          modifier = Modifier.fillMaxWidth().height(100.dp),\n          maxLines = 4,\n          enabled = !uiState.isLoading,\n          shape = RoundedCornerShape(25.dp))\n      OutlinedTextField(\n          value = location,\n          onValueChange = { location = it },\n          label = { Text(stringResource(R.string.location)) },\n          modifier = Modifier.fillMaxWidth(),\n          singleLine = true,\n          enabled = !uiState.isLoading,\n          shape = RoundedCornerShape(25.dp))\n    }\n    generalError?.let { Text(it, color = colorScheme.error, style = typography.bodyMedium) }\n    Spacer(modifier = Modifier.height(16.dp))\n  }\n\n  val currentDateTimeState = eventDateTimeState\n\n  if (showStartDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.startDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli())\n    DatePickerDialog(\n        onDismissRequest = { showStartDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      currentDateTimeState.copy(\n                          startDate = selectedDate,\n                          endDate =\n                              if (selectedDate.isAfter(currentDateTimeState.endDate) ||\n                                  currentDateTimeState.startTime == null)\n                                  selectedDate\n                              else currentDateTimeState.endDate)\n                }\n                showStartDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n  if (showStartTimePicker) {\n    val initialTime = currentDateTimeState.startTime ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showStartTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                var newEndTime = currentDateTimeState.endTime\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.endTime != null &&\n                    !selectedTime.isBefore(currentDateTimeState.endTime)) {\n                  newEndTime = selectedTime.plusHours(1).withNano(0)\n                }\n                eventDateTimeState =\n                    currentDateTimeState.copy(startTime = selectedTime, endTime = newEndTime)\n                showStartTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n\n  if (showEndDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.endDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli(),\n            selectableDates =\n                object : SelectableDates {\n                  val startMillis =\n                      currentDateTimeState.startDate\n                          .atStartOfDay(userTimeZoneId)\n                          .toInstant()\n                          .toEpochMilli()\n\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    return utcTimeMillis >= startMillis\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= currentDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState = currentDateTimeState.copy(endDate = selectedDate)\n                }\n                showEndDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n\n  if (showEndTimePicker) {\n    val initialTime =\n        currentDateTimeState.endTime\n            ?: currentDateTimeState.startTime?.plusHours(1)\n            ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showEndTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.startTime != null &&\n                    !currentDateTimeState.startTime.isBefore(selectedTime)) {\n                  Toast.makeText(\n                          context, R.string.error_end_time_not_after_start, Toast.LENGTH_SHORT)\n                      .show()\n                } else {\n                  eventDateTimeState = currentDateTimeState.copy(endTime = selectedTime)\n                  showEndTimePicker = false\n                }\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n  if (showRecurrenceEndDatePicker) {\n    val initialSelectedDateMillis =\n        eventDateTimeState.recurrenceEndDate\n            ?.atStartOfDay(userTimeZoneId)\n            ?.toInstant()\n            ?.toEpochMilli()\n            ?: eventDateTimeState.startDate\n                .plusMonths(1)\n                .atStartOfDay(userTimeZoneId)\n                .toInstant()\n                .toEpochMilli()\n\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis = initialSelectedDateMillis,\n            selectableDates =\n                object : SelectableDates {\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    val selectedLocalDate =\n                        Instant.ofEpochMilli(utcTimeMillis).atZone(userTimeZoneId).toLocalDate()\n                    return !selectedLocalDate.isBefore(eventDateTimeState.startDate)\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= eventDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showRecurrenceEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      eventDateTimeState.copy(\n                          recurrenceEndDate = selectedDate,\n                          recurrenceEndType = RecurrenceEndType.DATE,\n                          recurrenceCount = null)\n                }\n                showRecurrenceEndDatePicker = false\n              },\n          ) {\n            Text(\"OK\")\n          }\n        },\n        dismissButton = {\n          TextButton(onClick = { showRecurrenceEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n}\n\n// TODO\nfun parseCalendarEventToDateTimeState(\n    event: EventDto,\n    userTimeZoneId: String,\n): EventDateTimeState {\n  val isAllDay = event.isAllDay\n\n  var parsedStartDate: LocalDate = LocalDate.now()\n  var parsedStartTime: LocalTime? = null\n  var parsedEndDate: LocalDate = LocalDate.now()\n  var parsedEndTime: LocalTime? = null\n\n  try {\n    if (isAllDay) {\n      parsedStartDate = LocalDate.parse(event.startTime, DateTimeFormatter.ISO_LOCAL_DATE)\n      parsedEndDate = LocalDate.parse(event.endTime, DateTimeFormatter.ISO_LOCAL_DATE).minusDays(1)\n    } else {\n\n      val startInstant = DateTimeUtils.parseToInstant(event.startTime, userTimeZoneId)\n      val endInstant = DateTimeUtils.parseToInstant(event.endTime, userTimeZoneId)\n\n      if (startInstant != null) {\n        val startZonedDateTime = startInstant.atZone(ZoneId.of(userTimeZoneId))\n        parsedStartDate = startZonedDateTime.toLocalDate()\n        parsedStartTime = startZonedDateTime.toLocalTime().withNano(0)\n      }\n      if (endInstant != null) {\n        val endZonedDateTime = endInstant.atZone(ZoneId.of(userTimeZoneId))\n        parsedEndDate = endZonedDateTime.toLocalDate()\n        parsedEndTime = endZonedDateTime.toLocalTime().withNano(0)\n      }\n    }\n  } catch (e: Exception) {\n    Log.e(\"ParseToState\", \"Error parsing event date/time for editing: ${e.message}\")\n    val now = ZonedDateTime.now(ZoneId.of(userTimeZoneId))\n    parsedStartDate = now.toLocalDate()\n    parsedStartTime = if (!isAllDay) now.toLocalTime().plusHours(1).withMinute(0) else null\n    parsedEndDate = parsedStartDate\n    parsedEndTime = if (!isAllDay) parsedStartTime?.plusHours(1) else null\n  }\n\n  var recurrenceOption: RecurrenceOption? = null\n  var selectedWeekdays: Set<DayOfWeek> = emptySet()\n  var recurrenceEndType = RecurrenceEndType.NEVER\n  var recurrenceEndDate: LocalDate? = null\n  var recurrenceCount: Int? = null\n  var isRecurring = false\n\n  event.recurrenceRule?.let { rruleString ->\n    isRecurring = true\n    val rules = rruleString.split(';')\n    rules.forEach { rulePart ->\n      val parts = rulePart.split('=')\n      if (parts.size == 2) {\n        val key = parts[0]\n        val value = parts[1]\n        when (key) {\n          \"FREQ\" -> {\n            recurrenceOption = RecurrenceOption.ALL_OPTIONS.find { it.rruleValue == \"FREQ=$value\" }\n          }\n          \"BYDAY\" -> {\n            selectedWeekdays =\n                value\n                    .split(',')\n                    .mapNotNull { dayStr ->\n                      when (dayStr) {\n                        \"MO\" -> DayOfWeek.MONDAY\n                        \"TU\" -> DayOfWeek.TUESDAY\n                        \"WE\" -> DayOfWeek.WEDNESDAY\n                        \"TH\" -> DayOfWeek.THURSDAY\n                        \"FR\" -> DayOfWeek.FRIDAY\n                        \"SA\" -> DayOfWeek.SATURDAY\n                        \"SU\" -> DayOfWeek.SUNDAY\n                        else -> null\n                      }\n                    }\n                    .toSet()\n          }\n          \"UNTIL\" -> {\n            try {\n              val zonedDateTime =\n                  ZonedDateTime.parse(\n                      value,\n                      DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\").withZone(ZoneOffset.UTC))\n              recurrenceEndDate =\n                  zonedDateTime.withZoneSameInstant(ZoneId.of(userTimeZoneId)).toLocalDate()\n              recurrenceEndType = RecurrenceEndType.DATE\n            } catch (e: Exception) {\n              Log.e(\"ParseToState\", \"Error parsing UNTIL value: $value - ${e.message}\")\n            }\n          }\n          \"COUNT\" -> {\n            recurrenceCount = value.toIntOrNull()\n            if (recurrenceCount != null) recurrenceEndType = RecurrenceEndType.COUNT\n          }\n        }\n      }\n    }\n    if (recurrenceOption == null) {\n      Log.w(\"ParseToState\", \"Could not map FREQ from RRULE: $rruleString to known RecurrenceOption\")\n    }\n  }\n\n  Log.d(\"ParseToState\", \"--- Parsing Event to EventDateTimeState ---\")\n  Log.d(\"ParseToState\", \"Original Event ID: ${event.id}\")\n  Log.d(\"ParseToState\", \"Original Event Summary: ${event.summary}\")\n  Log.d(\"ParseToState\", \"Original RRULE String: ${event.recurrenceRule}\")\n  Log.d(\"ParseToState\", \"Parsed isAllDay: $isAllDay\")\n  Log.d(\"ParseToState\", \"Parsed StartDate: $parsedStartDate, StartTime: $parsedStartTime\")\n  Log.d(\"ParseToState\", \"Parsed EndDate: $parsedEndDate, EndTime: $parsedEndTime\")\n  Log.d(\"ParseToState\", \"Parsed isRecurring: $isRecurring\")\n  Log.d(\"ParseToState\", \"Parsed recurrenceRule (FREQ): ${recurrenceOption?.rruleValue}\")\n  Log.d(\"ParseToState\", \"Parsed selectedWeekdays: $selectedWeekdays\")\n  Log.d(\"ParseToState\", \"Parsed recurrenceEndType: $recurrenceEndType\")\n  Log.d(\"ParseToState\", \"Parsed recurrenceEndDate: $recurrenceEndDate\")\n  Log.d(\"ParseToState\", \"Parsed recurrenceCount: $recurrenceCount\")\n  Log.d(\"ParseToState\", \"-----------------------------------------\")\n\n  return EventDateTimeState(\n      startDate = parsedStartDate,\n      startTime = parsedStartTime,\n      endDate = parsedEndDate,\n      endTime = parsedEndTime,\n      isAllDay = isAllDay,\n      isRecurring = isRecurring,\n      recurrenceRule = recurrenceOption?.rruleValue,\n      selectedWeekdays = selectedWeekdays,\n      recurrenceEndType = recurrenceEndType,\n      recurrenceEndDate = recurrenceEndDate,\n      recurrenceCount = recurrenceCount)\n}\n\nfun buildUpdateEventApiRequest(\n    originalEvent: EventDto,\n    currentSummary: String,\n    currentDescription: String,\n    currentLocation: String,\n    currentDateTimeState: EventDateTimeState,\n    formattedStartStr: String,\n    formattedEndStr: String,\n    finalRRuleStringFromUi: String?,\n    userTimeZoneIdForTimed: String,\n    selectedUpdateMode: EventUpdateMode\n): EventRequest? {\n  var hasChanges = false\n\n  val summaryUpdate =\n      currentSummary.takeIf { it != originalEvent.summary }?.also { hasChanges = true }\n  val descriptionUpdate =\n      currentDescription\n          .takeIf { it != (originalEvent.description ?: \"\") }\n          ?.also { hasChanges = true }\n  val locationUpdate =\n      currentLocation.takeIf { it != (originalEvent.location ?: \"\") }?.also { hasChanges = true }\n\n  var startTimeUpdate: String? = null\n  var endTimeUpdate: String? = null\n  var isAllDayUpdate: Boolean? = null\n  var timeZoneIdUpdate: String? = null\n\n  // Проверяем изменение правила повторения\n  val originalRRuleString = originalEvent.recurrenceRule?.takeIf { it.isNotBlank() }\n  val currentRRuleString = finalRRuleStringFromUi?.takeIf { it.isNotBlank() }\n  val recurrenceRuleChanged = currentRRuleString != originalRRuleString\n\n  // Определяем, изменяется ли только правило повторения для всех событий\n  val isOnlyRecurrenceChangeForAllEvents =\n      recurrenceRuleChanged &&\n          selectedUpdateMode == EventUpdateMode.ALL_IN_SERIES &&\n          currentSummary == originalEvent.summary &&\n          currentDescription == (originalEvent.description ?: \"\") &&\n          currentLocation == (originalEvent.location ?: \"\") &&\n          currentDateTimeState.isAllDay == originalEvent.isAllDay\n\n  // Обновляем даты только если это НЕ случай изменения только правила повторения для всех событий\n  if (!isOnlyRecurrenceChangeForAllEvents) {\n    if (currentDateTimeState.isAllDay != originalEvent.isAllDay) {\n      isAllDayUpdate = currentDateTimeState.isAllDay\n      hasChanges = true\n    }\n\n    if (formattedStartStr != originalEvent.startTime) {\n      startTimeUpdate = formattedStartStr\n      hasChanges = true\n    }\n    if (formattedEndStr != originalEvent.endTime) {\n      endTimeUpdate = formattedEndStr\n      hasChanges = true\n    }\n\n    // Обновляем timezone только если обновляются даты\n    if (!currentDateTimeState.isAllDay) {\n      if (userTimeZoneIdForTimed.isNotBlank()) {\n        if (isAllDayUpdate == false ||\n            (isAllDayUpdate == null && (startTimeUpdate != null || endTimeUpdate != null))) {\n          timeZoneIdUpdate = userTimeZoneIdForTimed\n        }\n      }\n    }\n  }\n\n  var recurrenceForApiRequest: List<String>? = null\n\n  if (recurrenceRuleChanged) {\n    hasChanges = true\n\n    if (currentRRuleString != null) {\n      recurrenceForApiRequest = listOf(\"RRULE:$currentRRuleString\")\n    } else {\n      recurrenceForApiRequest = emptyList()\n    }\n  }\n\n  if (selectedUpdateMode == EventUpdateMode.SINGLE_INSTANCE && recurrenceForApiRequest != null) {\n    Log.w(\n        \"BuildUpdateRequest\",\n        \"Recurrence data was calculated but will be ignored for SINGLE_INSTANCE update mode.\")\n    recurrenceForApiRequest = null\n  }\n\n  val noPrimaryFieldChanges =\n      summaryUpdate == null &&\n          descriptionUpdate == null &&\n          locationUpdate == null &&\n          startTimeUpdate == null &&\n          endTimeUpdate == null &&\n          isAllDayUpdate == null &&\n          timeZoneIdUpdate == null\n\n  if (noPrimaryFieldChanges && recurrenceForApiRequest == null) {\n    Log.d(\n        \"BuildUpdateRequest\",\n        \"No actual changes to save after considering all fields and update mode.\")\n    return null\n  }\n\n  Log.d(\"BuildUpdateRequest\", \"Update mode: $selectedUpdateMode\")\n  Log.d(\"BuildUpdateRequest\", \"Recurrence rule changed: $recurrenceRuleChanged\")\n  Log.d(\n      \"BuildUpdateRequest\",\n      \"Is only recurrence change for all events: $isOnlyRecurrenceChangeForAllEvents\")\n  Log.d(\"BuildUpdateRequest\", \"Start time update: $startTimeUpdate\")\n  Log.d(\"BuildUpdateRequest\", \"End time update: $endTimeUpdate\")\n\n  return EventRequest(\n      summary = summaryUpdate,\n      description = descriptionUpdate,\n      location = locationUpdate,\n      startTime = startTimeUpdate,\n      endTime = endTimeUpdate,\n      isAllDay = isAllDayUpdate,\n      timeZoneId = timeZoneIdUpdate,\n      recurrence = recurrenceForApiRequest)\n}\n",
      "info": {
        "size": 33912,
        "last_modified": "2025-08-06T08:35:04.214037",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/ui/create/CreateEventScreen.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.ui.create\n\nimport android.text.format.DateFormat\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedContent\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.ExitTransition\nimport androidx.compose.animation.SizeTransform\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.togetherWith\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.heightIn\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Check\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.DatePicker\nimport androidx.compose.material3.DatePickerDialog\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.LoadingIndicator\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.SelectableDates\nimport androidx.compose.material3.SheetValue\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.material3.TimePicker\nimport androidx.compose.material3.rememberDatePickerState\nimport androidx.compose.material3.rememberTimePickerState\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport com.lpavs.caliinda.core.ui.util.DateTimeUtils\nimport com.lpavs.caliinda.feature.event_management.ui.shared.AdaptiveContainer\nimport com.lpavs.caliinda.feature.event_management.ui.shared.TimePickerDialog\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimePicker\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventDateTimeState\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.EventNameSection\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceEndType\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.RecurrenceOption\nimport com.lpavs.caliinda.feature.event_management.ui.shared.sections.suggestions.SuggestionsViewModel\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementUiEvent\nimport com.lpavs.caliinda.feature.event_management.vm.EventManagementViewModel\nimport java.time.DayOfWeek\nimport java.time.Instant\nimport java.time.LocalDate\nimport java.time.LocalTime\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.format.DateTimeFormatter\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalMaterial3ExpressiveApi::class)\n@Composable\nfun CreateEventScreen(\n    viewModel: EventManagementViewModel = hiltViewModel(),\n    suggestionsViewModel: SuggestionsViewModel = hiltViewModel(),\n    userTimeZone: String,\n    initialDate: LocalDate,\n    onDismiss: () -> Unit,\n    currentSheetValue: SheetValue\n) {\n  var summary by remember { mutableStateOf(\"\") }\n  var description by remember { mutableStateOf(\"\") }\n  var location by remember { mutableStateOf(\"\") }\n  val userTimeZoneId = remember { ZoneId.of(userTimeZone) }\n\n  var summaryError by remember { mutableStateOf<String?>(null) }\n  var validationError by remember { mutableStateOf<String?>(null) }\n\n  var generalError by remember { mutableStateOf<String?>(null) }\n\n  val context = LocalContext.current\n  val uiState by viewModel.uiState.collectAsState()\n  // Состояния для управления видимостью диалогов M3\n  var showStartDatePicker by remember { mutableStateOf(false) }\n  var showStartTimePicker by remember { mutableStateOf(false) }\n  var showEndDatePicker by remember { mutableStateOf(false) }\n  var showEndTimePicker by remember { mutableStateOf(false) }\n  var showRecurrenceEndDatePicker by remember { mutableStateOf(false) }\n\n  // Форматер\n  val untilFormatter = remember { DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\") }\n\n  var eventDateTimeState by remember {\n    val defaultStartTime = LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0)\n    val defaultEndTime = LocalTime.now().plusHours(2).withMinute(0).withSecond(0).withNano(0)\n    var effectiveEndDate = initialDate\n\n    if (defaultEndTime.isBefore(defaultStartTime)) {\n      effectiveEndDate = initialDate.plusDays(1)\n    }\n\n    mutableStateOf(\n        EventDateTimeState(\n            startDate = initialDate,\n            startTime = LocalTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0),\n            endDate = effectiveEndDate,\n            endTime = LocalTime.now().plusHours(2).withMinute(0).withSecond(0).withNano(0),\n            isAllDay = false,\n            selectedWeekdays = emptySet(),\n            recurrenceEndType = RecurrenceEndType.NEVER,\n            isRecurring = false,\n            recurrenceRule = null))\n  }\n\n  LaunchedEffect(key1 = true) {\n    viewModel.eventFlow.collect { event ->\n      when (event) {\n        is EventManagementUiEvent.ShowMessage -> {\n          //          Toast.makeText(context, event.message, Toast.LENGTH_SHORT).show()\n        }\n        is EventManagementUiEvent.OperationSuccess -> {\n          onDismiss()\n        }\n      }\n    }\n  }\n  LaunchedEffect(eventDateTimeState.startTime) {\n    suggestionsViewModel.updateSortContext(\n        eventDateTimeState.startTime, eventDateTimeState.isAllDay)\n  }\n  val suggestedChips by suggestionsViewModel.suggestionChips.collectAsStateWithLifecycle()\n\n  fun formatEventTimesForSaving(\n      state: EventDateTimeState,\n      timeZoneId: String?\n  ): Pair<String?, String?> {\n    return if (state.isAllDay) {\n      val formatter = DateTimeFormatter.ISO_LOCAL_DATE\n      val startDateStr =\n          try {\n            state.startDate.format(formatter)\n          } catch (_: Exception) {\n            null\n          }\n      val effectiveEndDate = state.endDate.plusDays(1)\n      val endDateStr =\n          try {\n            effectiveEndDate.format(formatter)\n          } catch (_: Exception) {\n            null\n          }\n      Log.d(\"CreateEvent\", \"Formatting All-Day: Start Date=$startDateStr, End Date=$endDateStr\")\n      Pair(startDateStr, endDateStr)\n    } else {\n      if (timeZoneId == null) {\n        Log.e(\"CreateEvent\", \"Cannot format timed event without TimeZone ID!\")\n        return Pair(null, null)\n      }\n      val startTimeIso =\n          DateTimeUtils.formatDateTimeToIsoWithOffset(\n              state.startDate, state.startTime!!, false, timeZoneId)\n      val endTimeIso =\n          DateTimeUtils.formatDateTimeToIsoWithOffset(\n              state.endDate, state.endTime!!, false, timeZoneId)\n      Log.d(\n          \"CreateEvent\", \"Formatting Timed: Start DateTime=$startTimeIso, End DateTime=$endTimeIso\")\n      Pair(startTimeIso, endTimeIso)\n    }\n  }\n\n  fun validateInput(): Boolean {\n    summaryError =\n        if (summary.isBlank()) R.string.error_summary_cannot_be_empty.toString() else null\n    validationError = null\n    val state = eventDateTimeState\n    if (!state.isAllDay && (state.startTime == null || state.endTime == null)) {\n      validationError = R.string.error_specify_start_and_end_time.toString()\n      return false\n    }\n    val (testStartTimeStr, testEndTimeStr) = formatEventTimesForSaving(state, userTimeZone)\n    if (testStartTimeStr == null || testEndTimeStr == null) {\n      validationError = R.string.error_failed_to_format_datetime.toString()\n      return false\n    }\n    return summaryError == null && validationError == null\n  }\n\n  val onSaveClick: () -> Unit = saveLambda@{\n    generalError = null\n    if (validateInput()) {\n      val (startStr, endStr) = formatEventTimesForSaving(eventDateTimeState, userTimeZone)\n\n      if (startStr == null || endStr == null) {\n        validationError = R.string.error_failed_to_format_datetime.toString()\n        Log.e(\n            \"CreateEvent\",\n            \"Failed to format strings based on state: $eventDateTimeState and TimeZone: $userTimeZoneId\")\n        return@saveLambda\n      }\n      val baseRule = eventDateTimeState.recurrenceRule?.takeIf { it.isNotBlank() }\n      var finalRecurrenceRule: String? = null\n\n      if (baseRule != null) {\n        val ruleParts = mutableListOf(baseRule) // Начинаем с FREQ=...\n\n        // Добавляем BYDAY, если нужно\n        if (baseRule == RecurrenceOption.Weekly.rruleValue &&\n            eventDateTimeState.selectedWeekdays.isNotEmpty()) {\n          val bydayString =\n              eventDateTimeState.selectedWeekdays.sorted().joinToString(\",\") { day ->\n                when (day) {\n                  DayOfWeek.MONDAY -> \"MO\"\n                  DayOfWeek.TUESDAY -> \"TU\"\n                  DayOfWeek.WEDNESDAY -> \"WE\"\n                  DayOfWeek.THURSDAY -> \"TH\"\n                  DayOfWeek.FRIDAY -> \"FR\"\n                  DayOfWeek.SATURDAY -> \"SA\"\n                  DayOfWeek.SUNDAY -> \"SU\"\n                }\n              }\n          ruleParts.add(\"BYDAY=$bydayString\")\n        }\n\n        // Добавляем UNTIL или COUNT\n        when (eventDateTimeState.recurrenceEndType) {\n          RecurrenceEndType.DATE -> {\n            eventDateTimeState.recurrenceEndDate?.let { endDate ->\n              val userTimeZone = userTimeZoneId\n              endDate.atTime(LocalTime.MAX).atZone(userTimeZone)\n\n              val endDateTimeUtc =\n                  endDate\n                      .atTime(23, 59, 59)\n                      .atZone(userTimeZone)\n                      .withZoneSameInstant(ZoneOffset.UTC)\n\n              val untilString = untilFormatter.format(endDateTimeUtc)\n              ruleParts.add(\"UNTIL=$untilString\")\n            }\n          }\n\n          RecurrenceEndType.COUNT -> {\n            eventDateTimeState.recurrenceCount?.let { count -> ruleParts.add(\"COUNT=$count\") }\n          }\n\n          RecurrenceEndType.NEVER -> {\n            // Ничего не добавляем\n          }\n        }\n\n        // Собираем все части через точку с запятой\n        finalRecurrenceRule = ruleParts.joinToString(\";\")\n      }\n      Log.d(\"CreateEvent\", \"Final RRULE to send: $finalRecurrenceRule\")\n      val request =\n          EventRequest(\n              summary = summary.trim(),\n              startTime = startStr,\n              endTime = endStr,\n              isAllDay = eventDateTimeState.isAllDay,\n              timeZoneId = if (eventDateTimeState.isAllDay) null else userTimeZone,\n              description = description.trim().takeIf { it.isNotEmpty() },\n              location = location.trim().takeIf { it.isNotEmpty() },\n              recurrence = finalRecurrenceRule?.let { listOf(\"RRULE:$it\") })\n\n      viewModel.createEvent(request)\n    } else {\n      Toast.makeText(context, R.string.error_check_input_data, Toast.LENGTH_SHORT).show()\n    }\n  }\n\n  Row(\n      modifier = Modifier.fillMaxWidth().padding(horizontal = 4.dp, vertical = 0.dp),\n      verticalAlignment = Alignment.CenterVertically,\n      horizontalArrangement = Arrangement.Center) {\n        AnimatedContent(\n            targetState = currentSheetValue,\n            transitionSpec = {\n              (EnterTransition.None)\n                  .togetherWith(ExitTransition.None)\n                  .using(\n                      SizeTransform(\n                          clip = false,\n                          sizeAnimationSpec = { _, _ ->\n                            spring(\n                                dampingRatio = Spring.DampingRatioLowBouncy,\n                                stiffness = Spring.StiffnessMediumLow)\n                          }))\n            },\n            label = \"SaveButtonAnimation\") { targetSheetValue ->\n              val expandedSize = ButtonDefaults.LargeContainerHeight\n              val defaultSize = ButtonDefaults.MediumContainerHeight\n\n              val isNotCompactState = targetSheetValue == SheetValue.Expanded\n\n              val size = if (!isNotCompactState) defaultSize else expandedSize\n\n              Button(\n                  onClick = onSaveClick,\n                  enabled = !uiState.isLoading,\n                  modifier = Modifier.heightIn(size),\n                  contentPadding = ButtonDefaults.contentPaddingFor(size)) {\n                    if (uiState.isLoading) {\n                      LoadingIndicator(\n                          color = colorScheme.onPrimary,\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    } else {\n                      Icon(\n                          imageVector = Icons.Filled.Check,\n                          contentDescription = \"Сохранить\",\n                          modifier = Modifier.size(ButtonDefaults.iconSizeFor(size)))\n                    }\n                  }\n            }\n      }\n\n  Column(\n      modifier =\n          Modifier.verticalScroll(rememberScrollState())\n              .padding(horizontal = 16.dp, vertical = 4.dp)\n              .fillMaxWidth(),\n      verticalArrangement = Arrangement.spacedBy(4.dp)) {\n        AdaptiveContainer {\n          EventNameSection(\n              summary = summary,\n              summaryError = summaryError,\n              onSummaryChange = { summary = it },\n              onSummaryErrorChange = { summaryError = it },\n              isLoading = uiState.isLoading,\n              suggestedChips = suggestedChips)\n        }\n        AdaptiveContainer {\n          EventDateTimePicker(\n              state = eventDateTimeState,\n              onStateChange = { newState ->\n                eventDateTimeState = newState\n                validationError = null\n              },\n              isLoading = uiState.isLoading,\n              onRequestShowStartDatePicker = { showStartDatePicker = true },\n              onRequestShowStartTimePicker = { showStartTimePicker = true },\n              onRequestShowEndDatePicker = { showEndDatePicker = true },\n              onRequestShowEndTimePicker = { showEndTimePicker = true },\n              onRequestShowRecurrenceEndDatePicker = { showRecurrenceEndDatePicker = true },\n              modifier = Modifier.fillMaxWidth())\n        }\n        validationError?.let { Text(it, color = colorScheme.error, style = typography.bodySmall) }\n\n        AdaptiveContainer {\n          OutlinedTextField(\n              value = description,\n              onValueChange = { description = it },\n              label = { Text(stringResource(R.string.description)) },\n              modifier = Modifier.fillMaxWidth().height(100.dp),\n              maxLines = 4,\n              enabled = !uiState.isLoading,\n              shape = RoundedCornerShape(25.dp))\n          OutlinedTextField(\n              value = location,\n              onValueChange = { location = it },\n              label = { Text(stringResource(R.string.location)) },\n              modifier = Modifier.fillMaxWidth(),\n              singleLine = true,\n              enabled = !uiState.isLoading,\n              shape = RoundedCornerShape(25.dp))\n        }\n        generalError?.let { Text(it, color = colorScheme.error, style = typography.bodyMedium) }\n        Spacer(modifier = Modifier.height(16.dp))\n      }\n\n  val currentDateTimeState = eventDateTimeState\n\n  if (showStartDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.startDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli())\n    DatePickerDialog(\n        onDismissRequest = { showStartDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      currentDateTimeState.copy(\n                          startDate = selectedDate,\n                          endDate =\n                              if (selectedDate.isAfter(currentDateTimeState.endDate) ||\n                                  currentDateTimeState.startTime == null)\n                                  selectedDate\n                              else currentDateTimeState.endDate)\n                }\n                showStartDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n  if (showStartTimePicker) {\n    val initialTime = currentDateTimeState.startTime ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showStartTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n                var newEndTime = currentDateTimeState.endTime\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.endTime != null &&\n                    !selectedTime.isBefore(currentDateTimeState.endTime)) {\n                  newEndTime = selectedTime.plusHours(1).withNano(0)\n                }\n                eventDateTimeState =\n                    currentDateTimeState.copy(startTime = selectedTime, endTime = newEndTime)\n                showStartTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showStartTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n\n  if (showEndDatePicker) {\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis =\n                currentDateTimeState.endDate\n                    .atStartOfDay(userTimeZoneId)\n                    .toInstant()\n                    .toEpochMilli(),\n            selectableDates =\n                object : SelectableDates {\n                  val startMillis =\n                      currentDateTimeState.startDate\n                          .atStartOfDay(userTimeZoneId)\n                          .toInstant()\n                          .toEpochMilli()\n\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    return utcTimeMillis >= startMillis\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= currentDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState = currentDateTimeState.copy(endDate = selectedDate)\n                }\n                showEndDatePicker = false\n              },\n              enabled = datePickerState.selectedDateMillis != null) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n\n  if (showEndTimePicker) {\n    val initialTime =\n        currentDateTimeState.endTime\n            ?: currentDateTimeState.startTime?.plusHours(1)\n            ?: LocalTime.now()\n    val timePickerState =\n        rememberTimePickerState(\n            initialHour = initialTime.hour,\n            initialMinute = initialTime.minute,\n            is24Hour = DateFormat.is24HourFormat(context))\n    TimePickerDialog(\n        onDismissRequest = { showEndTimePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                val selectedTime =\n                    LocalTime.of(timePickerState.hour, timePickerState.minute).withNano(0)\n\n                var newFinalEndDate = currentDateTimeState.endDate\n\n                if (currentDateTimeState.startDate == currentDateTimeState.endDate &&\n                    currentDateTimeState.startTime != null &&\n                    selectedTime.isBefore(currentDateTimeState.startTime)) {\n                  newFinalEndDate = currentDateTimeState.startDate.plusDays(1)\n                }\n\n                eventDateTimeState =\n                    currentDateTimeState.copy(endTime = selectedTime, endDate = newFinalEndDate)\n                showEndTimePicker = false\n              }) {\n                Text(\"OK\")\n              }\n        },\n        dismissButton = {\n          TextButton(onClick = { showEndTimePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          TimePicker(state = timePickerState)\n        }\n  }\n  if (showRecurrenceEndDatePicker) {\n    val initialSelectedDateMillis =\n        eventDateTimeState.recurrenceEndDate\n            ?.atStartOfDay(userTimeZoneId)\n            ?.toInstant()\n            ?.toEpochMilli()\n            ?: eventDateTimeState.startDate\n                .plusMonths(1)\n                .atStartOfDay(userTimeZoneId)\n                .toInstant()\n                .toEpochMilli()\n\n    val datePickerState =\n        rememberDatePickerState(\n            initialSelectedDateMillis = initialSelectedDateMillis,\n            selectableDates =\n                object : SelectableDates {\n                  override fun isSelectableDate(utcTimeMillis: Long): Boolean {\n                    val selectedLocalDate =\n                        Instant.ofEpochMilli(utcTimeMillis).atZone(userTimeZoneId).toLocalDate()\n                    return !selectedLocalDate.isBefore(eventDateTimeState.startDate)\n                  }\n\n                  override fun isSelectableYear(year: Int): Boolean {\n                    return year >= eventDateTimeState.startDate.year\n                  }\n                })\n    DatePickerDialog(\n        onDismissRequest = { showRecurrenceEndDatePicker = false },\n        confirmButton = {\n          TextButton(\n              onClick = {\n                datePickerState.selectedDateMillis?.let { millis ->\n                  val selectedDate =\n                      Instant.ofEpochMilli(millis).atZone(userTimeZoneId).toLocalDate()\n                  eventDateTimeState =\n                      eventDateTimeState.copy(\n                          recurrenceEndDate = selectedDate,\n                          recurrenceEndType = RecurrenceEndType.DATE,\n                          recurrenceCount = null)\n                }\n                showRecurrenceEndDatePicker = false\n              },\n          ) {\n            Text(\"OK\")\n          }\n        },\n        dismissButton = {\n          TextButton(onClick = { showRecurrenceEndDatePicker = false }) {\n            Text(stringResource(R.string.cancel))\n          }\n        }) {\n          DatePicker(state = datePickerState)\n        }\n  }\n}\n",
      "info": {
        "size": 24882,
        "last_modified": "2025-08-06T08:35:04.217307",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/event_management/vm/EventManagementViewModel.kt",
      "content": "package com.lpavs.caliinda.feature.event_management.vm\n\nimport android.util.Log\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.lpavs.caliinda.core.data.remote.EventDeleteMode\nimport com.lpavs.caliinda.core.data.remote.EventUpdateMode\nimport com.lpavs.caliinda.core.data.remote.dto.EventDto\nimport com.lpavs.caliinda.core.data.remote.dto.EventRequest\nimport com.lpavs.caliinda.core.data.repository.CalendarRepository\nimport com.lpavs.caliinda.core.data.repository.SettingsRepository\nimport com.lpavs.caliinda.core.data.utils.UiText\nimport com.lpavs.caliinda.feature.calendar.ui.components.FunMessages\nimport com.lpavs.caliinda.feature.event_management.ui.shared.RecurringDeleteChoice\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.stateIn\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport java.time.LocalDate\nimport java.time.OffsetDateTime\nimport java.time.ZoneId\nimport java.time.ZoneOffset\nimport java.time.format.DateTimeFormatter\nimport java.time.format.DateTimeParseException\nimport javax.inject.Inject\n\n@HiltViewModel\nclass EventManagementViewModel\n@Inject\nconstructor(\n    settingsRepository: SettingsRepository,\n    private val calendarRepository: CalendarRepository,\n) : ViewModel() {\n  private val _uiState = MutableStateFlow(EventManagementUiState())\n  val uiState: StateFlow<EventManagementUiState> = _uiState.asStateFlow()\n\n  private val _eventFlow = MutableSharedFlow<EventManagementUiEvent>()\n  val eventFlow: SharedFlow<EventManagementUiEvent> = _eventFlow.asSharedFlow()\n\n  val timeZone: StateFlow<String> =\n      settingsRepository.timeZoneFlow.stateIn(\n          viewModelScope, SharingStarted.WhileSubscribed(5000), ZoneId.systemDefault().id)\n\n  /**\n   * Вызывается из UI (формы/диалога редактирования) для сохранения изменений.\n   *\n   * @param updatedEventData Данные, введенные пользователем в форме.\n   * @param modeFromUi Режим обновления (особенно важен для повторяющихся, выбирается заранее). Если\n   *   событие одиночное, mode обычно SINGLE_INSTANCE или можно передать специальное значение,\n   *   которое бэкенд поймет как \"не повторяющееся\". Но так как update_mode на бэке обязательный,\n   *   всегда передаем режим.\n   */\n  fun confirmEventUpdate(updatedEventData: EventRequest, modeFromUi: EventUpdateMode) {\n    val originalEvent = _uiState.value.eventBeingEdited ?: return\n    viewModelScope.launch {\n      _uiState.update { it.copy(isLoading = true, operationError = null) }\n      val result =\n          calendarRepository.updateEvent(\n              eventId = originalEvent.id, updateData = updatedEventData, mode = modeFromUi)\n      _uiState.update { it.copy(isLoading = false) }\n      if (result.isSuccess) {\n        // Обычные случайные сообщения для обновления\n        val message = FunMessages.getEventUpdatedMessage(originalEvent.summary)\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n      } else {\n        val message =\n            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                ?: FunMessages.getUpdateErrorMessage()\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n      }\n    }\n  }\n\n  fun createEvent(request: EventRequest) {\n    viewModelScope.launch {\n      _uiState.update { it.copy(isLoading = true, operationError = null) }\n\n      val result = calendarRepository.createEvent(request)\n\n      _uiState.update { it.copy(isLoading = false) }\n\n      if (result.isSuccess) {\n        val message = FunMessages.getEventCreatedMessage(request.summary)\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n      } else {\n        val message =\n            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                ?: FunMessages.getCreateErrorMessage()\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n      }\n    }\n  }\n\n  /**\n   * Вызывается из UI, когда пользователь инициирует удаление события. Устанавливает ID события и\n   * показывает диалог подтверждения.\n   */\n  fun requestDeleteConfirmation(event: EventDto) {\n    _uiState.update {\n      val isActuallyRecurring = event.recurringEventId != null || event.originalStartTime != null\n      Log.d(\n          TAG,\n          \"requestDeleteConfirmation for event: ${event.id}, summary: '${event.summary}', isAllDay: ${event.isAllDay}, recurringId: ${event.recurringEventId}, originalStart: ${event.originalStartTime}, calculatedIsRecurring: $isActuallyRecurring\")\n\n      it.copy(\n          eventPendingDeletion = event,\n          showDeleteConfirmationDialog = !isActuallyRecurring,\n          showRecurringDeleteOptionsDialog = isActuallyRecurring,\n      )\n    }\n  }\n\n  /** Вызывается из UI, когда пользователь отменяет удаление в диалоге. */\n  fun cancelDelete() {\n    _uiState.update {\n      it.copy(\n          eventPendingDeletion = null,\n          showDeleteConfirmationDialog = false,\n          showRecurringDeleteOptionsDialog = false)\n    }\n  }\n\n  /**\n   * Вызывается из UI, когда пользователь подтверждает удаление в диалоге. Запускает процесс\n   * удаления через DataManager.\n   */\n  fun confirmDeleteEvent() {\n    val eventToDelete = _uiState.value.eventPendingDeletion ?: return\n\n    viewModelScope.launch {\n      _uiState.update {\n        it.copy(\n            isLoading = true,\n            showDeleteConfirmationDialog = false,\n            eventPendingDeletion = null,\n            operationError = null)\n      }\n\n      val result = calendarRepository.deleteEvent(eventToDelete.id, EventDeleteMode.DEFAULT)\n        _uiState.update { it.copy(isLoading = false) }\n      if (result.isSuccess) {\n        val message = FunMessages.getEventDeletedMessage(eventToDelete.summary)\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n      } else {\n        val errorMessage: UiText =\n            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                ?: run { FunMessages.getDeleteErrorMessage() }\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n      }\n    }\n  }\n\n  fun confirmRecurringDelete(choice: RecurringDeleteChoice) {\n    val eventToDelete = _uiState.value.eventPendingDeletion ?: return\n    _uiState.update {\n      it.copy(\n          isLoading = true,\n          showDeleteConfirmationDialog = false,\n          eventPendingDeletion = null,\n          operationError = null)\n    }\n\n    when (choice) {\n      RecurringDeleteChoice.SINGLE_INSTANCE -> {\n        viewModelScope.launch {\n          val result =\n              calendarRepository.deleteEvent(eventToDelete.id, EventDeleteMode.INSTANCE_ONLY)\n            _uiState.update { it.copy(isLoading = false) }\n\n          if (result.isSuccess) {\n            val message = FunMessages.getSeriesDeletedMessage()\n            _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n            _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n          } else {\n            val errorMessage: UiText =\n                result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                    ?: run { FunMessages.getGenericErrorMessage() }\n            _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n          }\n        }\n      }\n\n      RecurringDeleteChoice.THIS_AND_FOLLOWING -> {\n        handleThisAndFollowingDelete(eventToDelete)\n      }\n\n      RecurringDeleteChoice.ALL_IN_SERIES -> {\n        val idForBackendCall = eventToDelete.recurringEventId ?: eventToDelete.id\n        viewModelScope.launch {\n          val result = calendarRepository.deleteEvent(idForBackendCall, EventDeleteMode.DEFAULT)\n            _uiState.update { it.copy(isLoading = false) }\n\n          if (result.isSuccess) {\n            val message = FunMessages.getSeriesDeletedMessage()\n            _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n            _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n          } else {\n            val errorMessage: UiText =\n                result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                    ?: run { FunMessages.getGenericErrorMessage() }\n            _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Обрабатывает удаление текущего и последующих событий. Это делается путем обновления\n   * мастер-события: в его правило повторения (RRULE) добавляется дата окончания (UNTIL),\n   * установленная на день до удаляемого экземпляра.\n   *\n   * @param eventInstance Экземпляр события, с которого начинается удаление.\n   */\n  private fun handleThisAndFollowingDelete(eventInstance: EventDto) {\n    val originalRRule = eventInstance.recurrenceRule\n    if (originalRRule.isNullOrBlank()) {\n      Log.e(\n          TAG,\n          \"Cannot perform 'this and following' delete: Event ${eventInstance.id} has no recurrence rule.\")\n      _uiState.update { it.copy(operationError = FunMessages.getGenericErrorMessage()) }\n      return\n    }\n\n    val masterEventId = eventInstance.recurringEventId ?: eventInstance.id\n\n    val instanceStartDate: LocalDate =\n        try {\n          OffsetDateTime.parse(eventInstance.startTime, DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n              .toLocalDate()\n        } catch (_: DateTimeParseException) {\n          try {\n            LocalDate.parse(eventInstance.startTime, DateTimeFormatter.ISO_LOCAL_DATE)\n          } catch (e2: DateTimeParseException) {\n            Log.e(\n                TAG,\n                \"Failed to parse event start time in any known format: ${eventInstance.startTime}\",\n                e2)\n            _uiState.update { it.copy(operationError = FunMessages.getGenericErrorMessage()) }\n            return\n          }\n        }\n\n    val newUntilDate = instanceStartDate.minusDays(1)\n\n    val untilString =\n        newUntilDate\n            .atTime(23, 59, 59)\n            .atZone(ZoneOffset.UTC)\n            .format(DateTimeFormatter.ofPattern(\"yyyyMMdd'T'HHmmss'Z'\"))\n\n    val ruleParts =\n        originalRRule.split(';').filterNot {\n          it.startsWith(\"UNTIL=\", ignoreCase = true) || it.startsWith(\"COUNT=\", ignoreCase = true)\n        }\n    val newRRuleString = \"RRULE:\" + ruleParts.joinToString(\";\") + \";UNTIL=$untilString\"\n\n    val updateRequest = EventRequest(recurrence = listOf(newRRuleString))\n\n    Log.d(\n        TAG, \"Updating master event $masterEventId to stop recurrence. New RRULE: $newRRuleString\")\n\n    viewModelScope.launch {\n      val result =\n          calendarRepository.updateEvent(\n              eventId = masterEventId,\n              updateData = updateRequest,\n              mode = EventUpdateMode.ALL_IN_SERIES)\n        _uiState.update { it.copy(isLoading = false) }\n      if (result.isSuccess) {\n        val message = FunMessages.getSeriesDeletedMessage()\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(message))\n        _eventFlow.emit(EventManagementUiEvent.OperationSuccess)\n      } else {\n        val errorMessage: UiText =\n            result.exceptionOrNull()?.message?.let { UiText.DynamicString(it) }\n                ?: run { FunMessages.getGenericErrorMessage() }\n        _eventFlow.emit(EventManagementUiEvent.ShowMessage(errorMessage))\n      }\n    }\n  }\n\n  /** Вызывается из UI, когда пользователь инициирует редактирование события. */\n  fun requestEditEvent(event: EventDto) {\n    val isAlreadyRecurring =\n        event.recurringEventId != null ||\n            event.originalStartTime != null ||\n            !event.recurrenceRule.isNullOrEmpty()\n\n    _uiState.update {\n      it.copy(\n          eventBeingEdited = event,\n          showRecurringEditOptionsDialog = isAlreadyRecurring,\n          showEditEventDialog = !isAlreadyRecurring,\n          selectedUpdateMode =\n              if (!isAlreadyRecurring) {\n                EventUpdateMode.ALL_IN_SERIES\n              } else {\n                it.selectedUpdateMode\n              },\n      )\n    }\n    Log.d(\n        TAG,\n        \"Requested edit for event ID: ${event.id}, isAlreadyRecurring: $isAlreadyRecurring, initial selectedUpdateMode for form: ${_uiState.value.selectedUpdateMode}\")\n  }\n\n  /** Вызывается из диалога выбора режима редактирования для повторяющихся событий. */\n  fun onRecurringEditOptionSelected(choice: EventUpdateMode) {\n    val currentEvent = _uiState.value.eventBeingEdited\n    if (currentEvent == null) {\n      Log.e(TAG, \"onRecurringEditOptionSelected called but eventBeingEdited is null.\")\n      cancelEditEvent()\n      return\n    }\n\n    Log.d(\n        TAG,\n        \"Recurring edit mode selected: $choice for event: ${currentEvent.id}. Current RRULE in event: ${currentEvent.recurrenceRule}\")\n\n    _uiState.update {\n      it.copy(\n          showRecurringEditOptionsDialog = false,\n          showEditEventDialog = true,\n          selectedUpdateMode = choice)\n    }\n  }\n\n  /** Вызывается для отмены процесса редактирования (закрытия диалогов). */\n  fun cancelEditEvent() {\n    _uiState.update {\n      it.copy(\n          eventBeingEdited = null,\n          showRecurringEditOptionsDialog = false,\n          showEditEventDialog = false)\n    }\n    Log.d(TAG, \"Event editing cancelled.\")\n  }\n\n  /**\n   * Вызывается из UI, когда пользователь хочет посмотреть детали события. Устанавливает событие для\n   * просмотра и флаг для отображения UI.\n   */\n  fun requestEventDetails(event: EventDto) {\n    _uiState.update { currentState ->\n      currentState.copy(eventForDetailedView = event, showEventDetailedView = true)\n    }\n    Log.d(TAG, \"Requested event details for event ID: ${event.id}\")\n  }\n\n  /**\n   * Вызывается из UI, когда пользователь закрывает детальный просмотр события. Сбрасывает событие и\n   * флаг.\n   */\n  fun cancelEventDetails() {\n    _uiState.update { currentState ->\n      currentState.copy(eventForDetailedView = null, showEventDetailedView = false)\n    }\n    Log.d(TAG, \"Cancelled event details view.\")\n  }\n\n  companion object {\n    private const val TAG = \"EventManagementViewModel\"\n  }\n}\n\ndata class EventManagementUiState(\n    val operationError: UiText? = null,\n    val isLoading: Boolean = false,\n    val eventToDeleteId: String? = null,\n    val eventPendingDeletion: EventDto? = null,\n    val showDeleteConfirmationDialog: Boolean = false,\n    val showRecurringDeleteOptionsDialog: Boolean = false,\n    val eventBeingEdited: EventDto? = null,\n    val showRecurringEditOptionsDialog: Boolean = false,\n    val showEditEventDialog: Boolean = false,\n    val selectedUpdateMode: EventUpdateMode? = null,\n    val eventForDetailedView: EventDto? = null,\n    val showEventDetailedView: Boolean = false,\n)\n\nsealed class EventManagementUiEvent {\n  data class ShowMessage(val message: UiText) : EventManagementUiEvent()\n\n  object OperationSuccess : EventManagementUiEvent()\n}\n",
      "info": {
        "size": 16384,
        "last_modified": "2025-08-06T08:35:04.221073",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/ui/CustomRotatingMorphShape.kt",
      "content": "package com.lpavs.caliinda.feature.agent.ui\n\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.Matrix\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.asComposePath\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport androidx.graphics.shapes.Morph\nimport androidx.graphics.shapes.toPath\n\nclass CustomRotatingMorphShape(\n    private val morph: Morph,\n    private val percentage: Float,\n    private val rotation: Float\n) : Shape {\n\n  private val matrix = Matrix()\n\n  override fun createOutline(\n      size: Size,\n      layoutDirection: LayoutDirection,\n      density: Density\n  ): Outline {\n    // Растягиваем на размер контейнера\n    matrix.reset() // Сбрасываем матрицу перед использованием\n    matrix.scale(size.width / 2f, size.height / 2f)\n    matrix.translate(1f, 1f) // Центрируем (предполагается радиус 1f в Morph)\n    matrix.rotateZ(rotation) // Вращаем\n\n    // Получаем путь из Morph и трансформируем\n    val path = morph.toPath(progress = percentage).asComposePath()\n    path.transform(matrix)\n\n    return Outline.Generic(path)\n  }\n}\n",
      "info": {
        "size": 1318,
        "last_modified": "2025-08-06T08:35:04.224655",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/ui/RecordButton.kt",
      "content": "package com.lpavs.caliinda.feature.agent.ui\n\nimport android.Manifest\nimport android.content.pm.PackageManager\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.animation.animateColorAsState\nimport androidx.compose.animation.core.LinearEasing\nimport androidx.compose.animation.core.RepeatMode\nimport androidx.compose.animation.core.animateFloat\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.animation.core.infiniteRepeatable\nimport androidx.compose.animation.core.rememberInfiniteTransition\nimport androidx.compose.animation.core.tween\nimport androidx.compose.foundation.gestures.awaitFirstDown\nimport androidx.compose.foundation.gestures.waitForUpOrCancellation\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Mic\nimport androidx.compose.material3.FloatingActionButton\nimport androidx.compose.material3.FloatingActionButtonDefaults\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.core.content.ContextCompat\nimport androidx.graphics.shapes.CornerRounding\nimport androidx.graphics.shapes.Morph\nimport androidx.graphics.shapes.RoundedPolygon\nimport androidx.graphics.shapes.star\nimport com.lpavs.caliinda.feature.calendar.ui.CalendarState\nimport kotlinx.coroutines.launch\n\n@Composable\nfun RecordButton(\n    uiState: CalendarState,\n    onStartRecording: () -> Unit, // Принимаем лямбды вместо ViewModel\n    onStopRecordingAndSend: () -> Unit,\n    onUpdatePermissionResult: (Boolean) -> Unit,\n    modifier: Modifier = Modifier // Принимаем внешний модификатор\n) {\n  val context = LocalContext.current\n  val scope = rememberCoroutineScope()\n  var isPressed by remember { mutableStateOf(false) } // Для UI эффекта нажатия\n\n  // --- Анимации и формы (без изменений) ---\n  val targetBackgroundColor =\n      if (uiState.isListening) {\n        colorScheme.error\n      } else {\n        colorScheme.primary\n      }\n  val animatedBackgroundColor by\n      animateColorAsState(\n          targetValue = targetBackgroundColor,\n          animationSpec = tween(durationMillis = 300),\n          label = \"RecordButtonBgColor\")\n  val animatedContentColor = contentColorFor(animatedBackgroundColor)\n\n  // --- Определение форм (предполагаем, что Morph, RoundedPolygon, CornerRounding в util) ---\n  val shapeA = remember { RoundedPolygon(numVertices = 5, rounding = CornerRounding(0.5f)) }\n  val shapeB = remember { RoundedPolygon.star(9, rounding = CornerRounding(0.3f), radius = 4f) }\n  val morph = remember { Morph(shapeA, shapeB) }\n\n  val infiniteTransition = rememberInfiniteTransition(\"morph_transition\")\n  val animatedProgress =\n      infiniteTransition.animateFloat(\n          initialValue = 0f,\n          targetValue = 1f,\n          animationSpec =\n              infiniteRepeatable(tween(1800, easing = LinearEasing), RepeatMode.Reverse),\n          label = \"animatedMorphProgress\")\n  val animatedRotation =\n      infiniteTransition.animateFloat(\n          initialValue = 0f,\n          targetValue = 360f,\n          animationSpec =\n              infiniteRepeatable(tween(4000, easing = LinearEasing), RepeatMode.Restart),\n          label = \"animatedMorphRotation\")\n  val animatedScale by\n      animateFloatAsState(\n          targetValue = if (isPressed || uiState.isListening) 1.45f else 1.0f,\n          animationSpec = tween(durationMillis = 300),\n          label = \"RecordButtonScale\")\n\n  // Лаунчер для запроса разрешения\n  val requestPermissionLauncher =\n      rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) {\n          isGranted: Boolean ->\n        onUpdatePermissionResult(isGranted) // Вызываем лямбду для обновления состояния в ViewModel\n        if (!isGranted) {\n          Toast.makeText(context, \"Разрешение на запись отклонено.\", Toast.LENGTH_LONG).show()\n        } else {\n          Log.i(\"RecordButton\", \"Permission granted by user.\")\n          Toast.makeText(\n                  context,\n                  \"Разрешение получено. Нажмите и удерживайте для записи.\",\n                  Toast.LENGTH_SHORT)\n              .show()\n        }\n      }\n\n  // Кнопка активна, если пользователь вошел и не идет загрузка/запись (для начала записи)\n  // Сама логика pointerInput будет обрабатывать uiState.isListening для остановки\n  val isInteractionEnabled = uiState.isSignedIn && !uiState.isLoading\n\n  Log.d(\n      \"RecordButton\",\n      \"Rendering FAB: isInteractionEnabled=$isInteractionEnabled, isPressed=$isPressed, isListening=${uiState.isListening}\")\n  FloatingActionButton(\n      onClick = {\n        // Если нужно простое нажатие для запроса разрешения, если его нет\n        if (!uiState.isPermissionGranted && isInteractionEnabled) {\n          scope.launch { requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO) }\n        }\n        Log.d(\"RecordButton\", \"FAB onClick triggered (handled permission request if needed)\")\n      },\n      containerColor = animatedBackgroundColor,\n      contentColor = animatedContentColor,\n      modifier =\n          modifier\n              //                .fillMaxSize()\n              .pointerInput(\n                  isInteractionEnabled, uiState.isPermissionGranted) { // Передаем зависимости в key\n                    if (!isInteractionEnabled) {\n                      Log.d(\"RecordButton\", \"Interaction disabled, returning from pointerInput.\")\n                      return@pointerInput // Не обрабатываем ввод, если кнопка неактивна\n                    }\n                    awaitPointerEventScope {\n                      while (true) {\n                        val down = awaitFirstDown(requireUnconsumed = false)\n                        Log.d(\"RecordButton\", \"Pointer down detected.\")\n                        isPressed = true\n                        try {\n                          // Проверяем разрешение прямо перед началом записи\n                          val hasPermission =\n                              ContextCompat.checkSelfPermission(\n                                  context, Manifest.permission.RECORD_AUDIO) ==\n                                  PackageManager.PERMISSION_GRANTED\n\n                          // Обновляем статус разрешения в ViewModel на всякий случай\n                          onUpdatePermissionResult(hasPermission)\n\n                          if (hasPermission) {\n                            // Если уже идет запись, нажатие игнорируем (остановка по отпусканию)\n                            if (!uiState.isListening) {\n                              Log.d(\"RecordButton\", \"Permission granted, starting recording.\")\n                              down.consume() // Потребляем событие\n                              scope.launch { onStartRecording() } // Вызываем лямбду начала записи\n                              try {\n                                waitForUpOrCancellation() // Ждем отпускания\n                                Log.d(\"RecordButton\", \"Pointer up detected, stopping recording.\")\n                              } finally {\n                                // Всегда останавливаем запись при отпускании/отмене, если она была\n                                // начата\n                                scope.launch {\n                                  onStopRecordingAndSend()\n                                } // Вызываем лямбду остановки\n                              }\n                            } else {\n                              Log.d(\"RecordButton\", \"Already recording, waiting for up.\")\n                              // Потребляем событие, чтобы оно не всплыло\n                              down.consume()\n                              // Просто ждем отпускания, чтобы остановить запись (логика в finally)\n                              try {\n                                waitForUpOrCancellation()\n                                Log.d(\n                                    \"RecordButton\",\n                                    \"Pointer up detected while recording, stopping recording.\")\n                              } finally {\n                                // Всегда останавливаем запись при отпускании/отмене\n                                scope.launch { onStopRecordingAndSend() }\n                              }\n                            }\n                          } else {\n                            Log.d(\"RecordButton\", \"Permission denied, requesting permission.\")\n                            down.consume() // Потребляем событие, чтобы не начать запись\n                            scope.launch {\n                              requestPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)\n                            }\n                            try {\n                              waitForUpOrCancellation() // Ждем отпускания (ничего не делаем)\n                              Log.d(\"RecordButton\", \"Pointer up after permission request.\")\n                            } finally {\n                              /* Ничего не делаем */\n                            }\n                          }\n                        } finally {\n                          Log.d(\n                              \"RecordButton\",\n                              \"Pointer input block finished, setting isPressed=false.\")\n                          isPressed = false // Сбрасываем состояние нажатия\n                        }\n                      }\n                    }\n                  }\n              .clip(\n                  if (isPressed || uiState.isListening) {\n                    // Используем CustomRotatingMorphShape из папки common\n                    CustomRotatingMorphShape(\n                        morph = morph,\n                        percentage = animatedProgress.value,\n                        rotation = animatedRotation.value)\n                  } else {\n                    // Стандартная форма FAB обычно CircleShape, но оставим RoundedCornerShape, как\n                    // было\n                    FloatingActionButtonDefaults.shape\n                    //                        MaterialShapes.Cookie4Sided.toShape() // Используем\n                    // стандартную форму FAB\n                  })\n              .graphicsLayer { // Масштабируем и вращаем весь Box\n                scaleX = animatedScale\n                scaleY = animatedScale\n              },\n  ) {\n    Icon(\n        imageVector = Icons.Filled.Mic,\n        contentDescription =\n            if (uiState.isListening) \"Идет запись (Отпустите для остановки)\"\n            else \"Начать запись (Нажмите и удерживайте)\",\n        tint = animatedContentColor)\n  }\n}\n",
      "info": {
        "size": 12354,
        "last_modified": "2025-08-06T08:35:04.22734",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/ui/AIShape.kt",
      "content": "package com.lpavs.caliinda.feature.agent.ui\n\nimport androidx.compose.ui.geometry.Size\nimport androidx.compose.ui.graphics.Matrix\nimport androidx.compose.ui.graphics.Outline\nimport androidx.compose.ui.graphics.Shape\nimport androidx.compose.ui.graphics.asComposePath\nimport androidx.compose.ui.unit.Density\nimport androidx.compose.ui.unit.LayoutDirection\nimport androidx.graphics.shapes.CornerRounding\nimport androidx.graphics.shapes.RoundedPolygon\nimport androidx.graphics.shapes.star // Make sure this import works\nimport androidx.graphics.shapes.toPath\n\n// Define star parameters (you can make these configurable)\nprivate const val STAR_VERTICES = 17\nprivate val STAR_ROUNDING = CornerRounding(0.95f)\n// You might need innerRadiusRatio or other parameters for androidx.graphics.shapes.star\n// Example: Assuming a default or requiring it as a parameter\nprivate const val STAR_INNER_RADIUS_RATIO = 0.4f // Example value, adjust as needed\n\n// A shape specifically for the AI Visualizer Star\nobject AiStarShape : Shape {\n  // Cache the polygon to avoid recreating it constantly\n  private val starPolygon =\n      RoundedPolygon.star(\n          numVerticesPerRadius = STAR_VERTICES,\n          innerRadius = STAR_INNER_RADIUS_RATIO, // Adjust if needed\n          rounding = STAR_ROUNDING)\n  private val matrix = Matrix()\n\n  override fun createOutline(\n      size: Size,\n      layoutDirection: LayoutDirection,\n      density: Density\n  ): Outline {\n    // The RoundedPolygon is defined in a normalized space (e.g., radius 1)\n    // We need to scale and center it within the requested Size.\n    matrix.reset()\n    // Scale to fit the smaller dimension, maintaining aspect ratio\n    val scale = minOf(size.width, size.height) / 2f\n    matrix.scale(scale, scale)\n    // Translate to center\n    matrix.translate(size.width / (2f * scale), size.height / (2f * scale))\n\n    // Generate the path and transform it\n    val path = starPolygon.toPath().asComposePath() // Use the cached polygon\n    path.transform(matrix)\n\n    return Outline.Generic(path)\n  }\n}\n",
      "info": {
        "size": 2044,
        "last_modified": "2025-08-06T08:35:04.22912",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/ui/AIVisualiezer.kt",
      "content": "package com.lpavs.caliinda.feature.agent.ui\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.animateColor\nimport androidx.compose.animation.core.Animatable\nimport androidx.compose.animation.core.EaseInCubic\nimport androidx.compose.animation.core.EaseOutCubic\nimport androidx.compose.animation.core.LinearEasing\nimport androidx.compose.animation.core.RepeatMode\nimport androidx.compose.animation.core.Spring\nimport androidx.compose.animation.core.animateFloat\nimport androidx.compose.animation.core.infiniteRepeatable\nimport androidx.compose.animation.core.spring\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.core.updateTransition\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.scaleIn\nimport androidx.compose.animation.scaleOut\nimport androidx.compose.animation.slideInVertically\nimport androidx.compose.animation.slideOutVertically\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.aspectRatio\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.layout.widthIn\nimport androidx.compose.foundation.layout.wrapContentHeight\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport androidx.compose.material3.MaterialTheme.colorScheme\nimport androidx.compose.material3.MaterialTheme.typography\nimport androidx.compose.material3.Surface\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.TransformOrigin\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.unit.IntOffset\nimport androidx.compose.ui.unit.dp\nimport com.lpavs.caliinda.feature.agent.data.model.AiVisualizerState\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\n\n@Composable\nfun AiVisualizer(\n    aiState: AiVisualizerState,\n    aiMessage: String?,\n    modifier: Modifier = Modifier,\n    onResultShownTimeout: () -> Unit,\n    onAskingShownTimeout: () -> Unit\n) {\n  val targetState = aiState\n\n  // --- LaunchedEffect для задержки перед IDLE ---\n  LaunchedEffect(targetState) { // Запускается при смене targetState\n    if (targetState == AiVisualizerState.RESULT) {\n      delay(5000L) // Ждем 5 секунд\n      onResultShownTimeout() // Вызываем колбэк после задержки\n    }\n  }\n\n  LaunchedEffect(targetState) { // Запускается при смене targetState\n    if (targetState == AiVisualizerState.ASKING) {\n      delay(15000L) // Ждем 15 секунд\n      onAskingShownTimeout() // Вызываем колбэк после задержки\n    }\n  }\n\n  // --- 1. Animatable для вращения ---\n  val rotationAngle = remember { Animatable(0f) }\n  // LaunchedEffect для вращения остается без изменений...\n  LaunchedEffect(targetState) {\n    val shouldRotate =\n        targetState == AiVisualizerState.THINKING || targetState == AiVisualizerState.LISTENING\n    if (shouldRotate) {\n      val duration =\n          when (targetState) {\n            AiVisualizerState.THINKING -> 7000\n            AiVisualizerState.LISTENING -> 80000\n            else -> 5000 // На всякий случай\n          }\n      if (!rotationAngle.isRunning &&\n          (targetState == AiVisualizerState.THINKING ||\n              targetState == AiVisualizerState.LISTENING)) {\n        launch {\n          rotationAngle.animateTo(\n              targetValue = rotationAngle.value + 360f,\n              animationSpec =\n                  infiniteRepeatable(\n                      animation = tween(durationMillis = duration, easing = LinearEasing),\n                      repeatMode = RepeatMode.Restart))\n        }\n      }\n    } else {\n      if (rotationAngle.isRunning) {\n        launch {\n          rotationAngle.stop()\n          rotationAngle.value\n          rotationAngle.animateTo(\n              targetValue = 0f, // Возвращаем в 0 для предсказуемости\n              animationSpec = tween(durationMillis = 500, easing = EaseOutCubic))\n        }\n      }\n    }\n  }\n\n  // --- 3. Transition для управления остальными свойствами ---\n  val transition = updateTransition(targetState = targetState, label = \"AiVisualizerTransition\")\n\n  // --- Анимированные свойства ---\n  val configuration = LocalConfiguration.current\n  val screenWidthDp = configuration.screenWidthDp.dp\n  val screenHeightPx = with(LocalDensity.current) { configuration.screenHeightDp.dp.toPx() }\n\n  // --- Анимированный Фактор Масштаба ---\n  val animatedScaleFactor by\n      transition.animateFloat(\n          transitionSpec = { spring(stiffness = Spring.StiffnessMediumLow) },\n          label = \"scaleFactor\") { state ->\n            when (state) {\n              AiVisualizerState.IDLE -> 0f\n              AiVisualizerState.LISTENING -> 5f\n              AiVisualizerState.THINKING -> 1f\n              AiVisualizerState.ASKING -> 5f\n              AiVisualizerState.RESULT -> 5f\n              AiVisualizerState.ERROR -> 0f\n            }\n          }\n\n  // --- Базовый размер ---\n  val baseSizeDp = screenWidthDp * 0.4f\n\n  val animatedOffsetYRatio by\n      transition.animateFloat(\n          transitionSpec = { spring(stiffness = Spring.StiffnessMedium) },\n          label = \"offsetYRatio\") { state ->\n            when (state) {\n              AiVisualizerState.IDLE -> 0.6f\n              AiVisualizerState.LISTENING -> 0.75f\n              AiVisualizerState.THINKING -> 0.55f\n              AiVisualizerState.ASKING,\n              AiVisualizerState.RESULT -> 0.55f\n              AiVisualizerState.ERROR -> 0.6f\n            }\n          }\n\n  val animatedColor by\n      transition.animateColor(transitionSpec = { tween(durationMillis = 500) }, label = \"color\") {\n          state ->\n        when (state) {\n          AiVisualizerState.LISTENING -> colorScheme.primaryContainer\n          AiVisualizerState.THINKING -> colorScheme.secondary\n          AiVisualizerState.ASKING -> colorScheme.tertiary\n          AiVisualizerState.RESULT -> colorScheme.primary\n          else -> colorScheme.surface\n        }\n      }\n\n  // Видимость всего компонента\n  val isComponentVisible =\n      targetState != AiVisualizerState.IDLE && targetState != AiVisualizerState.ERROR\n\n  // Видимость бабла\n  val isBubbleVisible =\n      (targetState == AiVisualizerState.ASKING || targetState == AiVisualizerState.RESULT) &&\n          !aiMessage.isNullOrEmpty()\n\n  // Общий контейнер для позиционирования по Y и анимации появления/исчезания\n  AnimatedVisibility(\n      visible = isComponentVisible,\n      enter =\n          slideInVertically(\n              initialOffsetY = { it / 2 },\n              animationSpec = tween(durationMillis = 400, easing = EaseOutCubic)) +\n              fadeIn(animationSpec = tween(durationMillis = 300)),\n      exit =\n          slideOutVertically(\n              targetOffsetY = { it / 2 },\n              animationSpec = tween(durationMillis = 300, easing = EaseInCubic)) +\n              fadeOut(animationSpec = tween(durationMillis = 200)),\n      modifier = modifier) {\n        // Box для позиционирования звезды и бабла\n        Box(\n            contentAlignment = Alignment.Center,\n            modifier =\n                Modifier.fillMaxSize().offset {\n                  IntOffset(x = 0, y = (animatedOffsetYRatio * screenHeightPx / 2).toInt())\n                }) {\n              // --- 1. Анимированная Звезда (под баблом) ---\n              Box(\n                  modifier =\n                      Modifier.size(baseSizeDp).aspectRatio(1f).graphicsLayer {\n                        scaleX = animatedScaleFactor\n                        scaleY = animatedScaleFactor\n                        rotationZ = rotationAngle.value\n                        transformOrigin = TransformOrigin.Center\n                      }) {\n                    Surface(\n                        modifier = Modifier.matchParentSize().clip(AiStarShape),\n                        color = animatedColor,\n                    ) {}\n                  }\n\n              // --- 2. Бабл с текстом (поверх звезды) ---\n              AnimatedVisibility(\n                  visible = isBubbleVisible,\n                  enter =\n                      fadeIn(animationSpec = tween(delayMillis = 150, durationMillis = 300)) +\n                          scaleIn(\n                              initialScale = 0.8f,\n                              transformOrigin = TransformOrigin(0.5f, 0.5f),\n                              animationSpec = tween(delayMillis = 150, durationMillis = 300)),\n                  exit =\n                      fadeOut(animationSpec = tween(durationMillis = 150)) +\n                          scaleOut(\n                              targetScale = 0.8f,\n                              transformOrigin = TransformOrigin(0.5f, 0.5f),\n                              animationSpec = tween(durationMillis = 150)),\n                  modifier =\n                      Modifier.align(Alignment.Center)\n                          .widthIn(max = baseSizeDp * 2f)\n                          .wrapContentHeight()) {\n                    Surface(\n                        shape = RoundedCornerShape(16.dp),\n                        color = colorScheme.tertiaryContainer,\n                        tonalElevation = 2.dp,\n                        modifier = Modifier.padding(horizontal = 1.dp, vertical = 2.dp)) {\n                          Text(\n                              text = aiMessage ?: \"\",\n                              style = typography.bodyMedium,\n                              textAlign = TextAlign.Center,\n                              color = colorScheme.onTertiaryContainer,\n                              modifier =\n                                  Modifier.padding(\n                                      horizontal = 16.dp,\n                                      vertical = 12.dp) // Добавил padding для текста\n                              )\n                        }\n                  }\n            }\n      }\n}\n",
      "info": {
        "size": 10872,
        "last_modified": "2025-08-06T08:35:04.23074",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/data/model/AiVisualizerState.kt",
      "content": "package com.lpavs.caliinda.feature.agent.data.model\n\nenum class AiVisualizerState {\n  IDLE,\n  LISTENING,\n  THINKING,\n  ASKING,\n  RESULT,\n  ERROR\n}\n",
      "info": {
        "size": 147,
        "last_modified": "2025-08-06T08:35:04.234202",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "feature/agent/data/AiInteractionManager.kt",
      "content": "package com.lpavs.caliinda.feature.agent.data\n\nimport android.content.Context\nimport android.content.Intent\nimport android.os.Bundle\nimport android.speech.RecognitionListener\nimport android.speech.RecognizerIntent\nimport android.speech.SpeechRecognizer\nimport android.util.Log\nimport com.lpavs.caliinda.R\nimport com.lpavs.caliinda.app.di.IoDispatcher\nimport com.lpavs.caliinda.app.di.MainDispatcher\nimport com.lpavs.caliinda.core.data.auth.AuthManager\nimport com.lpavs.caliinda.core.data.di.BackendUrl\nimport com.lpavs.caliinda.core.data.repository.SettingsRepository\nimport com.lpavs.caliinda.feature.agent.data.model.AiVisualizerState\nimport dagger.hilt.android.qualifiers.ApplicationContext\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.DelicateCoroutinesApi\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.cancel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.first\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport okhttp3.MultipartBody\nimport okhttp3.OkHttpClient\nimport okhttp3.Request\nimport org.json.JSONException\nimport org.json.JSONObject\nimport java.io.IOException\nimport java.time.LocalDateTime\nimport java.time.ZoneId\nimport java.util.Locale\nimport javax.inject.Inject\nimport javax.inject.Singleton\n\n@Singleton\nclass AiInteractionManager\n@Inject\nconstructor(\n    @ApplicationContext private val context: Context,\n    private val okHttpClient: OkHttpClient,\n    private val authManager: AuthManager, // Для получения токена\n    private val settingsRepository: SettingsRepository, // Для получения temper\n    @BackendUrl private val backendBaseUrl: String,\n    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\n    @MainDispatcher private val mainDispatcher: CoroutineDispatcher // Нужен для SpeechRecognizer\n) {\n  private val TAG = \"AiInteractionManager\"\n  // Важно: Используем SupervisorJob, чтобы ошибка в одной корутине не отменила весь скоуп\n  private val managerScope = CoroutineScope(SupervisorJob() + ioDispatcher) // Основной скоуп для IO\n\n  // --- Состояния для ViewModel ---\n  private val _aiState = MutableStateFlow(AiVisualizerState.IDLE)\n  val aiState: StateFlow<AiVisualizerState> = _aiState.asStateFlow()\n\n  private val _aiMessage = MutableStateFlow<String?>(null) // Сообщение для UI (Asking/Result)\n  val aiMessage: StateFlow<String?> = _aiMessage.asStateFlow()\n\n  // --- SpeechRecognizer ---\n  private var speechRecognizer: SpeechRecognizer? = null\n  private val speechRecognizerIntent: Intent\n  private var isRecognizerInitialized = false\n  private var isListening = false // Внутренний флаг для управления\n\n  init {\n    Log.d(TAG, \"Initializing AiInteractionManager...\")\n    speechRecognizerIntent =\n        Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {\n          putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)\n          putExtra(\n              RecognizerIntent.EXTRA_LANGUAGE,\n              Locale.getDefault().toString()) // Или язык из настроек\n          putExtra(RecognizerIntent.EXTRA_PROMPT, \"Говорите...\")\n          putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)\n        }\n    // Инициализируем распознаватель заранее в основном потоке\n    initializeSpeechRecognizer()\n  }\n\n  // --- Публичные методы для ViewModel ---\n\n  fun startListening() {\n    if (isListening) {\n      Log.w(TAG, \"Already listening.\")\n      return\n    }\n    if (!isRecognizerInitialized) {\n      Log.w(TAG, \"Recognizer not ready, attempting to initialize...\")\n      // Попробуем инициализировать еще раз на всякий случай\n      initializeSpeechRecognizer()\n      if (!isRecognizerInitialized) {\n        Log.e(TAG, \"Cannot start listening: SpeechRecognizer failed to initialize.\")\n        // Можно передать ошибку в ViewModel через _errorEvent.emit(\"...\")\n        _aiState.value = AiVisualizerState.IDLE // Сброс состояния\n        return\n      }\n    }\n\n    Log.d(TAG, \"Attempting to start listening...\")\n    // Важно: Вызовы SpeechRecognizer должны быть на Main потоке\n    managerScope.launch(mainDispatcher) {\n      try {\n        isListening = true\n        _aiState.value = AiVisualizerState.LISTENING\n        _aiMessage.value = null // Очищаем сообщение\n        speechRecognizer?.startListening(speechRecognizerIntent)\n        Log.d(TAG, \"Called startListening on SpeechRecognizer\")\n      } catch (e: Exception) {\n        Log.e(TAG, \"Error starting listening\", e)\n        handleRecognitionError(\"Ошибка старта: ${e.message}\")\n      }\n    }\n  }\n\n  fun stopListening() {\n    if (!isListening) {\n      // Log.w(TAG, \"Not currently listening.\") // Можно не логировать\n      return\n    }\n    Log.d(TAG, \"Stopping listening (user action)...\")\n    // Вызов stopListening также на Main потоке\n    managerScope.launch(mainDispatcher) {\n      try {\n        // Не меняем isListening и _aiState здесь, это сделает listener в\n        // onEndOfSpeech/onError/onResults\n        speechRecognizer?.stopListening()\n        Log.d(TAG, \"Called stopListening on SpeechRecognizer\")\n      } catch (e: Exception) {\n        Log.e(TAG, \"Error stopping listening\", e)\n        // Возможно, стоит обработать ошибку, но обычно listener все равно сработает\n        handleRecognitionError(\"Ошибка остановки: ${e.message}\")\n      }\n    }\n  }\n\n  /** Отправляет текстовое сообщение на обработку */\n  fun sendTextMessage(text: String) {\n    if (text.isBlank()) return\n    // Проверяем состояние перед отправкой\n    if (_aiState.value == AiVisualizerState.LISTENING ||\n        _aiState.value == AiVisualizerState.THINKING) {\n      Log.w(TAG, \"Cannot send text message while listening or thinking.\")\n      return\n    }\n\n    Log.d(TAG, \"Sending text message: '$text'\")\n    // Сразу переводим в состояние THINKING\n    _aiState.value = AiVisualizerState.THINKING\n    _aiMessage.value = null // Очищаем предыдущее сообщение\n    // Запускаем отправку в IO скоупе\n    managerScope.launch { processText(text) }\n  }\n\n  /** Сбрасывает состояние AI в IDLE (например, после показа ASKING/RESULT) */\n  fun resetAiState() {\n    if (_aiState.value == AiVisualizerState.ASKING || _aiState.value == AiVisualizerState.RESULT) {\n      Log.d(TAG, \"Resetting AI state from ${_aiState.value} to IDLE\")\n      _aiState.value = AiVisualizerState.IDLE\n      _aiMessage.value = null\n    }\n  }\n\n  /** Вызывать в onCleared ViewModel */\n  @OptIn(DelicateCoroutinesApi::class)\n  fun destroy() {\n    Log.d(TAG, \"Destroying AiInteractionManager...\")\n    managerScope.cancel() // Отменяем все корутины скоупа\n    // Уничтожаем SpeechRecognizer на главном потоке\n    // Используем GlobalScope + MainDispatcher, т.к. managerScope уже может быть отменен\n    GlobalScope.launch(mainDispatcher) {\n      speechRecognizer?.destroy()\n      speechRecognizer = null\n      isRecognizerInitialized = false\n      Log.d(TAG, \"SpeechRecognizer destroyed.\")\n    }\n  }\n\n  // --- Приватные методы ---\n\n  /** Инициализация SpeechRecognizer, выполняется на Main потоке */\n  @OptIn(DelicateCoroutinesApi::class)\n  private fun initializeSpeechRecognizer() {\n    // Запускаем в GlobalScope, т.к. init может вызываться до того, как ViewModelScope будет готов\n    GlobalScope.launch(mainDispatcher) {\n      if (!SpeechRecognizer.isRecognitionAvailable(context)) {\n        Log.e(TAG, \"Speech recognition not available.\")\n        isRecognizerInitialized = false\n        return@launch\n      }\n      try {\n        if (speechRecognizer == null) { // Создаем только если еще не создан\n          speechRecognizer = SpeechRecognizer.createSpeechRecognizer(context)\n          speechRecognizer?.setRecognitionListener(recognitionListener)\n          isRecognizerInitialized = true\n          Log.d(TAG, \"SpeechRecognizer initialized successfully.\")\n        } else {\n          Log.d(TAG, \"SpeechRecognizer already initialized.\")\n          isRecognizerInitialized = true // Убедимся, что флаг установлен\n        }\n      } catch (e: Exception) {\n        Log.e(TAG, \"Failed to initialize SpeechRecognizer\", e)\n        speechRecognizer = null // Сбрасываем, если ошибка\n        isRecognizerInitialized = false\n      }\n    }\n  }\n\n  /** Обрабатывает распознанный текст (вызывается из listener) */\n  private fun processRecognizedText(text: String) {\n    if (text.isBlank()) {\n      Log.w(TAG, \"processRecognizedText called with blank text.\")\n      _aiState.value = AiVisualizerState.IDLE // Просто сброс, если текст пуст\n      return\n    }\n    Log.i(TAG, \"Processing recognized text: '$text'\")\n    // Состояние уже должно быть THINKING (установлено в onEndOfSpeech или onResults)\n    // Если нет, устанавливаем на всякий случай\n    if (_aiState.value != AiVisualizerState.THINKING) {\n      _aiState.value = AiVisualizerState.THINKING\n      _aiMessage.value = null\n    }\n    managerScope.launch {\n      processText(text) // Вызываем общую функцию обработки текста\n    }\n  }\n\n  /** Общая функция для отправки текста на бэкенд и обработки ответа */\n  private suspend fun processText(text: String) {\n    // Получаем токен\n    val freshToken = authManager.getBackendAuthToken()\n    if (freshToken == null) {\n      Log.e(TAG, \"processText failed: Could not get fresh token.\")\n      handleBackendError(\"Ошибка аутентификации\") // Обрабатываем как ошибку\n      return\n    }\n\n    // Получаем настройки\n    val currentTemper = settingsRepository.botTemperFlow.first() // Получаем последнее значение\n    val timeZoneId = settingsRepository.timeZoneFlow.first().ifEmpty { ZoneId.systemDefault().id }\n\n    Log.i(TAG, \"Sending text to /process. Temper: $currentTemper, TimeZone: $timeZoneId\")\n\n    val requestBody =\n        try {\n          MultipartBody.Builder()\n              .setType(MultipartBody.FORM)\n              .addFormDataPart(\"text\", text)\n              .addFormDataPart(\"time\", LocalDateTime.now().toString()) // Текущее время устройства\n              .addFormDataPart(\"timeZone\", timeZoneId) // Таймзона из настроек\n              .addFormDataPart(\"temper\", currentTemper) // Темперамент из настроек\n              .build()\n        } catch (e: Exception) {\n          Log.e(TAG, \"Failed to build request body\", e)\n          handleBackendError(\"Ошибка подготовки запроса\")\n          return\n        }\n\n    val request =\n        Request.Builder()\n            .url(\"$backendBaseUrl/process\")\n            .header(\"Authorization\", \"Bearer $freshToken\")\n            .post(requestBody)\n            .build()\n\n    // Выполняем запрос\n    executeProcessRequest(request)\n  }\n\n  /** Выполняет запрос к /process и обрабатывает базовые ответы/ошибки */\n  private suspend fun executeProcessRequest(request: Request) =\n      withContext(ioDispatcher) {\n        try {\n          val response = okHttpClient.newCall(request).execute()\n          val responseBodyString = response.body?.string() // Читаем тело ОДИН раз\n\n          if (!response.isSuccessful) {\n            Log.e(TAG, \"Server error processing request: ${response.code} - $responseBodyString\")\n            var errorDetail = \"Server error: (${response.code})\"\n            try {\n              if (!responseBodyString.isNullOrBlank()) {\n                val jsonError = JSONObject(responseBodyString)\n                errorDetail = jsonError.optString(\"detail\", errorDetail)\n              }\n            } catch (e: JSONException) {\n              Log.w(TAG, \"Could not parse error response body: $e\")\n            }\n            // Обрабатываем ошибку бэкенда\n            handleBackendError(errorDetail)\n          } else {\n            Log.i(TAG, \"Request processed successfully. Response: $responseBodyString\")\n            // Обрабатываем успешный ответ (парсим JSON)\n            handleProcessResponse(responseBodyString)\n          }\n        } catch (e: IOException) {\n          Log.e(TAG, \"Network error during /process request\", e)\n          handleBackendError(\"Network error: ${e.message}\")\n        } catch (e: Exception) {\n          Log.e(TAG, \"Error executing /process request\", e)\n          handleBackendError(\"Request processing error: ${e.message}\")\n        }\n      }\n\n  /** Обрабатывает успешный JSON-ответ от /process */\n  private fun handleProcessResponse(responseBody: String?) {\n    // Логика парсинга JSON и обновления _aiState и _aiMessage\n    // Взята из ViewModel, но обновляет состояния менеджера\n    var finalAiState: AiVisualizerState\n    var messageForVisualizer: String? = null\n    // var errorForViewModel: String? = null // Если нужно передавать ошибку отдельно\n\n    if (responseBody.isNullOrBlank()) {\n      Log.w(TAG, \"Empty success response from /process\")\n      // errorForViewModel = \"Пустой ответ от сервера.\"\n      finalAiState = AiVisualizerState.IDLE // Или ERROR? Решаем как обрабатывать.\n    } else {\n      try {\n        val json = JSONObject(responseBody)\n        val status = json.optString(\"status\")\n        val message = json.optString(\"message\")\n\n        when (status) {\n          \"success\" -> {\n            messageForVisualizer = \"Success!\" // Или что-то другое?\n            finalAiState = AiVisualizerState.RESULT\n            Log.i(TAG, \"Backend status: success. Message: $message\")\n            // Тут можно инициировать обновление календаря, но как?\n            // Вариант 1: ViewModel наблюдает за aiState == RESULT и вызывает refresh\n            // Вариант 2: Менеджер имеет SharedFlow для событий типа \"CalendarNeedsRefresh\"\n            // Вариант 3: Менеджер напрямую вызывает метод CalendarDataManager (не очень хорошо\n            // из-за связности)\n            // Пока оставляем на откуп ViewModel (Вариант 1)\n          }\n          \"clarification_needed\" -> {\n            messageForVisualizer = message\n            finalAiState = AiVisualizerState.ASKING\n            Log.i(TAG, \"Backend status: clarification_needed. Message: $message\")\n          }\n          \"info\",\n          \"unsupported\" -> {\n            messageForVisualizer = message\n            finalAiState = AiVisualizerState.RESULT // Показываем как результат\n            Log.i(TAG, \"Backend status: $status. Message: $message\")\n          }\n          \"error\" -> {\n            Log.e(TAG, \"Backend processing error: $message\")\n            // errorForViewModel = message\n            finalAiState = AiVisualizerState.IDLE // Сбрасываем в IDLE при ошибке\n          }\n          else -> {\n            Log.w(TAG, \"Unknown status from backend: $status\")\n            // errorForViewModel = \"Неизвестный статус ответа: '$status'\"\n            finalAiState = AiVisualizerState.IDLE\n          }\n        }\n      } catch (e: JSONException) {\n        Log.e(TAG, \"Error parsing /process response\", e)\n        // errorForViewModel = \"Ошибка парсинга ответа: ${e.message}\"\n        finalAiState = AiVisualizerState.IDLE\n      } catch (e: Exception) { // Ловим другие ошибки парсинга/обработки\n        Log.e(TAG, \"Error handling /process response content\", e)\n        // errorForViewModel = \"Ошибка обработки ответа: ${e.message}\"\n        finalAiState = AiVisualizerState.IDLE\n      }\n    }\n\n    // Обновляем состояния менеджера\n    _aiMessage.value = messageForVisualizer\n    _aiState.value = finalAiState\n\n    // Если нужно передать ошибку отдельно в ViewModel:\n    // if (errorForViewModel != null) {\n    //     managerScope.launch { _errorEvent.emit(errorForViewModel) }\n    // }\n\n    // Сбрасываем сообщение, если перешли в IDLE\n    if (_aiState.value == AiVisualizerState.IDLE) {\n      _aiMessage.value = null\n    }\n  }\n\n  /** Обрабатывает ошибку распознавания речи */\n  private fun handleRecognitionError(errorMessage: String) {\n    Log.e(TAG, \"Recognition error: $errorMessage\")\n    isListening = false // Сбрасываем флаг прослушивания\n    _aiState.value = AiVisualizerState.IDLE // Сбрасываем состояние AI\n    _aiMessage.value = null // Очищаем сообщение\n    // Можно передать ошибку в ViewModel через _errorEvent\n    // managerScope.launch { _errorEvent.emit(errorMessage) }\n  }\n\n  /** Обрабатывает ошибку сети или сервера при запросе к /process */\n  private fun handleBackendError(errorMessage: String) {\n    Log.e(TAG, \"Backend processing error: $errorMessage\")\n    _aiState.value = AiVisualizerState.IDLE // Сбрасываем состояние AI\n    _aiMessage.value = null // Очищаем сообщение\n    // Можно передать ошибку в ViewModel через _errorEvent\n    // managerScope.launch { _errorEvent.emit(errorMessage) }\n  }\n\n  // --- Recognition Listener ---\n  private val recognitionListener =\n      object : RecognitionListener {\n        override fun onReadyForSpeech(params: Bundle?) {\n          Log.d(TAG, \"Listener: onReadyForSpeech\")\n          // UI обновится через _aiState = LISTENING\n        }\n\n        override fun onBeginningOfSpeech() {\n          Log.d(TAG, \"Listener: onBeginningOfSpeech\")\n        }\n\n        override fun onRmsChanged(rmsdB: Float) {\n          /* Можно игнорировать */\n        }\n\n        override fun onBufferReceived(buffer: ByteArray?) {\n          /* Можно игнорировать */\n        }\n\n        override fun onEndOfSpeech() {\n          Log.d(TAG, \"Listener: onEndOfSpeech\")\n          // Пользователь закончил говорить, переходим в режим обработки\n          if (isListening) { // Проверяем, что мы действительно слушали\n            isListening = false // Сбрасываем флаг\n            _aiState.value = AiVisualizerState.THINKING // Меняем состояние\n            _aiMessage.value = null\n            Log.d(TAG, \"Listener: Switched state to THINKING\")\n          }\n        }\n\n        override fun onError(error: Int) {\n          if (!isListening && error == SpeechRecognizer.ERROR_NO_MATCH) {\n            // Игнорируем NO_MATCH, если мы уже не слушаем (например, после onEndOfSpeech)\n            Log.d(TAG, \"Listener: Ignored ERROR_NO_MATCH after onEndOfSpeech\")\n            return\n          }\n          val errorMessage = getSpeechRecognizerErrorText(error)\n          Log.w(TAG, \"Listener: onError: $errorMessage (code: $error)\")\n          // Обрабатываем ошибку через общую функцию\n          handleRecognitionError(errorMessage)\n        }\n\n        override fun onResults(results: Bundle?) {\n          Log.d(TAG, \"Listener: onResults\")\n          if (isListening) { // Обрабатываем только если еще слушали\n            isListening = false // Сбрасываем флаг\n            val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)\n            if (!matches.isNullOrEmpty()) {\n              val recognizedText = matches[0]\n              // Передаем текст на обработку\n              processRecognizedText(recognizedText) // Это установит state в THINKING\n            } else {\n              Log.w(TAG, \"Listener: No recognition results in bundle.\")\n              handleRecognitionError(\"Ничего не распознано\") // Обрабатываем как ошибку\n            }\n          } else {\n            Log.d(TAG, \"Listener: Ignoring onResults because listening was already stopped.\")\n          }\n        }\n\n        override fun onPartialResults(partialResults: Bundle?) {\n          val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)\n          if (!matches.isNullOrEmpty()) {\n            val partialText = matches[0]\n            // Log.d(TAG, \"Listener: Partial result: '$partialText'\")\n            // НЕ обновляем _aiMessage здесь, чтобы не мешать сообщениям Asking/Result\n            // Можно передавать partial results через отдельный Flow, если нужно для UI\n          }\n        }\n\n        override fun onEvent(eventType: Int, params: Bundle?) {\n          /* Можно игнорировать */\n        }\n      }\n\n  // Вспомогательная функция для текста ошибок SpeechRecognizer\n  private fun getSpeechRecognizerErrorText(error: Int): String {\n    return when (error) {\n      SpeechRecognizer.ERROR_AUDIO -> context.getString(R.string.speech_recognizer_error_audio)\n      SpeechRecognizer.ERROR_CLIENT -> context.getString(R.string.speech_recognizer_error_client)\n      SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS ->\n          context.getString(R.string.speech_recognizer_error_insufficient_permissions)\n      SpeechRecognizer.ERROR_NETWORK -> context.getString(R.string.speech_recognizer_error_network)\n      SpeechRecognizer.ERROR_NETWORK_TIMEOUT ->\n          context.getString(R.string.speech_recognizer_error_network_timeout)\n      SpeechRecognizer.ERROR_NO_MATCH ->\n          context.getString(R.string.speech_recognizer_error_no_match)\n      SpeechRecognizer.ERROR_RECOGNIZER_BUSY ->\n          context.getString(R.string.speech_recognizer_error_recognizer_busy)\n      SpeechRecognizer.ERROR_SERVER -> context.getString(R.string.speech_recognizer_error_server)\n      SpeechRecognizer.ERROR_SPEECH_TIMEOUT ->\n          context.getString(R.string.speech_recognizer_error_speech_timeout)\n      else -> context.getString(R.string.speech_recognizer_error_unknown, error)\n    }\n  }\n}\n",
      "info": {
        "size": 23607,
        "last_modified": "2025-08-06T08:35:04.236783",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    },
    {
      "path": "previews/Preview.kt",
      "content": "import androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material.icons.filled.Favorite\nimport androidx.compose.material.icons.filled.FavoriteBorder\nimport androidx.compose.material.icons.filled.MoreVert\nimport androidx.compose.material3.ButtonGroup\nimport androidx.compose.material3.ButtonGroupDefaults\nimport androidx.compose.material3.ExperimentalMaterial3ExpressiveApi\nimport androidx.compose.material3.FilledIconButton\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\n\n@OptIn(ExperimentalMaterial3ExpressiveApi::class) // Для ButtonGroup\n@Composable\nfun IconAndTextButtonGroupScreen() {\n  var isFavorite by remember { mutableStateOf(false) }\n  Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n    ButtonGroup(\n        overflowIndicator = { menuState ->\n          FilledIconButton(\n              onClick = {\n                if (menuState.isExpanded) {\n                  menuState.dismiss()\n                } else {\n                  menuState.show()\n                }\n              }) {\n                Icon(\n                    imageVector = Icons.Filled.MoreVert,\n                    contentDescription = \"Localized description\")\n              }\n        },\n        modifier = Modifier,\n        expandedRatio = ButtonGroupDefaults.ExpandedRatio,\n        horizontalArrangement = ButtonGroupDefaults.HorizontalArrangement,\n        {\n          clickableItem(\n              onClick = { println(\"Edit clicked\") },\n              label = \"\",\n              icon = { Icon(Icons.Filled.Edit, contentDescription = \"\") },\n              enabled = true // Можно опустить, т.к. true по умолчанию\n              )\n          // 2. Использование toggleableItem\n          toggleableItem(\n              checked = isFavorite,\n              label = \"\",\n              onCheckedChange = { newCheckedState -> isFavorite = newCheckedState },\n              icon = {\n                Icon(\n                    if (isFavorite) Icons.Filled.Favorite else Icons.Filled.FavoriteBorder,\n                    contentDescription = \"Toggle Favorite\")\n              })\n          // 3. Использование customItem\n        })\n  }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun IconAndTextButtonGroupScreenPreview() {\n  IconAndTextButtonGroupScreen()\n}\n",
      "info": {
        "size": 2790,
        "last_modified": "2025-08-06T08:35:04.241501",
        "mime_type": "text/plain",
        "extension": ".kt"
      }
    }
  ]
}